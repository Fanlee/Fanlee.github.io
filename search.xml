<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS之float属性]]></title>
    <url>%2F2017%2F05%2F12%2F2017-05-12-CSS%E4%B9%8Bfloat%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[概述 CSS的float属性可以使一个元素脱离正常的文档流，然后被安放在它所在容器的左端或者右端，并且其他的文本和行内元素环绕它。 float属性介绍 left: 元素向左浮动 float: 元素向右浮动 none: 默认值 inherit： 默认值 由于float使用了块布局， 所以它会改变display的计算值 指定值 计算值 inline block inline-block block inline-table table table-row block table-row-group block table-column block tabale-column-group block tabel-cell block table-caption block table-header-group block table-footer-group block flex flex,float对这样的元素不起作用 inline-flex inline-flex, float对这样的元素不起作用 浮动元素是如何定位的当一个元素浮动后，它会被移除正常的文档流，然后向左或是向右平移，一直平移到碰到了所处容器的边缘或者碰到另外一个浮动元素。不管一个元素是行内元素还是块级元素，如果被设置了浮动，那浮动元素会生成一个块级框，可以设置它的width和height 浮动元素的一些特性 浮动元素浮动的时候， margin不会超过包含块的padding CSS代码12.box&#123; width: 200px; height: 500px; background: lightseagreen; padding: 10px&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin: 20px&#125; HTML代码123&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt;&lt;/div&gt; 效果图 如果有多个浮动元素，后面浮动元素的margin不会超过前面浮动元素的margin, 多个浮动元素，浮动元素会按顺序排列而不发生重叠现象 CSS代码12.box&#123; width: 400px; height: 500px; background: lightseagreen; padding: 10px&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin: 10px; float: left&#125; HTML代码123456&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt;&lt;/div&gt; 效果图 如果两个元素一个左浮动，一个右浮动，左浮动元素的marginRinght和右浮动的marginLeft不会重叠 CSS代码123.box&#123; width: 219px; height: 500px; background: lightseagreen;&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin-right: 10px; float: left&#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left&#125; HTML代码1234&lt;div class="box"&gt; &lt;div class="box1"&gt;左浮动元素&lt;/div&gt; &lt;div class="box2"&gt;右浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 浮动元素重叠问题 块级元素与浮动元素发生重叠，边框和背景会显示在浮动元素之下，内容会显示在浮动元素之上CSS123.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;.box1&#123;background: blue; border: 1px solid #000&#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left; margin-top: -10px&#125; HTML1234&lt;div class="box"&gt; &lt;div class="box1"&gt;我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字&lt;/div&gt; &lt;div class="box2"&gt;右浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 行内元素与浮动元素发生重叠，其边框，背景和内容都会显示在浮动元素之上CSS123.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;span&#123; background: palevioletred; &#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left; margin-top: -10px&#125; HTML1234&lt;div class="box"&gt; &lt;span&gt;我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字&lt;/span&gt; &lt;div class="box2"&gt;浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 清除浮动的方法 增加额外的div1&lt;div style="clear: both"&gt;&lt;/div&gt; 优点：简单粗暴缺点: 增加额外的无意义的标签，不利于语义化 父级元素增加overflow: hidden(关键在于触发了BFC)1.clearfix&#123; overflow:hidden&#125; 优点：代码量少，没有额外的标签缺点： 如果子元素超出父元素的范围，会造成超出的部分被隐藏 after伪类12clearfix&#123;zoom:1&#125;clearfix:after&#123;display:block; content:""; clear:both; visibility: hidden;&#125; 优点：没有额外标签，综合起来算比较好的方法缺点：稍显复杂推荐使用这种方法 float应用场景float最初应用就是文字环绕效果CSS代码12.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;img&#123; float: left&#125; HTML代码1234&lt;div class="box"&gt; &lt;img src="demo6.png" alt=""&gt; 文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕&lt;/div&gt; 效果图 还可用于横向菜单排列，但是更推荐使用display:inline-block,除了文字环绕效果，在其他几乎所有的应用场景中，float能实现的效果，display:inline-block都能实现。推荐一篇张鑫旭大神的关于float的文章,写的特别有意思。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css之position属性]]></title>
    <url>%2F2017%2F05%2F12%2F2017-05-15-css%E4%B9%8Bposition%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[简介 position CSS属性选择用于定位元素的替代规则，被设计为对脚本动画效果有用。 语法1234567891011/* 关键字 值 */position: static;position: relative;position: absolute;position: fixed;position: sticky; //实验性API/* 全局值 */position: inherit;position: initial;position: unset; static 元素默认定位属性默认值。没有定位，元素出现在正常的文档流中，忽略top, right, bottom, left, z-index声明。 relative 相对定位相对自己文档流中的原始位置进行定位，不会脱离文档流。上图给test4加上了position:relative效果，代码如下1position: relative; top:10px; left:-20px 可以看出test4并没有对周围的元素造成影响， 它还是存在于正常的文档流中。position:relative对 table-*-group, table-row, table-column, table-cell, table-caption 元素没有效果。 absolute 绝对定位 相对于static定位以外的第一个父元素进行定位， 脱离文档流上图给test4加上了position:absolute效果明显可以看到test4从正常的文档流中脱离了出来， test5填补了test4原本的位置。 绝对定位元素可以设置外边距，且不会与其他边距合并CSS代码 12345678910111213141516171819202122body&#123; margin: 0; padding: 0;&#125;.box &#123; position: relative; width: 500px; height: 200px; background: lightseagreen; margin: 30px&#125;.box1 &#123; position: absolute; top: 0; left: 0; margin: 20px; width: 100px; height: 50px; background: red&#125;eight: 50px;background: red&#125; HTML代码123&lt;div class="box"&gt; &lt;div class="box1"&gt;absolute定位元素&lt;/div&gt;&lt;/div&gt; 效果图 stickyposition:sticky是一个新的CSS3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置CSS代码12345678910111213141516171819202122.container &#123; background: #eee; width: 600px; height: 1000px; margin: 0 auto;&#125;.sticky-box &#123; position: -webkit-sticky; position: sticky; height: 60px; margin-bottom: 30px; background: #ff7300; top: 0px;&#125;div &#123; font-size: 30px; text-align: center; color: #fff; line-height: 60px;&#125; HTML代码123456&lt;div class="container"&gt; &lt;div class="sticky-box"&gt;内容1&lt;/div&gt; &lt;div class="sticky-box"&gt;内容2&lt;/div&gt; &lt;div class="sticky-box"&gt;内容3&lt;/div&gt; &lt;div class="sticky-box"&gt;内容4&lt;/div&gt;&lt;/div&gt; 效果图因为设定的阈值是 top:0 ，这个值表示当元素距离页面视口（Viewport，也就是fixed定位的参照）顶部距离大于 0px 时，元素以 relative 定位表现，而当元素距离页面视口小于 0px 时，元素表现为 fixed 定位，也就会固定在顶部。浏览器支持情况IOS 家族（SAFARI &amp;&amp; IOS SAFARI）和 Firefox 很早开始就支持 position:sticky 了。而 Chrome53~55 则需要启用实验性网络平台功能才行。其中 webkit 内核的要添加上私有前缀 -webkit-。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的数组去重]]></title>
    <url>%2F2017%2F05%2F07%2F2017-05-07-js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[判断浏览器是否支持indexOf方法123456789101112131415161718//判断是否支持indexOf方法if(!Array.prototype.indexOf)&#123; Array.prototype.indexOf = function (item)&#123; var result = -1; //数组为空的时候返回-1 if (this.length == 0) &#123; return result; &#125;; for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] === item) &#123; //当当前项的值与参数值相等的时候，结束循环 result = i; break; &#125; &#125;; return result; &#125;;&#125; 遍历数组法：新建一新数组，遍历数组，值不在新数组中就加入新数组1234567891011function unique(array)&#123; //新建数组 var newArr = []; for(var i = 0; i &lt; arr.length; i++)&#123; //值不在新数组中就添加到新数组 if(newArr.indexOf(array[i]) == -1)&#123; newArr.push(array[i]); &#125; &#125;; return newArr &#125; 对象键值法：该方法执行速度比其他任何方法都快，就是占用内存大一些。新建一JS对象和数组，遍历传入数组时，判断值是否为JS对象的值，不是的话给对象新增该键并放入新数组。注意点，判断是否为JS对象键时，会自动对传入的键执行”toString()”,不同的键可能会被误认为一样。12345678910111213141516171819202122function unique(array)&#123; var obj = &#123;&#125;, newArr = [], len = array.length, val, type; for (var i = 0; i &lt; len; i++) &#123; val = array[i]; //获取值的数据类型 type = typeof val; //判断值是否存在 if (!obj[val]) &#123; //把type以数组的形式存入便于用indexOf对比 obj[val] = [type]; newArr.push(val); &#125; else if(obj[val].indexOf(type) &lt; 0) &#123; //值存在的情况下判断是否是相同的数据类型 obj[val].push(type); newArr.push(val); &#125; &#125; return newArr; &#125; 数组下标判断法：当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的。12345678910function unique(array)&#123; var newArr = [array[0]]; for (var i = 1; i &lt; array.length; i++) &#123; //判断第i项出现位置下标 if (array.indexOf(array[i]) == i) &#123; newArr.push(array[i]) &#125;; &#125; return newArr; &#125; 排序后相邻去除法：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。123456789101112function unique(array)&#123; //先排序 array.sort(); var newArr = [array[0]]; for (var i =1; i &lt; array.length; i++) &#123; //newArr最后一项就是array[i]的前一项 if(array[i] !== newArr[newArr.length - 1])&#123; newArr.push(array[i]); &#125;; &#125;; return newArr; &#125; 获取没重复的最右一值放入新数组。检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断1234567891011121314function unique(array)&#123; var r = []; for(var i = 0, len = array.length; i &lt; len; i++)&#123; for(var j = i + 1; j &lt; len; j++)&#123; if(array[i] === array[j])&#123; //当两个值相同的时候,i在内循环自增1，相当于跳出本次循环，执行下一次，当前值就不能添加到新数组 j = ++i; &#125;; &#125; r.push(array[i]); &#125;; return r; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>