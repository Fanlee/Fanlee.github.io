<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Javascript高级程序设计-引用类型]]></title>
      <url>/2017/06/15/2017-06-15-Javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>创建Object实例的方式有两种。</p>
<p>第一种通过new操作符后跟Object构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">'Tom'</span>;</div></pre></td></tr></table></figure></p>
<p>第二种使用对象字面量使用法。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> person = &#123;</div><div class="line">    name: <span class="string">'Tom'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在通过对象字面量定义对象的时候，实际上不会调用Object构造函数。</p>
<p>访问对象属性一般通过点表示法，也可以使用方括号表示法。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    <span class="built_in">name</span>: <span class="string">'Tom'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(person.<span class="built_in">name</span>); <span class="comment">// Tom</span></div><div class="line">console.<span class="built_in">log</span>(person[<span class="string">'name'</span>]); <span class="comment">// Tom</span></div></pre></td></tr></table></figure></p>
<p>以下情况可以使用方括号表示法：</p>
<ul>
<li><p>可以通过变量来访问属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Tom'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> propertyName = <span class="string">'name'</span>;</div><div class="line"><span class="built_in">console</span>.log(person[propertyName]); <span class="comment">// Tom</span></div></pre></td></tr></table></figure>
</li>
<li><p>属性名中包含会导致语法错误的的字符，或者属性名使用的是关键字或者保留字</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person[<span class="string">'first name'</span>] = <span class="string">'Tom'</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>创建数组的基本方式有两种：第一种是通过Array构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="comment">// 也可以省略new操作符</span></div><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>();</div></pre></td></tr></table></figure></p>
<p>可以在Array()构造函数中传入参数， 有以下几种情况：</p>
<ul>
<li><p>传递单个数值，则会按照该数值创建给定项数的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(arr.lenght); <span class="comment">// [undefined, undefined]</span></div><div class="line"><span class="built_in">console</span>.log(arr.lenght); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
</li>
<li><p>传递多个数值，则会创建包含传入数值的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2, 3, 4]</span></div><div class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
</li>
<li><p>传递其他类型的参数，则会创建包含传入参数的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"a"</span>);</div><div class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["a"]</span></div><div class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>第二种是通过数组字面量表示法。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var arr</span> = [<span class="string">'a'</span>, 2, <span class="string">'c'</span>];</div></pre></td></tr></table></figure></p>
<p>可以通过length动态的为数组添加或者删除值。<br><figure class="highlight rsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">color</span> = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line"><span class="comment">// 删除值</span></div><div class="line"><span class="keyword">color</span>.<span class="built_in">length</span> = <span class="number">2</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="keyword">color</span>); <span class="comment">//["red", "green"]</span></div><div class="line"><span class="comment">// 添加值</span></div><div class="line"><span class="keyword">color</span>[<span class="keyword">color</span>.<span class="built_in">length</span>] = <span class="string">'black'</span>;</div><div class="line"><span class="keyword">color</span>[[<span class="keyword">color</span>.<span class="built_in">length</span>]] = <span class="string">'yellow'</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="keyword">color</span>); <span class="comment">// ["red", "green", "black", "yellow"]</span></div></pre></td></tr></table></figure></p>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>检测某个对象是不是数组有以下两种方法：</p>
<ul>
<li><p>instanceof</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array.isArray()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>所有的对象都具有toLocaleString()、toString()和valueOf()方法。调用toString()方法会返回由数组中每个值的字符串拼接而成的一个以逗号分割的字符串。调用valueOf()返回的是数值的本身。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">color</span> = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">color</span>.toString()); <span class="comment">// "red,yellow,blue"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">color</span>.valueOf()); <span class="comment">// ["red", "yellow", "blue"]</span></div></pre></td></tr></table></figure></p>
<p>alert()一个数组的时候，会默认在后台调用toString()方法。</p>
<h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h3><p>join()方法可以接收一个参数，用作分隔符的字符串。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">color</span> = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>];</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">color</span>.<span class="built_in">join</span>(<span class="string">'-'</span>)); <span class="comment">// "red-yellow-blue"</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">color</span>.<span class="built_in">join</span>(<span class="string">'+'</span>)); <span class="comment">// "red+yellow+blue"</span></div></pre></td></tr></table></figure></p>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>栈是一种LIFO的数据结构。ECMAScript提供了push()和pop()方法，以便实现类似栈的行为。</p>
<h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><p>push()方法可以接受任意数量的参数，把他们逐步添加到末尾，返回修改后数组的长度。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [];</div><div class="line">var <span class="built_in">len</span> = arr.push(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>);</div><div class="line">console.<span class="built_in">log</span>(arr); // [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">len</span>); // <span class="number">3</span></div></pre></td></tr></table></figure></p>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p>pop()方法从数值末尾移除最后一项，返回移除的项。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line"><span class="keyword">var</span> item = arr.pop();</div><div class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["red", "yellow", "blue"]</span></div><div class="line"><span class="built_in">console</span>.log(item); <span class="comment">// "green"</span></div></pre></td></tr></table></figure></p>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>队列数据结构访问规则是FIFO。</p>
<h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p>移除数组的第一项并返回该项。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line"><span class="keyword">var</span> item = arr.shift();</div><div class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//  ["yellow", "blue", "green"]</span></div><div class="line"><span class="built_in">console</span>.log(item); <span class="comment">// "red"</span></div></pre></td></tr></table></figure></p>
<h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p>unshift()方法可以接受任意数量的参数，把他们逐步添加数组的前端，返回修改后数组的长度。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'red'</span>, <span class="string">'yellow'</span>];</div><div class="line"><span class="keyword">var</span> item = arr.unshift(<span class="string">'black'</span>, <span class="string">'pink'</span>);</div><div class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//["black", "pink", "red", "yellow"]</span></div><div class="line"><span class="built_in">console</span>.log(item); <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>reverse()方法能够反转数组项的顺序。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> <span class="keyword">new</span><span class="type">Arr</span> = arr.reverse();</div><div class="line">console.log(arr); <span class="comment">// [4, 3, 2, 1]</span></div><div class="line">console.log(<span class="keyword">new</span><span class="type">Arr</span>); <span class="comment">// [4, 3, 2, 1]</span></div></pre></td></tr></table></figure></p>
<p>sort()方法默认按照升序排列，排序时会调用每个数组项的toString()转型方法，然后比较得到的字符串。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr1 = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>];</div><div class="line">var arr2 = [<span class="number">5</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">1</span>];</div><div class="line">console.log(arr1.sort()); <span class="comment">// [2, 3, 4, 6]</span></div><div class="line">console.log(arr2.sort()); <span class="comment">// [1, 10, 15, 5]</span></div></pre></td></tr></table></figure></p>
<p>sort()可以接收一个比较函数作为参数，比较函数有两个参数，如果第一个参数应该位于第二个参数之前返回负数，两个参数相等返回0， 第一个参数应该位于第二个参数后面返回正数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">5</span>];</div><div class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function">(<span class="params">v1, v2</span>) =&gt;</span> v1 - v2)); <span class="comment">// [1, 5, 10, 15]</span></div><div class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function">(<span class="params">v1, v2</span>) =&gt;</span> v2 - v1)); <span class="comment">// [15, 10, 5, 1]</span></div></pre></td></tr></table></figure></p>
<p><strong>reverse()和sort()的返回值都是经过排序后的数组。</strong></p>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>concat()方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。如果传递的值不是数组，这些值就会简单的被添加到数组的末尾。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var let = [<span class="string">'red'</span>, <span class="string">'yellow'</span>];</div><div class="line">console.log(arr.concat([<span class="number">1</span>, <span class="number">2</span>], [<span class="string">'hello'</span>, <span class="string">'hi'</span>])); // [<span class="string">"red"</span>, <span class="string">"yellow"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">"hello"</span>, <span class="string">"hi"</span>]</div><div class="line">console.log(arr.concat(<span class="string">'green'</span>, <span class="string">'black'</span>)); // [<span class="string">"red"</span>, <span class="string">"yellow"</span>, <span class="string">"green"</span>, <span class="string">"black"</span>]</div></pre></td></tr></table></figure></p>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p>slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var let = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'green'</span>, <span class="string">'black'</span>];</div><div class="line">console.log(arr.slice(<span class="number">1</span>)); // [<span class="string">"yellow"</span>, <span class="string">"green"</span>, <span class="string">"black"</span>]</div><div class="line">console.log(arr.slice(<span class="number">1</span>, <span class="number">3</span>)); // [<span class="string">"yellow"</span>, <span class="string">"green"</span>]</div></pre></td></tr></table></figure></p>
<p>如果该参数为负数，则用数组长度加上该数来确认位置，如果结束位置小于起始位置，则返回空数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">let</span> = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'green'</span>, <span class="string">'black'</span>];</div><div class="line"><span class="comment">// 相当于arr.slice(0, 2)</span></div><div class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">-4</span>, <span class="number">-2</span>)); <span class="comment">// ["red", "yellow"]</span></div></pre></td></tr></table></figure></p>
<p>slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个数组。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="comment">// return Array.prototype.slice.call(arguments);</span></div><div class="line">     <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</div><div class="line"> &#125;</div><div class="line"> <span class="built_in">var</span> <span class="keyword">let</span> = <span class="built_in">list</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"> <span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure></p>
<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p>splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。有以下几种用法：</p>
<ul>
<li><p>删除： 删除任意数量的项，只需要提供两个参数，要删除的第一项和要删除的项数。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">let arr2 = arr1.splice(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line">console.log(arr1); <span class="comment">// [1, 2, 5]</span></div><div class="line">console.log(arr2); <span class="comment">// [3, 4]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>插入：可以向指定位置插入任意数量的项，只需提供三个参数，起始位置和0（要删除的项数）和要插入的项，如果要插入多项，只需在后面继续添加要插入的参数即可。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">let arr2 = arr1.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>);</div><div class="line">console.log(arr1); <span class="comment">// [1, 2, 6, 7, 3, 4, 5]</span></div><div class="line">console.log(arr2); <span class="comment">// []</span></div></pre></td></tr></table></figure>
</li>
<li><p>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需提供三个参数，起始位置，要删除的项数和要插入任意数量的项。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">let arr2 = arr1.splice(<span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>);</div><div class="line">console.log(arr1); <span class="comment">// [1, 2, 6, 7, 5]</span></div><div class="line">console.log(arr2); <span class="comment">// [3, 4]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p> splice()方法始终都会返回一个新数组，包含从原始数组中删除的项。</p>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>indexOf()和lastIndexOf()都可以接收两个参数，要查找的项和表示查找起点位置的索引。两个方法都返回要查找的项在数组中的位置，没找到返回-1。在比较第一个参数与数组中每一项时，会使用全等操作符。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var let = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</div><div class="line">console.log(arr.indexOf(<span class="number">4</span>)); <span class="comment">// 3</span></div><div class="line">console.log(arr.indexOf(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 5</span></div><div class="line">console.log(arr.indexOf(<span class="number">6</span>)); <span class="comment">// -1</span></div><div class="line">console.log(arr.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript5为数组定义了5个迭代方法，每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域。传入这些方法的函数会接收三个参数，数组项的值，该项在数组中的位置和数组对象本身。</p>
<h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><p>对数组每一项都运行给定的函数，如果函数对每一项都返回true,则返回true。every()不会改变原数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</div><div class="line"><span class="keyword">let</span> everyResult = arr.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p>对数组中每一项运行给的的函数，任一项返回ture，则返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">let</span> someResult = arr.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">3</span>)</div><div class="line"><span class="built_in">console</span>.log(someResult); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>对数组每一项都运行给定的函数，返回true的项组成的数组，不会改变原数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</div><div class="line"><span class="keyword">let</span> everyResult = arr.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">5</span>);</div><div class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// [6, 8]</span></div></pre></td></tr></table></figure></p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>对数组中的每一项运行给定的函数，没有返回值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</div><div class="line"><span class="keyword">let</span> pos = [];</div><div class="line">arr.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (item &gt; <span class="number">5</span>) &#123;</div><div class="line">        pos.push(index);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(pos); <span class="comment">// [2, 3]</span></div></pre></td></tr></table></figure></p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>对数组中的每一项运行给定的函数，返回每次函数调用结果组成的数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">let</span> mapResult = arr.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(mapResult); <span class="comment">// [2, 4, 6, 8]</span></div></pre></td></tr></table></figure></p>
<h3 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h3><p>reduce()和reduceRight()这两个方法都会迭代数组所有项，然后构建一个最终返回值。</p>
<p>这两个方法都接收两个参数，一个在每一项上调用的函数和作为缩小基础的初始值。传给reduce()和reduceRight()的函数接收四个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 15</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur, <span class="number">20</span>);</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 35</span></div></pre></td></tr></table></figure></p>
<p>和reduceRight()与reduce()作用类似，只不过方向相反而已。</p>
<h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>要创建一个日期对象，使用new操作符和Date构造函数即可，新创建的对象会自动获取当前日期和时间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div></pre></td></tr></table></figure></p>
<p>想根据特定的日期和时间创建日期对象，需要传入该日期的毫秒数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">600000000000</span>)); <span class="comment">// Thu Jan 05 1989 18:40:00 GMT+0800 (中国标准时间)</span></div></pre></td></tr></table></figure></p>
<h3 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h3><p>Date.parse() 方法解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为NaN。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">str</span> = <span class="built_in">Date</span>.parse(<span class="string">'2017-06-15'</span>);</div><div class="line">var <span class="built_in">str</span> = <span class="built_in">Date</span>.parse(<span class="string">'June 15, 2017'</span>); </div><div class="line">var <span class="built_in">str</span> = <span class="built_in">Date</span>.parse(<span class="string">'6/15/2017'</span>); </div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>); <span class="comment">//1497484800000</span></div></pre></td></tr></table></figure></p>
<p>将表示日期的字符串传给Date构造函数，会在后台默认调用Date.parse()。</p>
<h3 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h3><p>Date.UTC() 方法接受的参数同日期构造函数接受最多参数时一样，返回从1970-1-1 00:00:00 UTC到指定日期的的毫秒数。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var utcDate = new Date(Date.UTC(<span class="number">96</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</div><div class="line">console.log(utcDate); <span class="comment">// Sun Dec 01 1996 08:00:00 GMT+0800 (中国标准时间)</span></div></pre></td></tr></table></figure></p>
<h3 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h3><p>返回调用这个方法时的日期和时间的毫秒数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</div><div class="line"><span class="built_in">console</span>.log(now); <span class="comment">// 1497515369177</span></div></pre></td></tr></table></figure></p>
<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><p>返回日期的毫秒数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="built_in">console</span>.log(now.valueOf()); <span class="comment">// 1497515607459</span></div></pre></td></tr></table></figure></p>
<h3 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h3><p>日期/时间组件方法有下图这些。<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170615/164010994.png?imageslim" alt="mark"></p>
<p><img src="http://optwq0urg.bkt.clouddn.com/blog/20170615/164435910.png?imageslim" alt="mark"></p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript之深浅拷贝]]></title>
      <url>/2017/06/06/2017-06-06-Javascript%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p>在JavaScript中，对对象进行拷贝的场景比较常见。但是简单的复制语句只能对对象进行浅拷贝，即复制的是一份引用，而不是它所引用的对象。而更多的时候，我们希望对对象进行深拷贝，避免原始对象被无意修改。对象的深拷贝与浅拷贝的区别如下：</p>
<ul>
<li>浅拷贝：仅仅复制对象的引用，而不是对象本身</li>
<li>深拷贝：把复制的对象所引用的全部对象都复制一遍</li>
</ul>
<h2 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h2><h3 id="简单的复制语句"><a href="#简单的复制语句" class="headerlink" title="简单的复制语句"></a>简单的复制语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleClone</span>(<span class="params">target</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> target) &#123;</div><div class="line">      obj[attr] = target[attr];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="comment">&#123; a: &#123;a: "hello", b: 21&#125;</span> &#125;;</div><div class="line"><span class="keyword">var</span> newObj = <span class="keyword">Object</span>.assign(<span class="comment">&#123;&#125;</span>, obj);</div></pre></td></tr></table></figure></p>
<h2 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h2><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><p>最偷懒，也是浏览器层面优化比较好的方式，就是使用JSON的解析和序列化API,既简单，效率也非常高（v8层面又C++实现的解析引擎）:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(target));</div></pre></td></tr></table></figure></p>
<p>但是，这种拷贝的方法存在以下问题:</p>
<ul>
<li>一旦对象中存在函数类型（Function），此解析器会自动忽略掉Function</li>
<li>字符串化之后必须是标准类型的JSON格式</li>
<li>原型链丢失</li>
</ul>
<p>这种拷贝方式，最适合纯数据类型的对象或者数组。</p>
<h3 id="递归拷贝"><a href="#递归拷贝" class="headerlink" title="递归拷贝"></a>递归拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">initalObj, finalObj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = finalObj || &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> initalObj) &#123;</div><div class="line">      <span class="keyword">var</span> prop = initalObj[attr];</div><div class="line">      <span class="comment">// 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</span></div><div class="line">      <span class="keyword">if</span> (prop === obj) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> prop === <span class="string">'object'</span>) &#123;</div><div class="line">        obj[attr] = (prop.constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</div><div class="line">        <span class="built_in">arguments</span>.callee(prop, obj[attr]);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        obj[attr] = prop;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">initalObj, finalObj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = finalObj || &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> initalObj) &#123;</div><div class="line">        <span class="keyword">var</span> prop = initalObj[i];</div><div class="line"> </div><div class="line">        <span class="comment">// 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</span></div><div class="line">        <span class="keyword">if</span>(prop === obj) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> prop === <span class="string">'object'</span>) &#123;</div><div class="line">            obj[i] = (prop.constructor === <span class="built_in">Array</span>) ? [] : <span class="built_in">Object</span>.create(prop);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            obj[i] = prop;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript高级程序设计-变量、作用域和内存问题]]></title>
      <url>/2017/06/06/2017-06-08-Javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>Javascript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。变量的值及其数据类型可以在脚本的生命周期内改变。</p>
<h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p>ECMAScript包含两种不同数据类型的值：基本类型值和引用类型值。Javascript不允许直接访问内存中的位置，在操作对象时，实际上是操作对象的引用而不是实际的对象。</p>
<ul>
<li>基本类型值保存在栈内存中</li>
<li>引用类型值保存在堆内存中</li>
</ul>
<h3 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h3><p>定义一个基本类型值和引用类型值是一样的：创建一个变量并为该变量赋值。对于引用类型的值，我们可以为其添加属性和方法。</p>
<h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><p>从一个变量向另一个变量复制基本类型值的时候，会在变量对象上创建一个新值，两个变量可以参与任何操作而不相互影响。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> num2 = num1;</div><div class="line"><span class="built_in">console</span>.log(num1) <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<p>当从一个变量向另一个变量复制引用类型值的时候，其实复制的是对象的引用，复制操作结束后，两个变量的引用指向同一个对象。修改其中一个变量会影响到另一个变量。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;<span class="built_in">name</span>: <span class="string">'Tom'</span>&#125;;</div><div class="line">var obj2 = obj1;</div><div class="line">obj2.<span class="built_in">name</span> = <span class="string">'joy'</span>;</div><div class="line">console.<span class="built_in">log</span>(obj1.<span class="built_in">name</span>); <span class="comment">//joy</span></div></pre></td></tr></table></figure></p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript中所有参数都是按值传递的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    obj.name = <span class="string">'Tom'</span>;</div><div class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name = <span class="string">'Joy'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(obj);</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// 'Tom'</span></div></pre></td></tr></table></figure></p>
<p>当传入的参数是对象的时候，也是按值传递，如果是按引用传递的话，当obj被赋予新的对象的时候，person也会跟着变化。</p>
<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><p>检测一个变量是不是基本类型值的时候可以通过typeof操作符，注意当值为null的时候，使用typeof操作符会返回object。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></div></pre></td></tr></table></figure></p>
<p>检测是哪一种引用类型值的时候用instanceof<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">RegExp</span>();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>所有引用类型的值都是Object的实例，所以在检测引用类型值和Object构造函数的时候，始终返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">RegExp</span>();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>　执行环境定义了变量或函数有权访问的其他数据。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。<br>　全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数也随之被销毁。<br>　每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中。而在函数执行之后，栈将环境弹出，把控制权交给之前的执行环境。<br>　当代码在一个环境中执行时，会创建变量对象和一个作用域链。作用域链的用途是保证对执行环境的有权访问和所有函数和变量的有序访问。作用域链的前端始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，活动对象在最开始只包含一个变量，即arguments对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。<br>　标识符的解析是沿着作用域链一级一级搜索标识符的过程。搜索过程始终从作用域链的前端开始。然后逐级的向后回溯。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">color</span> = <span class="string">"red"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">var</span> anotherColor = <span class="string">"blue"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">var</span> tempColor = anotherColor;</div><div class="line">    &#125;;</div><div class="line">    swapColor();</div><div class="line">&#125;</div><div class="line">changeColor();</div></pre></td></tr></table></figure></p>
<p>　上面代码有三个执行环境：全局环境、changeColor()的局部环境和swapColor()的局部环境。全局环境中有变量color和函数changeColor()，changeColor()的局部环境中包含变量anotherColor和函数swapColor()，swapColor()局部环境中包含变量tempColor。swapColor()局部环境能访问他的包含环境的所有变量，而changeColor()局部环境和全局环境就不能访问swapColor()局部环境中的变量。<br>　内部环境能够通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>下面两个语句能够在作用域链的前端增加一个变量对象。该变量对象会在代码执行后被移除出。</p>
<ul>
<li>try-catch语句的catch块</li>
<li>with语句</li>
</ul>
<p>with会将指定的对象添加到作用域链中，catch会创建一个新的变量，其中包含的是被抛出的错误对象的声明。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bulidUrl</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">var</span> qs = <span class="string">"?debug=true"</span>;</div><div class="line">  <span class="keyword">with</span>(location) &#123;</div><div class="line">    <span class="built_in">var</span> <span class="built_in">url</span> = href + qs;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">url</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(bulidUrl()) <span class="comment">// http://localhost:63342/test/93.html?_ijt=butdjev1qf9q4jjb9qetp365sp?debug=true</span></div></pre></td></tr></table></figure></p>
<p>with语句接收的是location对象，因此变量对象中就包含了所有location对象的属性和方法。其中的href就是location.href。</p>
<h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><p>Javascript没有块级作用域，for语句初始化变量的表达式所定义的变量，在循环外部的执行环境也能访问到。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><p>使用var声明的变量会自动被添加到最接近的环境中。如果初始化变量没有用var声明，该变量会自动被添加到全局环境。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    num = num1 + num2;</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 30</span></div><div class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 30</span></div></pre></td></tr></table></figure></p>
<h4 id="查询标识符"><a href="#查询标识符" class="headerlink" title="查询标识符"></a>查询标识符</h4><p>搜索过程从作用域链的前端开始，向上逐级查询与给的名字匹配的标识符。<br>如果在局部环境没有找到标识符，则沿着作用域链向上搜索。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">color</span> = <span class="string">"red"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">color</span>;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(sayColor()); <span class="comment">//color</span></div></pre></td></tr></table></figure></p>
<p>如果在局部环境找到标识符，则停止搜索。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">color</span> = <span class="string">"red"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">var</span> <span class="built_in">color</span> = <span class="string">"blue"</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">color</span>;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(sayColor()); <span class="comment">//blue</span></div></pre></td></tr></table></figure></p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>Javascript具有自动垃圾收集机制。执行环境会负责管理代码执行过程中使用的内存。离开作用域的值将被自动标记为可回收，因此将在垃圾收集期间被删除。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>Javascript最常用的垃圾收集方式是标记清除。这种算法的思想是给当前不用的值加上标记，然后再回收其内存。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>这种算法的思想是跟踪所有的值被引用的次数。Javascript引擎目前都不再使用这种算法。</p>
<h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>优化内存占用的最佳方式是解除引用，就是一旦数据不再使用，手动将值设置为null来释放引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    localPerson.name = name;</div><div class="line">    <span class="keyword">return</span> localPerson;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> globalPerson = createPerson(<span class="string">'Tom'</span>);</div><div class="line"></div><div class="line">globalPerson = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用的正在目的是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript高级程序设计-基础概念]]></title>
      <url>/2017/06/02/2017-06-02-Javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><p>ECMAScript是区分大小写的，包括变量，函数名和操作符。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符指的是函数，变量，属性的名字。必须要遵循以下规则：</p>
<ol>
<li>第一个字符必须是字母、下划线、或者美元符号</li>
<li>其他字符可以是字符、下划线、美元符号或者数字</li>
</ol>
<p>标识符推荐采用驼峰大小写格式。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单行注释</span></div></pre></td></tr></table></figure></p>
<p>块级注释<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 块级注释</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>除了正常运行模式，ECMAScript5添加了第二种正常运行模式：“严格模式”。<br>设立严格模式的目的：</p>
<ul>
<li>消除Javascript语法一些不合理、不严谨的地方，减少一些怪异的行为</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全</li>
<li>提高编译器效率，增加运行速度</li>
<li>为未来的新版本Javascript做好铺垫</li>
</ul>
<p>严格模式有两种调用方法：</p>
<ol>
<li><p>整个脚本启用严格模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>函数内部启用严格模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">   "use strict"</span>;</div><div class="line">&#125;())</div></pre></td></tr></table></figure>
</li>
</ol>
<p>不管在什么情况下启用严格模式都必须放在第一行，否则不会生效。</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>ECMAScript中的语句以分号结尾，虽然可以不写，但是不推荐。分号加与不加完全取决于个人习惯，但为了代码稳定（解析出错）还是建议使用分号断句。<br>Javascript自动加分号规则：</p>
<ol>
<li>当有换行符（包括含有换行符的多行注释），并且下一个token没法跟前面的语法匹配时，会自动补分号。</li>
<li>当有}时，如果缺少分号，会补分号。</li>
<li>当程序源代码结束时，如果缺少分号，会补分号。<br>结论：<ol>
<li>在return、break、continue、后自增、后自减五种语句中，换行符可以完全替代分号的作用。</li>
<li>var、if、do、while、for、continue、break、return、with、switch、throw、try、 debugger几种关键字开头的语句，以及空语句，上一行加不加分号影响不大。</li>
<li>凡表达式语句和函数表达式语句，后面不加分号非常危险，情况极其复杂。</li>
<li>凡(和[开头的语句，前面不加分号极度危险。</li>
</ol>
</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript变量是松散类型的，可以用来保存任何类型的数据。声明变量要使用var操作符后跟变量名。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">message</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码是未初始化变量，会保存特殊值“undefined”。<br>也可以在声明的时候直接初始化变量。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var message</span> = <span class="string">"hi"</span>;</div></pre></td></tr></table></figure></p>
<p>使用var声明的变量会成为定义该变量作用域的局部变量。在函数中通过var声明的变量会在函数退出后销毁。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line">test();</div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Uncaught ReferenceError: a is not defined</span></div></pre></td></tr></table></figure></p>
<p>上面代码如果省略var就会创建一个全局变量，在全局作用于内任何地方都能访问到。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  a = <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line">test();</div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>一条语句可以定义多个变量，通过逗号分割开。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var <span class="attr">a</span> = <span class="number">1</span>,</div><div class="line">    <span class="attr">b</span> = <span class="number">2</span>,</div><div class="line">    <span class="attr">c</span> = <span class="string">"hello"</span>;</div></pre></td></tr></table></figure></p>
<p>严格模式下，定义名为eval和arguments的变量会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="string">"hello"</span> <span class="comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span></div></pre></td></tr></table></figure></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript有5种基本数据类型：Undefined、Null、Boolean、Number、String和一种引用数据类型：Object。</p>
<h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>用来检测变量的数据类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="keyword">var</span> b = <span class="string">'hi'</span>;</div><div class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> d = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> e = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> <span class="built_in">RegExp</span>;</div><div class="line"><span class="keyword">var</span> h = <span class="literal">null</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">// string</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c); <span class="comment">// number</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> d); <span class="comment">// boolean</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> e); <span class="comment">// object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f); <span class="comment">// function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> g); <span class="comment">// object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> h); <span class="comment">// object</span></div></pre></td></tr></table></figure></p>
<p>typeof null会返回object,因为null被认为是一个空的对象。</p>
<h3 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h3><p>使用var声明变量时未进行初始化，这个变量的值就是undefined。主要用来区分空对象指针与未经初始化的变量。<br>未初始化的变量和未定义的变量是不一样的，直接使用未定义的变量会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Uncaught ReferenceError: b is not defined</span></div></pre></td></tr></table></figure></p>
<h3 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h3><p>null表示一个对象的空指针，如果定义的变量将来用于保存对象，最好将该变量初始化为null。<br>undefined的值派生自null，所以相等测试返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">null</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>Boolean类型有两个字面值：true和false。ECMAScript所有类型的值都能通过Boolean()转型函数转换为Boolean值。<br>转换规则如下：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:center">转化为true的值</th>
<th style="text-align:center">转化为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:center">非空字符串</td>
<td style="text-align:center">“”（空字符串）</td>
</tr>
<tr>
<td>Number</td>
<td style="text-align:center">非零数字</td>
<td style="text-align:center">0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td style="text-align:center">任何对象</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td>Undefined</td>
<td style="text-align:center">不能转化为true</td>
<td style="text-align:center">Undefined</td>
</tr>
</tbody>
</table>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>Number类型使用IEEE754来表示整数和浮点数。<br>整数可以通过十进制、八进制、十六进制来表示。<br>八进制第一位必须是0，后面是八进制数字序列（0~7），如果数值超出了范围，则省略前导的0，后面数字以十进制解析。<strong>八进制在严格模式下无效，会抛出异常</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">070</span>) <span class="comment">// 56</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">079</span>); <span class="comment">// 79</span></div></pre></td></tr></table></figure></p>
<p>十六进制前两位必须是0x开头，后面是十六进制数字序列（0~7及A~F）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">0xA</span>); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<h4 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h4><p>浮点数值需要的内存空间是整数的两倍，所以ECMAScript会将小数点后没有数字的（如1.）和本身就表示一个整数的（如1.0）的浮点数值转化为整数。<br>可以用科学计数法表示极大或者极小的浮点数值。默认情况下ECMAScript会将小数点后带有6个零以上的浮点数在转化为e表示法。如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">3.12e7</span>) <span class="comment">// 31200000</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">3.12e-6</span>) <span class="comment">// 0.00000312</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">3.12e-7</span>) <span class="comment">// 3.12e-7</span></div></pre></td></tr></table></figure></p>
<p>浮点数值在任何机器的上都不能直接判断相等，最好通过精度来判断。</p>
<h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p><code>ECMAScripot</code>的数值范围在<code>Number.MIN_VALUE</code>和<code>Number.MAX_VALUE</code>之间，如果超出这个范围， 将会被转换成<code>Infinity</code>值，该值不能用于计算，要想确定一个值是否是有穷的，通过<code>isFinite()</code>判断，函数参数位于最大值与最小值之间返回<code>true</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE); <span class="comment">// 5e-324</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE); <span class="comment">// 1.7976931348623157e+308</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="built_in">Number</span>.MIN_VALUE + <span class="built_in">Number</span>.MIN_VALUE)); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>这个数值表示一个本来要返回数值的操作数未返回数值的情况。</p>
<ol>
<li>任何涉及到NaN的操作都会返回<code>NaN</code></li>
<li><code>NaN</code>与任何值都不相等，包括自身<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>ECMAScript</code>定义了<code>isNaN()</code>函数，该函数接收一个参数，会尝试将这个参数转换成数值，转换成功返回<code>false</code>, 失败返回<code>true</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'10'</span>)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'color'</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p>有三个函数可以把非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>和<code>parseFloat()</code>。<code>Number()</code>可用于任何数据类型，另两个则专门用于把字符串转换成数值。</p>
<p><code>Number()</code>转换规则如下：</p>
<ol>
<li>如果是Boolean值，则把<code>true</code>和<code>false</code>转换成1和0</li>
<li>如果是数值，返回本身</li>
<li>如果是<code>Null</code>， 返回0</li>
<li>如果是<code>undefined</code>，返回<code>NaN</code></li>
<li><p>如果是字符串，则有一下几种情况</p>
<ul>
<li>如果字符串中只包含数字，则转换成对应十进制</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10"</span>)); <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"+10"</span>)); <span class="comment">//10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"-10"</span>)); <span class="comment">// -10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"010"</span>)); <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<ul>
<li>如果字符串中包含有效的浮点格式，则转换成对应的浮点数值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10.3"</span>)); <span class="comment">// 10.3</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"+10.3"</span>)); <span class="comment">// 10.3</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"-10.3"</span>)); <span class="comment">//-10.3</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"010.3"</span>)); <span class="comment">// 10.3</span></div></pre></td></tr></table></figure>
<ul>
<li>如果字符串中包含有效的十六进制格式，则转换成相同大小的十进制整数值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"0xF"</span>)); <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<ul>
<li>如果字符串为空，则转换为0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">" "</span>)); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<ul>
<li>字符串中包含除上述格式之外的字符， 则转换为<code>NaN</code></li>
</ul>
</li>
<li>如果是对象， 则调用对象的<code>valueOf()</code>方法，然后按照前面规则转换，如果转换结果是<code>NaN</code>，则调用对象的<code>toString()</code>方法，再次依照前面规则转换。日期对象会转换成相应的毫秒数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(now)); <span class="comment">// 1495076392196</span></div></pre></td></tr></table></figure>
<p><code>parseInt()</code>函数在转换字符串时会忽略字符串前面的空格，直到找到第一个非空格字符串。如果第一个字符不是数字字符或者负号，就会返回<code>NaN</code>，如果第一个字符是数字字符，<code>parseInt()</code>会继续解析后面的字符，直到解析完所有字符或者遇到非数字字符。<code>parseInt()</code>解析空字符串会返回<code>NaN</code>。同样，<code>parseInt()</code>也能辨别各种整数格式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">""</span>)); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"123abc"</span>)); <span class="comment">// 123</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"abc123"</span>)); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10.2"</span>)); <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"070"</span>)); <span class="comment">// 70 (ECMAScript5已经不具备解析八进制的能力，所以认为前导的0无效)</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"0xFWQR"</span>)); <span class="comment">// 15</span></div></pre></td></tr></table></figure></p>
<p><code>parseInt()</code>可以接受第二个参数来指定整数的格式。默认是转换成十进制。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">2</span>)); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">8</span>)); <span class="comment">// 8</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">10</span>)); <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">16</span>)); <span class="comment">// 16</span></div></pre></td></tr></table></figure></p>
<p><code>parseFloat()</code>函数与<code>parseInt()</code>类似，不同的是<code>parseFloat()</code>解析完成或者遇到第一个无效的浮点数字字符为止，但是第一个小数点是有效的。<code>parseFloat()</code>始终会忽略前导的零，十六进制的字符串始终会被转换成0，由于<code>parseFloat()</code>只解析十进制值，所以不能指定第二个参数，如果字符串包含的是一个可解析成整数的数值，<code>parseFloat()</code>会返回整数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"123abc"</span>)); <span class="comment">// 123</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"0xF"</span>)); <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10.5"</span>)); <span class="comment">// 10.5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10.5.5"</span>)); <span class="comment">// 10.5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"010.5"</span>)); <span class="comment">// 10.5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10.0"</span>)); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p><code>String</code>由零或者多个16为Unicode字符组成的字符序列，可以用双引号或者单引号表示。</p>
<h4 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h4><p>字符串是不可变的，要改变某个变量保存的字符串首先要先销毁原来的字符串。然后用新值填充该变量。</p>
<h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><p>可以通过<code>toString()</code>将<code>Number</code>、<code>Boolean</code>、<code>Object</code>和<code>String</code>类型的数据转换为字符串，该方法可以接收一个参数：输出数值的基数。<br>在不知道值是不是<code>Null</code>或<code>Undefined</code>的情况下，可以通过<code>String()</code>方法进行转换。转换规则如下：</p>
<ul>
<li>如果值有<code>toString()</code>方法，则直接调用该方法</li>
<li>如果值为<code>null</code>，返回<code>null</code></li>
<li>如果值为<code>undefined</code>，返回<code>undefined</code></li>
</ul>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>ECMAScript对象就是一组数据和功能的集合。<br>可以通过<code>new</code>操作符后跟要创建的对象类型的名称来创建。创建<code>Object</code>类型的实例并为其添加属性和方法就可以创建自定义对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"Tom"</span>;</div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">person.sayName(); <span class="comment">// Tom</span></div></pre></td></tr></table></figure></p>
<p><code>Object</code>类型是所有它的实例的基础，它所具有的所有属性和方法都能被实例所共享。<br><code>Object</code>每个实例都有一下属性和方法：</p>
<ul>
<li><p>constructor: 保存着用于创建当前对象的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="built_in">console</span>.log(obj.constructor === <span class="built_in">Object</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>hasOwnProperty(): 检查给定属性是否存在当前实例中，如果存在于原型中返回true，实例本身属性返回false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.name = <span class="string">"Tom"</span>;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line">person.age = <span class="number">20</span>;</div><div class="line"><span class="built_in">console</span>.log(Person.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(Person.hasOwnProperty(<span class="string">"age"</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
<li><p>isPrototypeOf(): 用于检查传入的对象是否是另一个对象的原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Foo.prototype = <span class="keyword">new</span> Bar();</div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div><div class="line"><span class="built_in">console</span>.log(Bar.prototype.isPrototypeOf(f1)) <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>propertyIsEnumerable(): 检查给定的属性能否通过<code>for-in</code>来枚举</p>
<ol>
<li>这个属性必须属于实例的，并且不属于原型。</li>
<li>这个属性必须是可枚举的，也就是自定义的属性。</li>
<li>如果对象没有指定的属性，该方法返回false</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.name = <span class="string">'Tom'</span>;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">p1.age = <span class="number">20</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> p1) &#123;</div><div class="line"><span class="built_in">console</span>.log(attr) <span class="comment">// age name</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(p1.propertyIsEnumerable(<span class="string">'age'</span>))  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(p1.propertyIsEnumerable(<span class="string">'name'</span>)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(p1.propertyIsEnumerable(<span class="string">'toString'</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<ul>
<li>toLocaleString(): 返回对象的字符串表示法，该字符串与执行环境的地区对应</li>
<li>toString(): 返回对象的字符串表示</li>
<li>valueOf(): 返回对象的字符串、数值和布尔值表示</li>
</ul>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只能操作一个值的操作符叫做一元操作符。分为递增和递减操作符，递增和递减操作符又有前置型和后置型两种。<br>前置型：递增和递减操作在语句求值之前执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>,</div><div class="line">    num2 = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> num3 = --num1 + num2;</div><div class="line"><span class="keyword">var</span> num4 = num1 + num2;</div><div class="line"><span class="built_in">console</span>.log(num3); <span class="comment">// 11</span></div><div class="line"><span class="built_in">console</span>.log(num4); <span class="comment">// 11</span></div></pre></td></tr></table></figure></p>
<p>后置型：递增和递减操作在语句求值之后执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>,</div><div class="line">    num2 = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> num3 = num1-- + num2;</div><div class="line"><span class="keyword">var</span> num4 = num1 + num2;</div><div class="line"><span class="built_in">console</span>.log(num3); <span class="comment">// 12</span></div><div class="line"><span class="built_in">console</span>.log(num4); <span class="comment">// 11</span></div></pre></td></tr></table></figure></p>
<p>这四个操作符对任何值都适用，内部默认调用Number()进行转换。</p>
<h4 id="一元加和减操作符"><a href="#一元加和减操作符" class="headerlink" title="一元加和减操作符"></a>一元加和减操作符</h4><p>一元加操作符以一个加号表示，放在数值前面。对数值不会产生任何影响。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">20</span>;</div><div class="line"><span class="built_in">num</span> = +<span class="built_in">num</span>;</div><div class="line">console.log(<span class="built_in">num</span>) <span class="comment">// 20</span></div></pre></td></tr></table></figure></p>
<p>如果是非数值则内部调用<code>Number()</code>进行数据类型转化。</p>
<p>一元减操作符用于将一个数值转化为负数<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">20</span>;</div><div class="line"><span class="built_in">num</span> = -<span class="built_in">num</span>;</div><div class="line">console.log(<span class="built_in">num</span>) <span class="comment">// -20</span></div></pre></td></tr></table></figure></p>
<p>如果是非数值则先内部调用<code>Number()</code>进行数据类型转化，然后再变为负数。</p>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p><code>ECMAScript</code>中所有数值都以IEEE-754 64位格式存储，但位操作符不直接操作64位的值，而是将64位值转换为32位的整数，操作完成后再转换为64位。<br>对于有符号的整数，前31位表示整数的值，第32位表示符号：0表示正数，1表示负数。表示符号的叫符号位。正数以纯二进制格式存储，31位中的每一位都表示2的幂，没有用到的位以0填充，忽略不计。<br>二进制转化成十进制如下<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">10010</span> =&gt; (<span class="number">2</span>⁴*<span class="number">1</span>)+(<span class="number">2</span>³*<span class="number">0</span>)+(<span class="number">2</span>²*<span class="number">0</span>)+(<span class="number">2</span>¹*<span class="number">1</span>)+(<span class="number">2</span>⁰*<span class="number">0</span>)</div><div class="line">            <span class="number">16</span> +  <span class="number">0</span>   +   <span class="number">0</span>  +   <span class="number">2</span>   +  <span class="number">0</span> = <span class="number">18</span></div></pre></td></tr></table></figure></p>
<p>负数是用二进制的补码进行存储。计算一个数值的二进制补码需要经过下面步骤：</p>
<ol>
<li>求这个数值绝对值的二进制码</li>
<li>求二进制的反码，即0替换成1，1替换成0</li>
<li>得到二进制反码加1</li>
</ol>
<p>求-18的二进制码步骤如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)先取到<span class="number">18</span>的二进制码</div><div class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0010</span></div><div class="line">(<span class="number">2</span>)取其反码</div><div class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span> <span class="number">1101</span></div><div class="line">(<span class="number">3</span>)反码加一</div><div class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span> <span class="number">1101</span></div><div class="line">                                      <span class="number">1</span></div><div class="line">----------------------------------------</div><div class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span></div></pre></td></tr></table></figure>
<h4 id="按位非（-）"><a href="#按位非（-）" class="headerlink" title="按位非（~）"></a>按位非（~）</h4><p>执行按位非的结果返回数值的反码，按位非的本质是操作数的负值减1。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> num2 = ~num1;</div><div class="line"><span class="built_in">console</span>.log(num2); <span class="comment">// -3</span></div></pre></td></tr></table></figure></p>
<p>浮点数取整<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(~~<span class="number">3.14</span>); <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(~~<span class="number">-3.14</span>); <span class="comment">//-3</span></div></pre></td></tr></table></figure></p>
<p>indexOf判断字符是否存在<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">str</span> = <span class="string">"hello"</span>;</div><div class="line"><span class="keyword">if</span>(~<span class="keyword">str</span>.indexOf(<span class="string">'e'</span>))&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="按位与（-amp-）"><a href="#按位与（-amp-）" class="headerlink" title="按位与（&amp;）"></a>按位与（&amp;）</h4><p>按位与的操作是将两个数值的每一位对齐，两个数的值为1时，才返回1，其他为零。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="code">  var result = 3 &amp; 5;</span></div><div class="line"><span class="code">  console.log(result) // 1</span></div><div class="line"><span class="code">  </span></div><div class="line"><span class="code">  0011</span></div><div class="line"><span class="section">&amp; 0101</span></div><div class="line">------</div><div class="line"><span class="code">  0001</span></div></pre></td></tr></table></figure></p>
<p>可以用一个数和1进行按位&amp;操作来判断一个数是奇数还是偶数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"奇数"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"偶数"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为奇数的最后一位肯定是1，而1只有最后一位为1，按位&amp;操作之后，结果肯定只有最后一位数为1。而偶数的二进制表示的最后一位数是0，和1进行按位&amp;操作，结果所有位数都为0。</p>
<h4 id="按位或（-）"><a href="#按位或（-）" class="headerlink" title="按位或（|）"></a>按位或（|）</h4><p>只要两个数中有一个数为1，结果就为1，其他则为0。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="code">  0001</span></div><div class="line"><span class="section">| 0011</span></div><div class="line">------</div><div class="line"><span class="code">  0011</span></div></pre></td></tr></table></figure></p>
<p>可以用来对浮点数向下求整<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">1.1</span> | <span class="number">0</span>; <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<h4 id="按位异或（-）"><a href="#按位异或（-）" class="headerlink" title="按位异或（^）"></a>按位异或（^）</h4><p>按位异或是两个数中只有一个1时返回1，其他情况返回0。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="code">  0001</span></div><div class="line"><span class="section">^ 0011</span></div><div class="line">-------</div><div class="line"><span class="code">  0010</span></div></pre></td></tr></table></figure></p>
<p>可以用来调换两个数值的值。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var num1 = <span class="number">1</span>,</div><div class="line">    num2 = <span class="number">2</span><span class="comment">;</span></div><div class="line">num1 ^= num2<span class="comment">;</span></div><div class="line">num2 ^= num1<span class="comment">;</span></div><div class="line">num1 ^= num2<span class="comment">;</span></div><div class="line">console.log(num1)<span class="comment">; // 2</span></div><div class="line">console.log(num2)<span class="comment">; // 1</span></div></pre></td></tr></table></figure></p>
<h4 id="有符号左移（-lt-lt-）"><a href="#有符号左移（-lt-lt-）" class="headerlink" title="有符号左移（&lt;&lt;）"></a>有符号左移（&lt;&lt;）</h4><p>有符号左移会将32位二进制数的所有位向左移动指定位数。如：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">2</span>; <span class="comment">// 二进制10</span></div><div class="line"><span class="built_in">num</span> = <span class="built_in">num</span> &lt;&lt; <span class="number">5</span>; <span class="comment">// 二进制1000000，十进制64</span></div></pre></td></tr></table></figure></p>
<p>如果要求2的n次方，可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">power</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; n;</div><div class="line">&#125;</div><div class="line">power(<span class="number">5</span>); <span class="comment">// 32</span></div></pre></td></tr></table></figure></p>
<h4 id="有符号右移（-gt-gt-）"><a href="#有符号右移（-gt-gt-）" class="headerlink" title="有符号右移（&gt;&gt;）"></a>有符号右移（&gt;&gt;）</h4><p>有符号右移会将32位二进制数的所有位向右移动指定位数。如：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">64</span>; <span class="comment">// 二进制1000000</span></div><div class="line"><span class="built_in">num</span> = <span class="built_in">num</span> &gt;&gt; <span class="number">5</span>; <span class="comment">// 二进制10，十进制2</span></div></pre></td></tr></table></figure></p>
<p>可以用来求一个数的二分之一<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">10</span> &gt;&gt; <span class="number">1</span>; <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h4 id="无符号右移（-gt-gt-gt-）"><a href="#无符号右移（-gt-gt-gt-）" class="headerlink" title="无符号右移（&gt;&gt;&gt;）"></a>无符号右移（&gt;&gt;&gt;）</h4><p>正数的无符号右移与有符号右移结果是一样的。负数的无符号右移会把符号位也一起移动，而且无符号右移会把负数的二进制码当成正数的二进制码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">-64</span>; <span class="comment">// 11111111111111111111111111000000</span></div><div class="line"><span class="built_in">num</span> = <span class="built_in">num</span> &gt;&gt;&gt; <span class="number">5</span>; <span class="comment">// 134217726</span></div></pre></td></tr></table></figure></p>
<p>可以利用无符号右移来判断一个数的正负：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="title">isPos</span>(n) &#123;</div><div class="line"><span class="keyword">return</span> <span class="type">(n</span> === (n &gt;&gt;&gt; <span class="number">0</span>)) ? <span class="literal">true</span> : <span class="type">false</span>; 	</div><div class="line">&#125;</div><div class="line"></div><div class="line">isPos(-<span class="number">1</span>); // <span class="literal">false</span></div><div class="line">isPos(<span class="number">1</span>); // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>-1&gt;&gt;&gt;0虽然没有向右移动位数，但-1的二进制码已经变成了正数的二进制码,所以不会相等。</p>
<p>应该尽量少用位操作符进行运算，这会导致代码阅读困难。</p>
<h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><p>布尔操作符一共有三个：非（!）、与（&amp;&amp;）、或（||）。</p>
<h4 id="逻辑非（-）"><a href="#逻辑非（-）" class="headerlink" title="逻辑非（!）"></a>逻辑非（!）</h4><p>逻辑非会将操作数转化为布尔值，然后对其求反。转换规则与<code>Boolean()</code>函数类似。<br><code>!!</code>会将一个数转换为Boolean值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(!!<span class="string">"hello"</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(!!<span class="literal">NaN</span>); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(!!<span class="string">""</span>); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(!!<span class="number">10</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h4 id="逻辑与（-amp-amp-）"><a href="#逻辑与（-amp-amp-）" class="headerlink" title="逻辑与（&amp;&amp;）"></a>逻辑与（&amp;&amp;）</h4><p>逻辑与有两个操作数。只要其中有一个为false，则返回false。<br>在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值，遵循以下规则：</p>
<ul>
<li>第一个操作数是对象，则返回第二个操作数</li>
<li>第二个操作数是对象，则在第一个操作数求值结果为true的情况下返回该对象</li>
<li>两个操作数都是对象，则返回第二个</li>
<li>如果有一个操作数为null,则返回null</li>
<li>如果有一个操作数为NaN,则返回NaN</li>
<li>如果有一个操作数为Undefined,则返回Undefined</li>
</ul>
<p>逻辑与属于短路操作，第一个操作数为false，就不会对第二个操作数求值。</p>
<h4 id="逻辑或（-）"><a href="#逻辑或（-）" class="headerlink" title="逻辑或（||）"></a>逻辑或（||）</h4><p>逻辑或有两个操作数。只要其中有一个为true，则返回true。</p>
<p>在有一个操作数不是布尔值的情况下，逻辑或操作不一定返回布尔值，遵循以下规则：</p>
<ul>
<li>第一个操作数是对象，则返回第一个操作数</li>
<li>第一个操作数求值结果为false，则返回第二个操作数</li>
<li>两个操作数都是对象，则返回第一个</li>
<li>如果有一个操作数为null,则返回null</li>
<li>如果有一个操作数为NaN,则返回NaN</li>
<li>如果有一个操作数为Undefined,则返回Undefined</li>
</ul>
<p>逻辑或也属于短路操作，第一个操作为true，就不会对第二个操作数求值。<br>可以利用这一行为避免为变量赋null和undefined值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> result = obj || &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">// object</span></div></pre></td></tr></table></figure></p>
<h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><p>ECMAScript定义了三个乘性操作符：乘法、除法和求模。在操作数是非数值的情况下会默认在内部调用Number()函数进行数据类型的转换。</p>
<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>处理特殊值乘法操作遵循一下规则：</p>
<ul>
<li><p>如果乘积超过ECMAScript数值范围，则返回Infinity或者-Infinity</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>.MAX_VALUE;</div><div class="line"><span class="keyword">var</span> result = num * <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">// Infinity</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果有一个操作数为NaN，则返回NaN</p>
</li>
<li>如果是Infinity与0相乘， 则返回NaN</li>
<li>如果是Infinity与非0相乘，则返回Infinity或者-Infinity</li>
<li>如果一个操作数不是数值，则在内部调用Number()将其转换为数值，再应用上面规则</li>
</ul>
<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>处理特殊值乘法操作遵循一下规则：</p>
<ul>
<li>如果乘积超过ECMAScript数值范围，则返回Infinity或者-Infinity</li>
<li>如果有一个操作数为NaN，则返回NaN</li>
<li>如果是Infinity被Infinity除，则结果是NaN</li>
<li>如果是0被0除，结果是NaN</li>
<li>如果是非0的有限数被0除，则返回Infinity或者-Infinity</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(<span class="number">100</span> / <span class="number">0</span>); <span class="comment">// Infinity</span></div></pre></td></tr></table></figure>
<ul>
<li><p>如果是Infinity被任何非零的数除，则返回Infinity或者-Infinity</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="literal">Infinity</span> / <span class="number">100</span>); <span class="comment">//Infinity</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果一个操作数不是数值，则在内部调用Number()将其转换为数值，再应用上面规则</p>
</li>
</ul>
<h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><p>加性操作符分为加法和减法。加性操作符和乘性操作符类似，也会在后台转换不同的数据类型</p>
<h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>如果两个操作符都是数值，返回下列结果：</p>
<ul>
<li>如果有一个操作数是NaN，则结果是NaN</li>
<li>Infinity加Infinity，结果是Infinity</li>
<li>-Infinity加-Infinity，结果是-Infinity</li>
<li>Infinity加-Infinity，结果是NaN</li>
<li>+0加+0，结果是+0</li>
<li>-0加-0，结果是-0</li>
<li>+0加-0，结果是+0</li>
</ul>
<p>如果有一个操作符是字符串，就要应用如下规则：</p>
<ul>
<li>两个操作符都是字符串，则把他们两个拼接起来</li>
<li>如果只有一个操作符是字符串，则将另一个转换为字符串，然后拼接起来</li>
</ul>
<h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><p>如果两个操作符都是数值，返回下列结果：</p>
<ul>
<li>如果有一个操作数是NaN，则结果是NaN</li>
<li>Infinity减Infinity，结果是NaN</li>
<li>-Infinity减-Infinity，结果是NaN</li>
<li>Infinity减-Infinity，结果是Infinity</li>
<li>-Infinity减Infinity，结果是-Infinity</li>
<li>+0减+0，结果是+0</li>
<li>-0减-0，结果是-0</li>
<li>+0减-0，结果是+0</li>
<li>如果一个操作数是字符串、布尔值、null、undefined，则现在内部调用Number()函数将其转换为数值，再根据前面的规则进行计算</li>
<li>如果一个操作数是对象，则调用valueOf()方法以取得该对象的数值，如果该对象没有valueOf()方法，则调用其toString()方法。</li>
</ul>
<h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4><p>关系操作符返回一个布尔值。<br>当关系操作符的操作数使用了非数值的时候，也要进行数据转换，转换规则如下：</p>
<ul>
<li>如果都是字符串，则比较字符串对应的Unicode编码</li>
<li>如果其中一个是数值，则把另一个也转换成数值</li>
<li>如果一个操作数是对象，则调用valueOf()方法以取得该对象的数值，如果该对象没有valueOf()方法，则调用其toString()方法。</li>
<li>如果一个操作数是布尔值，则将其转换成数值进行比较</li>
</ul>
<h4 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h4><p>ECMAScript提供两组操作符：相等和不相等-先转换再比较，全等和不全等-仅比较而不转换。</p>
<ul>
<li>比较对象时，比较的是对象的存储地址。如果两个对象的引用都指向相同的地址，则为true。</li>
<li>undefined和null执行相等比较的时候返回true。</li>
</ul>
<p>在代码中尽量使用全等进行比较。</p>
<h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><p>条件操作符格式如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">num</span> = (num1 &gt; num2) ? num1 : num2;</div></pre></td></tr></table></figure></p>
<p>当num1大于num2的时候，将num1赋值给num，否则将num2赋值给num。</p>
<h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><p>作用就是把右侧的值赋给左侧的变量。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<h4 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h4><p>使用逗号操作符可以在一个语句中执行多个操作。<br>可以用逗号操作符来声明多个变量：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var <span class="symbol">num1</span> = <span class="number">10</span>,</div><div class="line">    <span class="symbol">num2</span> = <span class="number">20</span>,</div><div class="line">    <span class="symbol">num3</span> = <span class="number">30</span>;</div></pre></td></tr></table></figure></p>
<p>也可以用于赋值，但返回的是最后一个：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>);</div><div class="line">console.log(num); <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<h3 id="语句-1"><a href="#语句-1" class="headerlink" title="语句"></a>语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>当指定条件为 true 时，if 语句 会执行一条语句。如果该条件为 false，则执行另一条语句。<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="comment">(condition)</span> &#123;</div><div class="line">   stateme<span class="symbol">nts1</span></div><div class="line">&#125; else &#123;</div><div class="line">   stateme<span class="symbol">nts2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h4><p>在对表达式求值前，循环体内的代码至少会被执行一次。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    statement</div><div class="line">&#125; <span class="keyword">while</span> (<span class="keyword">expression</span>)</div></pre></td></tr></table></figure></p>
<h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><p>while 语句可以在某个条件表达式为真的前提下，循环执行指定的一段代码，直到那个表达式不为真时结束循环。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">condition</span>) &#123;</div><div class="line">  statement</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p>for语句用于创建一个循环,它包含了三个可选的表达式,三个可选的表达式包围在圆括号中并由分号分隔,后面跟随一个语句或一组语句在循环中执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</div><div class="line">   <span class="built_in">console</span>.log(i);</div><div class="line">   <span class="comment">// more statements</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于ECMAScript不存在块级作用域，在循环内定义的变量也能在循环外访问到。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<h4 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a>for-in语句</h4><p>for…in 语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Tom"</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">20</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">'student'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> obj) &#123;</div><div class="line">    <span class="built_in">console</span>.log(attr) <span class="comment">// name, age, job</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过for-in循环输出的属性名顺序是不可预测的。</p>
<h4 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h4><p>break语句会立刻退出循环，强制执行循环后面的语句。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )&#123;</div><div class="line">    <span class="keyword">if</span>( i == <span class="number">3</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>continue退出循环后从循环的顶部继续执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )&#123;</div><div class="line">    <span class="keyword">if</span>( i == <span class="number">3</span>) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>switch语句评估一个表达式，，将表达式的值与case子句匹配，并执行与该情况相关联的语句。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (expression) &#123;</div><div class="line">  <span class="keyword">case</span> <span class="keyword">value</span><span class="number">1</span>:</div><div class="line">    <span class="comment">// 当 expression 的结果与 value1 匹配时，从此处开始执行</span></div><div class="line">    statements<span class="number">1</span>；</div><div class="line">    [<span class="keyword">break</span>;]</div><div class="line">  <span class="keyword">case</span> <span class="keyword">value</span><span class="number">2</span>:</div><div class="line">    <span class="comment">// 当 expression 的结果与 value2 匹配时，从此处开始执行</span></div><div class="line">    statements<span class="number">2</span>;</div><div class="line">    [<span class="keyword">break</span>;]</div><div class="line">  ...</div><div class="line">  <span class="keyword">case</span> valueN:</div><div class="line">    <span class="comment">// 当 expression 的结果与 valueN 匹配时，从此处开始执行</span></div><div class="line">    statementsN;</div><div class="line">    [<span class="keyword">break</span>;]</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="comment">// 如果 expression 与上面的 value 值都不匹配时，执行此处的语句</span></div><div class="line">    statements<span class="number">_</span>def;</div><div class="line">    [<span class="keyword">break</span>;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数使用function关键字来声明，后跟一组参数以及函数体。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span><span class="params">(arg0, arg1, <span class="rest_arg">...argN</span>)</span></span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>arguments 是一个类似数组的对象, 对应于传递给函数的参数。<br>arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。例如，如果一个函数传递了三个参数，你可以参考它们如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">arguments</span>[<span class="number">0</span>]</div><div class="line"><span class="built_in">arguments</span>[<span class="number">1</span>]</div><div class="line"><span class="built_in">arguments</span>[<span class="number">2</span>]</div></pre></td></tr></table></figure></p>
<p>参数也可以被设置：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">arguments[1]</span> = <span class="string">'new value'</span>;</div></pre></td></tr></table></figure></p>
<p>arguments对象不是一个 Array 。它类似于数组，但除了 长度之外没有任何数组属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); </div><div class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure></p>
<h4 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h4><p>ECMAScript函数不能实现重载，两个相同名字的函数，后面的会覆盖前面的函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  alert(<span class="number">2</span>)</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="number">1</span>)</div><div class="line">&#125;;</div><div class="line">fn(<span class="number">10</span>); <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6学习笔记之数值的扩展]]></title>
      <url>/2017/05/18/2017-05-18-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="ES5中的Number类型"><a href="#ES5中的Number类型" class="headerlink" title="ES5中的Number类型"></a>ES5中的Number类型</h2><p><code>Number</code>采用IEEE754格式来表示整数和浮点数。<br>整数可以通过十进制、八进制、十六进制字面量来表示。</p>
<p>八进制字面量第一位必须是<code>0</code>，如果字面值中的数值超过范围，前导的零将会被省略，后面数值当作十进制解析。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">070</span>); <span class="comment">// 56</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">08</span>); <span class="comment">// 8</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">089</span>)； <span class="comment">// 89</span></div></pre></td></tr></table></figure></p>
<p>八进制字面量在严格模式下会报错</p>
<p>十六进制字面量前两位必须是<code>0x</code>,超出字面量会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">0xF</span>); <span class="comment">// 15</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">0</span>xG); <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></div></pre></td></tr></table></figure></p>
<p>在进行算术计算的时候，八进制和十六进制的数值最终都会转换成十进制。</p>
<h3 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h3><p>浮点数值需要的内存空间是保存整数值的两倍，如果小数点后面没有任何数值，或者浮点数本身就表示一个整数，那么都会转换为整数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">10.</span>); <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">10.0</span>); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p><code>ECMAScripot</code>的数值范围在<code>Number.MIN_VALUE</code>和<code>Number.MAX_VALUE</code>之间，如果超出这个范围， 将会被转换成<code>Infinity</code>值，该值不能用于计算，要想确定一个值是否是有穷的，通过<code>isFinite()</code>判断，函数参数位于最大值与最小值之间返回<code>true</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE); <span class="comment">// 5e-324</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE); <span class="comment">// 1.7976931348623157e+308</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="built_in">Number</span>.MIN_VALUE + <span class="built_in">Number</span>.MIN_VALUE)); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>这个数值表示一个本来要返回数值的操作数未返回数值的情况。</p>
<ol>
<li>任何涉及到NaN的操作都会返回<code>NaN</code></li>
<li><code>NaN</code>与任何值都不相等，包括自身<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>ECMAScript</code>定义了<code>isNaN()</code>函数，该函数接收一个参数，会尝试将这个参数转换成数值，转换成功返回<code>false</code>, 失败返回<code>true</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'10'</span>)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'color'</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p>有三个函数可以把非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>和<code>parseFloat()</code>。<code>Number()</code>可用于任何数据类型，另两个则专门用于把字符串转换成数值。</p>
<p><code>Number()</code>转换规则如下：</p>
<ol>
<li>如果是Boolean值，则把<code>true</code>和<code>false</code>转换成1和0</li>
<li>如果是数值，返回本身</li>
<li>如果是<code>Null</code>， 返回0</li>
<li>如果是<code>undefined</code>，返回<code>NaN</code></li>
<li><p>如果是字符串，则有一下几种情况</p>
<ul>
<li>如果字符串中只包含数字，则转换成对应十进制</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10"</span>)); <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"+10"</span>)); <span class="comment">//10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"-10"</span>)); <span class="comment">// -10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"010"</span>)); <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<ul>
<li>如果字符串中包含有效的浮点格式，则转换成对应的浮点数值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10.3"</span>)); <span class="comment">// 10.3</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"+10.3"</span>)); <span class="comment">// 10.3</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"-10.3"</span>)); <span class="comment">//-10.3</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"010.3"</span>)); <span class="comment">// 10.3</span></div></pre></td></tr></table></figure>
<ul>
<li>如果字符串中包含有效的十六进制格式，则转换成相同大小的十进制整数值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"0xF"</span>)); <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<ul>
<li>如果字符串为空，则转换为0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">" "</span>)); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<ul>
<li>字符串中包含除上述格式之外的字符， 则转换为<code>NaN</code></li>
</ul>
</li>
<li>如果是对象， 则调用对象的<code>valueOf()</code>方法，然后按照前面规则转换，如果转换结果是<code>NaN</code>，则调用对象的<code>toString()</code>方法，再次依照前面规则转换。日期对象会转换成相应的毫秒数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(now)); <span class="comment">// 1495076392196</span></div></pre></td></tr></table></figure>
<p><code>parseInt()</code>函数在转换字符串时会忽略字符串前面的空格，直到找到第一个非空格字符串。如果第一个字符不是数字字符或者负号，就会返回<code>NaN</code>，如果第一个字符是数字字符，<code>parseInt()</code>会继续解析后面的字符，直到解析完所有字符或者遇到非数字字符。<code>parseInt()</code>解析空字符串会返回<code>NaN</code>。同样，<code>parseInt()</code>也能辨别各种整数格式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">""</span>)); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"123abc"</span>)); <span class="comment">// 123</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"abc123"</span>)); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10.2"</span>)); <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"070"</span>)); <span class="comment">// 70 (ECMAScript5已经不具备解析八进制的能力，所以认为前导的0无效)</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"0xFWQR"</span>)); <span class="comment">// 15</span></div></pre></td></tr></table></figure></p>
<p><code>parseInt()</code>可以接受第二个参数来指定整数的格式。默认是转换成十进制。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">2</span>)); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">8</span>)); <span class="comment">// 8</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">10</span>)); <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">16</span>)); <span class="comment">// 16</span></div></pre></td></tr></table></figure></p>
<p><code>parseFloat()</code>函数与<code>parseInt()</code>类似，不同的是<code>parseFloat()</code>解析完成或者遇到第一个无效的浮点数字字符为止，但是第一个小数点是有效的。<code>parseFloat()</code>始终会忽略前导的零，十六进制的字符串始终会被转换成0，由于<code>parseFloat()</code>只解析十进制值，所以布恩那个指定第二个参数，如果字符串包含的是一个可解析成整数的数值，<code>parseFloat()</code>会返回整数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"123abc"</span>)); <span class="comment">// 123</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"0xF"</span>)); <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10.5"</span>)); <span class="comment">// 10.5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10.5.5"</span>)); <span class="comment">// 10.5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"010.5"</span>)); <span class="comment">// 10.5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10.0"</span>)); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="ES6数值扩展"><a href="#ES6数值扩展" class="headerlink" title="ES6数值扩展"></a>ES6数值扩展</h2><h3 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h3><p>ES6提供了新的二进制和八进制数值的新写法，分别用0b和0o表示。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.<span class="built_in">log</span>(<span class="number">0b0001</span>); // <span class="number">1</span></div><div class="line">console.<span class="built_in">log</span>(<span class="number">0o70</span>); // <span class="number">56</span></div></pre></td></tr></table></figure></p>
<p>要把二进制和八进制转换成十进制，调用Number()方法。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.<span class="built_in">log</span>(Number(<span class="number">0b0001</span>)); // <span class="number">1</span></div><div class="line">console.<span class="built_in">log</span>(Number(<span class="number">0o70</span>)); // <span class="number">56</span></div></pre></td></tr></table></figure></p>
<h3 id="Number-isFinite-、Number-isNaN"><a href="#Number-isFinite-、Number-isNaN" class="headerlink" title="Number.isFinite()、Number.isNaN()"></a>Number.isFinite()、Number.isNaN()</h3><p>这两个方法与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>相比，这两个新方法只对数值有效。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="string">"10"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="string">"10"</span>)); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">"NaN"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="string">"NaN"</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h3 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h3><p>与ES5<code>parseInt()</code>和<code>parseFloat()</code>行为完全一样。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h3><p>用来判断一个数是否为整数。同样能够识别不同格式的整数，如果第一位是零，则忽略。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">10</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="string">"10"</span>)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">10.0</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">10.1</span>)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">010</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">0xF</span>)); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。如果浮点数的计算误差小于<code>Number.EPSILON</code>，我们就可以认为等到了正确的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.EPSILON); <span class="comment">// 2.220446049250313e-16</span></div></pre></td></tr></table></figure></p>
<h3 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h3><p>ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示安全整数范围的上下限。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_SAFE_INTEGER); <span class="comment">// 9007199254740991</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_SAFE_INTEGER); <span class="comment">// -9007199254740991</span></div></pre></td></tr></table></figure></p>
<p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>验证的时候不止要验证结果是否为安全数，还要验证参与计算的值是否为安全数。</p>
<hr>
<p>ES6在Math对象上新增了17个与数学相关的方法，新增了4个对数相关方法，新增了6个三角函数方法，一个指数运算符。<br>具体请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math" target="_blank" rel="external">MDN</a></p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6学习笔记之字符串的扩展]]></title>
      <url>/2017/05/17/2017-05-17-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="ES5中字符串的属性和方法"><a href="#ES5中字符串的属性和方法" class="headerlink" title="ES5中字符串的属性和方法"></a>ES5中字符串的属性和方法</h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>Sting类型的每个实例都有一个<code>length</code>的属性，表示字符串包含多少个字符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> stringValue = <span class="string">'hello'</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.length) <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h3 id="charAt-和charCodeAt"><a href="#charAt-和charCodeAt" class="headerlink" title="charAt()和charCodeAt()"></a>charAt()和charCodeAt()</h3><p>用于访问字符串中特定的字符，两个方法都接受一个参数，即字符所在的下标位置。其中<code>charAt()</code>方法返回下标所在的字符，而<code>charCodeAt()</code>则返回下标对应的字符的字符编码。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = 'hello';</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.charAt(<span class="number">1</span>)); <span class="comment">// e</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.charCodeAt(<span class="number">1</span>)); <span class="comment">// 101</span></div></pre></td></tr></table></figure></p>
<p>还可以通过方括号加下标直接取到对应字符<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = 'hello';</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>[<span class="number">1</span>]); <span class="comment">// e</span></div></pre></td></tr></table></figure></p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>用于将多个字符拼接起来，返回拼接得到的新字符，不会修改字符串本身的值。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"hello"</span>;</div><div class="line"><span class="built_in">let</span> result = <span class="built_in">str</span>.<span class="built_in">concat</span>(<span class="string">" world"</span>,<span class="string">"!"</span>);</div><div class="line">console.<span class="built_in">log</span>(result) <span class="comment">//hello world!</span></div></pre></td></tr></table></figure></p>
<p>但是实际应用中还是用“+”操作符更方便。</p>
<h3 id="slice-、substr-、substring"><a href="#slice-、substr-、substring" class="headerlink" title="slice()、substr()、substring()"></a>slice()、substr()、substring()</h3><p>这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串开始的位置，第二个参数表示子字符串到哪里结束。<code>slice()</code>和<code>substring()</code>的第二个参数指定子字符串最后一个字符的位置(不包含字符本身)。而<code>substr()</code>的第二个参数指定的则是返回的字符个数。如果不给这些方法指定第二个参数，则将字符串的长度作为结束位置。它们都不会修改字符串本身的值。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"hello world"</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.slice(<span class="number">3</span>)); <span class="comment">// lo world</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.substr(<span class="number">3</span>)); <span class="comment">// lo world</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.substring(<span class="number">3</span>)); <span class="comment">// lo world</span></div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// lo w</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// lo worl</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.substring(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// lo w</span></div></pre></td></tr></table></figure></p>
<p>如果传递给这些方法的参数是负值，结果就不相同了。</p>
<ol>
<li><code>slice()</code>方法会将传入的负值与字符串的长度相加。</li>
<li><code>substr()</code>将负的第一个参数加上字符串的长度，将负的第二个参数转换为0。</li>
<li><code>substring()</code>方法会将所有的负的参数转换为0。<figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"hello world"</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.slice(-<span class="number">3</span>)); <span class="comment">// rld</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.substr(-<span class="number">3</span>)); <span class="comment">// rld</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.substring(-<span class="number">3</span>)); <span class="comment">// hello world</span></div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.slice(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// lo w</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.substr(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// (空字符串)</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.substring(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// hel</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意:</strong><code>substring()</code>这个方法始终会将较小的数作为开始位置，较大的数作为结束位置。</p>
<h3 id="indexOf-和lastIndexOf"><a href="#indexOf-和lastIndexOf" class="headerlink" title="indexOf()和lastIndexOf()"></a>indexOf()和lastIndexOf()</h3><p>两个方法都是从字符串中搜索给定的子字符串，然后返回字符串的位置。如果没有找到就返回-1。<code>indexOf()</code>从字符串的开头向后进行搜索，而<code>lastIndexOf()</code>与之相反。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let <span class="built_in">str</span> = <span class="string">"hello world"</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.indexOf(<span class="string">'o'</span>)); <span class="comment">// 4</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.lastIndexOf(<span class="string">'o'</span>)); <span class="comment">// 7</span></div></pre></td></tr></table></figure></p>
<p>这两个方法都可以接受第二个参数，指定搜索的起始位置。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let <span class="built_in">str</span> = <span class="string">"hello world"</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.indexOf(<span class="string">'o'</span>, <span class="number">6</span>)); <span class="comment">// 7</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.lastIndexOf(<span class="string">'o'</span>, <span class="number">6</span>)); <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>搜索字符串中所有匹配的字符<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let <span class="keyword">str</span> = <span class="string">"hello world hello world hello world hello world"</span><span class="comment">;</span></div><div class="line">let arr = []<span class="comment">;</span></div><div class="line">let <span class="keyword">pos</span> = str.indexOf(<span class="string">"o"</span>)<span class="comment">;</span></div><div class="line"><span class="keyword">while</span> ( <span class="keyword">pos</span> &gt; <span class="number">-1</span>)&#123;</div><div class="line">  arr.push(<span class="keyword">pos</span>)<span class="comment">;</span></div><div class="line">  <span class="keyword">pos</span> = str.indexOf(<span class="string">"o"</span>, <span class="keyword">pos</span>+<span class="number">1</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><p>这个方法会创建一个字符串的副本，删除前置及后缀的空格，返回结果，不会修改原始字符串。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">" hello world "</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.trim()); <span class="comment">// "hello world"</span></div></pre></td></tr></table></figure></p>
<h3 id="toLowerCase-、toLocaleLowerCase-、toUpperCase-和toLocaleUpperCase"><a href="#toLowerCase-、toLocaleLowerCase-、toUpperCase-和toLocaleUpperCase" class="headerlink" title="toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()"></a>toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()</h3><p>常用的是<code>toLowerCase()</code>和<code>toUpperCase()</code>,<code>toLocaleLowerCase()</code>和<code>toLocaleUpperCase()</code>是针对特定的地区实现的。<br><code>toUpperCase()</code>小写转大写，<code>toLowerCase()</code>大写转小写。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"HELLO WORLD"</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.toLowerCase()); <span class="comment">// "hello wprld"</span></div><div class="line"></div><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"hello wprld"</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.toLowerCase()); <span class="comment">// "HELLO WORLD"</span></div></pre></td></tr></table></figure></p>
<h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>在字符串上调用这个方法，本质上与调用<code>RegExp</code>的<code>exec()</code>方法相同，<code>match()</code>方法只接受一个参数，要么是一个正则表达式，要么是一个<code>RegExp</code>对象。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;</div><div class="line"><span class="keyword">let</span> <span class="built_in">pattern</span> = /.<span class="built_in">at</span>/;</div><div class="line"><span class="keyword">let</span> matchs = text.<span class="keyword">match</span>(<span class="built_in">pattern</span>);</div><div class="line">console.log(matchs) // [<span class="string">"cat"</span>, index: <span class="number">0</span>, input: <span class="string">"cat, bat, sat, fat"</span>]</div></pre></td></tr></table></figure></p>
<h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>这个方法唯一参数与<code>match()</code>参数相同，<code>search()</code>方法返回字符串第一个匹配项的索引，如果没有找到匹配项，则返回<code>-1</code>。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">text</span> = <span class="string">"cat, bat, sat, fat"</span>;</div><div class="line">var pos = <span class="built_in">text</span>.<span class="built_in">search</span>(/at/);</div><div class="line">console.<span class="built_in">log</span>(pos) <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>这个方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串，第二个参数可以是一个字符串或者一个函数。如果第一个参数是一个字符串，就只会替换第一个字符串，如果要替换所有的字符串，就必须要用正则表达式，全局(g)替换。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;</div><div class="line"><span class="keyword">var</span> <span class="literal">result</span> = text.replace(<span class="string">"at"</span>, <span class="string">"fu"</span>);</div><div class="line">console.log(<span class="literal">result</span>); // <span class="string">"cfu, bat, sat, fat"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>;</div><div class="line"><span class="keyword">var</span> <span class="literal">result</span> = text.replace(/at/g, <span class="string">"fu"</span>);</div><div class="line">console.log(<span class="literal">result</span>); // <span class="string">"cfu, bfu, sfu, ffu"</span></div></pre></td></tr></table></figure></p>
<p><code>replace()</code>的第二个方法可以是一个函数，在只有一个匹配项的情况下，会向这个函数传递三个参数：模式的匹配项，模式的匹配项在字符串中的位置和原始字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> text = <span class="string">"&lt;p class=\"active\"&gt;Hello world&lt;/p&gt;"</span>;</div><div class="line"><span class="keyword">let</span> result = text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, pos, oldText</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (match) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"&lt;"</span> :</div><div class="line">      <span class="keyword">return</span> <span class="string">"&amp;lt;"</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"&gt;"</span> :</div><div class="line">      <span class="keyword">return</span> <span class="string">"&amp;gt;"</span>;</div><div class="line">    <span class="keyword">case</span>  <span class="string">"&amp;"</span> :</div><div class="line">      <span class="keyword">return</span> <span class="string">"&amp;amp;"</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"\""</span> :</div><div class="line">      <span class="keyword">return</span> <span class="string">"&amp;quot;"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(result) <span class="comment">// "&amp;lt;p class=&amp;quot;active&amp;quot;&amp;gt;Hello world&amp;lt;/p&amp;gt;"</span></div></pre></td></tr></table></figure></p>
<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>这个方法可以基于指定的分隔符把一个字符串分割成多个子字符串，并将结果放在一个数组里面。分隔符可以是字符串，也可以是RegExp对象。<code>split()</code>方法可以接受可选的第二个参数，用于指定数组的大小。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">color</span> = <span class="string">"red, yellow, green, pink"</span>;</div><div class="line"><span class="built_in">let</span> color1 = <span class="built_in">color</span>.<span class="built_in">split</span>(<span class="string">","</span>); // [<span class="string">"red"</span>, <span class="string">" yellow"</span>, <span class="string">" green"</span>, <span class="string">" pink"</span>]</div><div class="line"><span class="built_in">let</span> color2 = <span class="built_in">color</span>.<span class="built_in">split</span>(<span class="string">","</span>, <span class="number">2</span>); // [<span class="string">"red"</span>, <span class="string">" yellow"</span>]</div></pre></td></tr></table></figure></p>
<h3 id="localeCompare"><a href="#localeCompare" class="headerlink" title="localeCompare()"></a>localeCompare()</h3><p>这个方法用于比较两个字符串，并返回下列结果之一:</p>
<ol>
<li>如果字符串在字母表中位置在参数之前，则返回一个负数</li>
<li>字符串等于参数，返回0</li>
<li>如果字符串在字母表中位置在参数之后，返回一个正数</li>
</ol>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"yellow"</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.localeCompare(<span class="string">"black"</span>)); <span class="comment">// 1</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.localeCompare(<span class="string">"yellow"</span>)); <span class="comment">// 0</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.localeCompare(<span class="string">"zoom"</span>)); <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p><strong>注意:</strong><code>localeCompare()</code>返回的数值取决于实现，不一定是1， -1， 0。</p>
<h3 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h3><p>这个方法是接收一个或多个字符编码，然后转换成字符串。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(String.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)); <span class="comment">// hello</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="ES6字符串的扩展"><a href="#ES6字符串的扩展" class="headerlink" title="ES6字符串的扩展"></a>ES6字符串的扩展</h2><p>javascript允许采用<code>\uxxxx</code>表示一个字符，但是只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间，超出这个范围的字符就必须用双字节表示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"\uD842\uDFB7"</span>); <span class="comment">// "𠮷"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"\u20BB7"</span>); <span class="comment">// " 7"</span></div></pre></td></tr></table></figure></p>
<p>但是ES6只要将码点放入大括号中， 就能正确解读。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"\u&#123;20BB7&#125;"</span>); <span class="comment">// "𠮷"</span></div></pre></td></tr></table></figure></p>
<h3 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h3><p><code>codePointAt()</code>方法能够正确处理四个字节的字符（Unicode码点大于<code>0xFFFF</code>的字符），返回一个字符的码点（十进制）。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let <span class="built_in">str</span> = <span class="string">'𠮷a'</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.codePointAt(<span class="number">0</span>).<span class="built_in">toString</span>(<span class="number">16</span>)); <span class="comment">// "20bb7"</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.codePointAt(<span class="number">1</span>)); <span class="comment">// "dfb7"</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.codePointAt(<span class="number">2</span>)); <span class="comment">// "61"</span></div></pre></td></tr></table></figure></p>
<p>可以看出<code>codePointAt()</code>的参数任然是不对的，要取到<code>a</code>必须的传入2才能取到，要解决这种问题可以用<code>for...of</code>循环实现，因为它会正确识别32位的UTF-16字符。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">'𠮷a'</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> str)&#123;</div><div class="line">  console.log(c.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>)); //<span class="string">"20bb7"</span> <span class="string">"61"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>codePointAt()</code>是判断一个字符是由两字节组成还是四字节组成最简单的办法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBit</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> value.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(isBit(<span class="string">"𠮷"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isBit(<span class="string">"a"</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h3 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h3><p>用于从码点返回对应字符，能够识别Unicode编号大于<code>0xFFFF</code>的字符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>) <span class="comment">// "𠮷"</span></div></pre></td></tr></table></figure></p>
<p>###字符串的遍历接口<br>ES6新增字符串遍历接口，字符串可以用<code>for...of</code>循环遍历。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">"hello"</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">of</span> str)&#123;</div><div class="line">  console.log(s) // <span class="string">"h"</span> <span class="string">"e"</span> <span class="string">"l"</span> <span class="string">"l"</span> <span class="string">"o"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"𠮷"</span>;</div><div class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">str</span>.length; i++)&#123;</div><div class="line">  console.<span class="built_in">log</span>(<span class="built_in">str</span>[i]) <span class="comment">// � � (打印出来是这种无法识别的符号)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="built_in">let</span> s of <span class="built_in">str</span>)&#123;</div><div class="line"> console.<span class="built_in">log</span>(s) <span class="comment">// "𠮷"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="includes-、startsWith-、endsWith"><a href="#includes-、startsWith-、endsWith" class="headerlink" title="includes()、startsWith()、endsWith()"></a>includes()、startsWith()、endsWith()</h3><ol>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在源字符串头部</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在源字符串尾部<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let <span class="built_in">str</span> = <span class="string">"hello world!"</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.includes(<span class="string">"hello"</span>)); <span class="comment">// true</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.startsWith(<span class="string">"hello"</span>)); <span class="comment">// true</span></div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.endsWith(<span class="string">"!"</span>)); <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>这三个方法都可以接受第二个参数，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> let <span class="built_in">str</span> = <span class="string">"hello world!"</span>;</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.includes(<span class="string">"world"</span>, <span class="number">6</span>))</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.startsWith(<span class="string">"world"</span>, <span class="number">6</span> ))</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.endsWith(<span class="string">"hello"</span>, <span class="number">5</span>))</div></pre></td></tr></table></figure></p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>这个方法接收一个参数，表示要将原字符重复的次数。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"abc"</span>;</div><div class="line">console.<span class="built_in">log</span>( <span class="built_in">str</span>.repeat(<span class="number">3</span>)) <span class="comment">// "abcabcabc"</span></div><div class="line">console.<span class="built_in">log</span>( <span class="built_in">str</span>.repeat(<span class="number">0</span>)) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>如果参数不是正整数，则有下面几种情况：</p>
<ol>
<li>如果参数是小数，会被取整</li>
<li>如果是负数或者是Infinity，会报错</li>
<li>如果是0~-1之间的小数，则为0</li>
<li>如果是NaN，则为0</li>
<li>如果是字符串，则会先转换成数字</li>
</ol>
<h3 id="padStart-和padEnd"><a href="#padStart-和padEnd" class="headerlink" title="padStart()和padEnd()"></a>padStart()和padEnd()</h3><p>字符串自动补全功能，如果字符串不够长度，会在头部或者尾部补全。这两个方法都可接收两个参数，第一个参数指定字符串的最小长度，第二个参数则是用来补全的字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( <span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>)); <span class="comment">// "ababx"</span></div><div class="line"><span class="built_in">console</span>.log( <span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>)) <span class="comment">// "abax"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( <span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>)); <span class="comment">// "xabab"</span></div><div class="line"><span class="built_in">console</span>.log( <span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>)); <span class="comment">// "xaba"</span></div></pre></td></tr></table></figure></p>
<p>当原字符串的长度大于指定的最小长度的时候，返回原字符串本身。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( <span class="string">'xxxxxxx'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>)); <span class="comment">// "xxxxxxx"</span></div></pre></td></tr></table></figure></p>
<p>如果用来补全的字符串与原字符串长度的和大于指定的最小长度的时候，则会截取超出指定的最小长度的字符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( <span class="string">'xxx'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)); <span class="comment">// "0123456xxx"</span></div></pre></td></tr></table></figure></p>
<p>如果省略第二个参数，默认使用空格补全长度。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="regexp">//</span> <span class="string">'   x'</span></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="regexp">//</span> <span class="string">'x   '</span></div></pre></td></tr></table></figure></p>
<p>padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="regexp">//</span> <span class="string">"0000000001"</span></div></pre></td></tr></table></figure></p>
<p>另一个用途是提示字符串格式。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="regexp">//</span> <span class="string">"YYYY-MM-12"</span></div><div class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="regexp">//</span> <span class="string">"YYYY-09-12"</span></div></pre></td></tr></table></figure></p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通字符串</span></div><div class="line"><span class="string">`hello world!`</span>;</div><div class="line"><span class="comment">//多行字符串</span></div><div class="line"><span class="string">`How are you</span></div><div class="line">I'm fine`</div><div class="line"><span class="comment">//字符串中嵌入变量</span></div><div class="line"><span class="keyword">let</span> name=<span class="string">"Tom"</span>;</div><div class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</div><div class="line"><span class="string">`my name is <span class="subst">$&#123;name&#125;</span>,  I'm <span class="subst">$&#123;age&#125;</span> years old`</span>;</div></pre></td></tr></table></figure></p>
<p>模板中使用多行字符串，空格和缩进会保留在输出之中。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">let</span> str = `</div><div class="line">  &lt;ul&gt;</div><div class="line">    &lt;<span class="built_in">li</span>&gt;<span class="built_in">first</span>&lt;/<span class="built_in">li</span>&gt;</div><div class="line">    &lt;<span class="built_in">li</span>&gt;<span class="built_in">second</span>&lt;/<span class="built_in">li</span>&gt;</div><div class="line">  &lt;ul&gt;</div><div class="line">`;</div><div class="line">console.<span class="built_in">log</span>(str)</div></pre></td></tr></table></figure></p>
<p>效果图如下<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170517/143957231.png?imageslim" alt="mark"></p>
<p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>中。大括号内可以放任意的JavaScript表达式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>,</div><div class="line">    y = <span class="number">2</span>;</div><div class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span> <span class="comment">// "1 + 2 = 3"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span> : <span class="number">1</span>, <span class="attr">y</span> : <span class="number">2</span>&#125;;</div><div class="line"><span class="string">`<span class="subst">$&#123;obj.x&#125;</span> + <span class="subst">$&#123;obj.y&#125;</span> = <span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span> <span class="comment">// "1 + 2 = 3"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"hello world"</span>;</div><div class="line">&#125;</div><div class="line"><span class="string">`Hi, <span class="subst">$&#123;fn()&#125;</span>`</span> <span class="comment">// "Hi, hello world"</span></div></pre></td></tr></table></figure></p>
<p>模板字符串中的变量没有声明，就会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">`hello, <span class="subst">$&#123;text&#125;</span>`</span> <span class="comment">// Uncaught ReferenceError: text is not defined</span></div></pre></td></tr></table></figure></p>
<p>模板字符串的大括号内部是一个字符串，将会原样输出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">`hello, <span class="subst">$&#123;<span class="string">'world'</span>&#125;</span>`</span> <span class="comment">// "hello, world"</span></div></pre></td></tr></table></figure></p>
<h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。如果模板字符串里面有变量，就会将模板字符串先处理成多个参数，再调用函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">arr, value1, value2</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(arr); <span class="comment">//  ["Hello ", " world ", "", raw: Array(3)]</span></div><div class="line">  <span class="built_in">console</span>.log(value1); <span class="comment">// 15</span></div><div class="line">  <span class="built_in">console</span>.log(value2); <span class="comment">// 50</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分。其他参数，都是模板字符串各个变量被替换后的值。</p>
<h3 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h3><p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span> === <span class="string">"Hi\\n5!"</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>不会做任何处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`Hi\\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>) <span class="comment">// "Hi\\n5!"</span></div></pre></td></tr></table></figure></p>
<p><code>String.raw</code>方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// 't0e1s2t'</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6学习笔记之变量的解构赋值]]></title>
      <url>/2017/05/16/2017-05-16-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      <content type="html"><![CDATA[<h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><hr>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><blockquote>
<p>ES6运行按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructuring)。</p>
</blockquote>
<p>假设我们有一个变量<code>arr</code>，其值为[1, 2, 3]，我们想给数组的每个元素分别声明一个变量，在ES5中的做法就是单独取出来赋值。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">let el1 = arr[<span class="number">0</span>],</div><div class="line">    el2 = arr[<span class="number">1</span>],</div><div class="line">    el3 = arr[<span class="number">2</span>];</div></pre></td></tr></table></figure></p>
<p>现在ES6允许我们在左边使用表达式来达到和上面代码一样的效果。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [el1, el2, el3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div></pre></td></tr></table></figure></p>
<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。这种写法属于“模式匹配”，只要等号两边模式相同，左边的变量就会被赋予对应的值。同样的，数组还可以进行嵌套。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [foo, <span class="string">[[bar], baz]]</span> = [<span class="number">1</span>, <span class="string">[[2], 3]]</span>;</div><div class="line">foo // <span class="number">1</span></div><div class="line">bar // <span class="number">2</span></div><div class="line">baz // <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>如果解构不成功，变量的值就被赋予<code>undefined</code>，就是等号左边模式匹配不到等号右边数组的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a] = [];</div><div class="line">a <span class="comment">// undefined</span></div><div class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>如果是不完全解构，就是等号左边的模式，只匹配一部分等号右边数组的值，解构依然可以成功。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let [<span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c] = [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line"><span class="selector-tag">a</span> <span class="comment">// 1</span></div><div class="line"><span class="selector-tag">b</span> <span class="comment">// 2</span></div><div class="line">let [<span class="selector-tag">a</span>, [<span class="selector-tag">b</span>, c]] = [<span class="number">1</span>, [<span class="number">2</span>]]</div><div class="line"><span class="selector-tag">a</span> <span class="comment">// 1</span></div><div class="line"><span class="selector-tag">b</span> <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>如果等号右边不是数组，就会报错<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a] = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> [a] = <span class="literal">true</span>;</div><div class="line"><span class="keyword">let</span> [a] = <span class="literal">NaN</span>;</div><div class="line"><span class="keyword">let</span> [a] = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">let</span> [a] = <span class="literal">null</span>;</div><div class="line"><span class="keyword">let</span> [a] = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</div><div class="line">foo <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>] <span class="comment">//x = 'a', y = 'b'</span></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">//x = 'a', y = 'b'</span></div></pre></td></tr></table></figure></p>
<p>ES6使用全等运算符判断一个位置是否有值，所以一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</div><div class="line">x <span class="comment">// null</span></div></pre></td></tr></table></figure></p>
<p>如果默认值是表达式，那么这表达式则是惰性求值。用到的时候才会求值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码因为<code>x</code>能取到值，所以函数不会执行，只有当等号右边数值的值为<code>undefined</code>时，函数才会执行。</p>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];</div><div class="line">x <span class="comment">// 2</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line"></div><div class="line">let [x = y, y = <span class="number">1</span>] = []; <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p>
<p>上面报错是因为<code>x</code>用<code>y</code>作为默认值的时候，<code>y</code>还没有声明。</p>
<hr>
<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>对象的解构与数组有一个很重要的不同，数组的元素是按次序排列的，变量的取值由位置决定，而对象的属性是没有次序的，变量必须要与属性同名才能取到值。<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="built_in">bar</span>, foo&#125; = &#123;foo: <span class="string">"aa"</span>, <span class="built_in">bar</span>: <span class="string">"bb"</span>&#125;;</div><div class="line">foo <span class="comment">// aa</span></div><div class="line"><span class="built_in">bar</span> <span class="comment">// bb</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;baz&#125; = &#123;foo: <span class="string">"aa"</span>, <span class="built_in">bar</span>: <span class="string">"bb"</span>&#125;;</div><div class="line">baz <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>如果变量名与属性名不一致，必须写成下面的形式。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;<span class="string">first:</span> <span class="string">'hello'</span>, <span class="string">last:</span> <span class="string">'world'</span>&#125;;</div><div class="line">let &#123;<span class="string">first:</span> f, <span class="string">last:</span> l&#125; = obj;</div><div class="line">f <span class="comment">// hello</span></div><div class="line">l <span class="comment">// world</span></div><div class="line">first <span class="comment">// ReferenceError</span></div><div class="line">last <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。<code>first</code>是匹配的模式，<code>f</code>才是变量。</p>
<p>用<code>let</code>或者<code>const</code>声明过的变量再通过这种方式重新声明会报错。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a;</div><div class="line"><span class="keyword">let</span> &#123;a, b&#125; = &#123;a: <span class="number">1</span>, b : <span class="number">2</span>&#125; // ReferenceError</div></pre></td></tr></table></figure></p>
<p>对象解构同样可以用于嵌套。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line"> a: [</div><div class="line">   <span class="string">'hello'</span>,</div><div class="line">   &#123;y: <span class="string">'world'</span>&#125;</div><div class="line"> ]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> &#123;a:[x, &#123;y&#125;]&#125; = obj;</div><div class="line">x // hello</div><div class="line">y // world</div></pre></td></tr></table></figure></p>
<p>对象解构也可以指定默认值。默认值生效的条件是对象的属性值严格等于<code>undefined</code>。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;x = <span class="number">1</span>&#125; = &#123;&#125;;</div><div class="line">x // <span class="number">1</span></div><div class="line"><span class="keyword">let</span> &#123;x = <span class="number">1</span>&#125; = &#123;x: <span class="number">3</span>&#125;;</div><div class="line">x // <span class="number">3</span></div><div class="line"><span class="keyword">let</span> &#123;x:y = <span class="number">1</span>&#125; = &#123;&#125;;</div><div class="line">y // <span class="number">1</span></div><div class="line"><span class="keyword">let</span> &#123;x:y = <span class="number">1</span>&#125; = &#123;x:<span class="number">3</span>&#125;;</div><div class="line">y // <span class="number">3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;x = <span class="number">1</span>&#125; = &#123;x: undefined&#125;;</div><div class="line">x // undefined</div><div class="line"><span class="keyword">let</span> &#123;x = <span class="number">1</span>&#125; = &#123;x: null&#125;;</div><div class="line">x // null</div></pre></td></tr></table></figure></p>
<p>解构失败，变量的值等于<code>undefined</code>。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">let</span> &#123;<span class="keyword">baz&#125; </span>= &#123;foo: <span class="string">"aa"</span>, <span class="keyword">bar: </span><span class="string">"bb"</span>&#125;<span class="comment">;</span></div><div class="line"><span class="keyword">baz </span>// undefined</div></pre></td></tr></table></figure></p>
<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class="string">'baz'</span>&#125;;</div><div class="line">bar // ReferenceError</div></pre></td></tr></table></figure></p>
<p>因为等号左边的foo属性在等号右边不存在，所以为<code>undefined</code>，而bar是foo下面的一个子属性<code>undefined.bar</code>肯定就会报错。</p>
<p>如果要将一个已经声明的变量用于解构赋值，需要小心。<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let <span class="keyword">x</span><span class="comment">;</span></div><div class="line">&#123;<span class="keyword">x</span>&#125; = &#123;<span class="keyword">x</span>: <span class="number">1</span>&#125;<span class="comment">;</span></div><div class="line"><span class="keyword">x</span> // Unexpected token =</div></pre></td></tr></table></figure></p>
<p>上面代码报错是因为JavaScript引擎将<code>{x}</code>解析成一个代码块，所以导致错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let <span class="keyword">x</span><span class="comment">;</span></div><div class="line">(&#123;<span class="keyword">x</span>&#125; = &#123;<span class="keyword">x</span>: <span class="number">1</span>&#125;)<span class="comment">;</span></div><div class="line"><span class="keyword">x</span> // <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>将代码放在一个圆括号里面就可以正确执行。</p>
<p>对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量。<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="built_in">log</span>, <span class="built_in">sin</span>, <span class="built_in">cos</span>&#125; = Math</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>字符串也可以解构赋值，被转化成一个类数组的对象。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, b, <span class="built_in">c</span>, d, e] = <span class="string">"hello"</span>;</div><div class="line">a <span class="comment">// h</span></div><div class="line">b <span class="comment">// e</span></div><div class="line"><span class="built_in">c</span> <span class="comment">// l</span></div><div class="line">d <span class="comment">// l</span></div><div class="line">e <span class="comment">// o</span></div></pre></td></tr></table></figure></p>
<p>每个类数组的对象都有个<code>length</code>属性，还可以对这个属性进行解构赋值。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let &#123;length: <span class="built_in">len</span>&#125; = <span class="string">"hello"</span>;</div><div class="line"><span class="built_in">len</span> <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="built_in">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line"><span class="attr">s</span> === Number.prototype.<span class="built_in">toString</span> // <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="built_in">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line"><span class="attr">s</span> === Boolean.prototype.<span class="built_in">toString</span> // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量s都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<hr>
<h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数参数也可以使用解构赋值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function <span class="function"><span class="keyword">fn</span></span>([a, b])&#123;</div><div class="line"> <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">fn</span></span>([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>函数被传入参数的时候，数组参数就被解构成了<code>x</code>和<code>y</code>。</p>
<p>函数参数的解构也可以使用默认值。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function fn(&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;)&#123;</div><div class="line">  return [x, y]</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">fn</span><span class="params">(&#123;x: <span class="number">3</span>, y:<span class="number">5</span>&#125;)</span></span> <span class="comment">// [3, 5]</span></div><div class="line"><span class="function"><span class="title">fn</span><span class="params">(&#123;x: <span class="number">3</span>&#125;)</span></span> <span class="comment">// [3, 0]</span></div><div class="line"><span class="function"><span class="title">fn</span><span class="params">(&#123;&#125;)</span></span> <span class="comment">// [0, 0]</span></div><div class="line"><span class="function"><span class="title">fn</span><span class="params">()</span></span> <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure></p>
<p>而下面的代码会得到不一样的结果。<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function <span class="function"><span class="keyword">fn</span><span class="params">(&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;)</span> &#123;</span></div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span><span class="params">(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;)</span></span>; <span class="comment">// [3, 8]</span></div><div class="line"><span class="function"><span class="keyword">fn</span><span class="params">(&#123;x: <span class="number">3</span>&#125;)</span></span>; <span class="comment">// [3, undefined]</span></div><div class="line"><span class="function"><span class="keyword">fn</span><span class="params">(&#123;&#125;)</span></span>; <span class="comment">// [undefined, undefined]</span></div><div class="line"><span class="function"><span class="keyword">fn</span><span class="params">()</span></span>; <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure></p>
<p>上面代码是为函数<code>fn</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p>
<hr>
<h2 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h2><ol>
<li>变量声明语句不能带有圆括号，包括函数的参数。<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</div><div class="line"><span class="keyword">let</span> &#123;x: (c)&#125; = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> (&#123;x: c&#125;) = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</div><div class="line"><span class="keyword">function</span> f([(z)]) &#123; return z; &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="xml">(</span><span class="template-variable">&#123; p: a &#125;</span><span class="xml">) = </span><span class="template-variable">&#123; p: 42 &#125;</span><span class="xml">;</span></div><div class="line">([a]) = [5];</div><div class="line">[(<span class="template-variable">&#123; p: a &#125;</span><span class="xml">), </span><span class="template-variable">&#123; x: c &#125;</span><span class="xml">] = [</span><span class="template-variable">&#123;&#125;</span><span class="xml">, </span><span class="template-variable">&#123;&#125;</span><span class="xml">];</span></div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h2><p>赋值语句的非模式部分，可以使用圆括号。<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">[(b)]</span> = <span class="string">[3]</span>; </div><div class="line">(&#123; p: (d) &#125; = &#123;&#125;); </div><div class="line"><span class="string">[(parseInt.prop)]</span> = <span class="string">[3]</span>;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>交换变量的值<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="attr">x</span> = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> <span class="attr">y</span> = <span class="number">2</span>;</div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure></p>
<p>从函数返回多个值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [a, b, c] = example();</div></pre></td></tr></table></figure></p>
<p>函数参数的定义<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数是一组有次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([x, y, z])</span> <span class="comment">&#123; ... &#125;</span></span></div><div class="line"><span class="title">f</span><span class="params">([1, 2, 3])</span>;</div><div class="line"></div><div class="line"><span class="comment">// 参数是一组无次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(<span class="comment">&#123;x, y, z&#125;</span>)</span> <span class="comment">&#123; ... &#125;</span></span></div><div class="line"><span class="title">f</span><span class="params">(<span class="comment">&#123;z: 3, y: 2, x: 1&#125;</span>)</span>;</div></pre></td></tr></table></figure></p>
<p>提取JSON数据<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let jsonData = &#123;</div><div class="line">  id: <span class="number">42</span>,</div><div class="line">  <span class="keyword">status</span>: <span class="string">"OK"</span>,</div><div class="line">  <span class="keyword">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let &#123; id, <span class="keyword">status</span>, <span class="keyword">data</span>: <span class="keyword">number</span> &#125; = jsonData;</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(id, <span class="keyword">status</span>, <span class="keyword">number</span>);</div><div class="line">// <span class="number">42</span>, <span class="string">"OK"</span>, [<span class="number">867</span>, <span class="number">5309</span>]</div></pre></td></tr></table></figure></p>
<p>函数参数的默认值<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> </span>(url, &#123;</div><div class="line">  async = <span class="literal">true</span>,</div><div class="line">  beforeSend = <span class="function"><span class="keyword">function</span> </span>() &#123;&#125;,</div><div class="line">  cache = <span class="literal">true</span>,</div><div class="line">  complete = <span class="function"><span class="keyword">function</span> </span>() &#123;&#125;,</div><div class="line">  crossDomain = <span class="literal">false</span>,</div><div class="line">  global = <span class="literal">true</span>,</div><div class="line">  <span class="comment">// ... more config</span></div><div class="line">&#125;) &#123;</div><div class="line">  <span class="comment">// ... do stuff</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6学习笔记之let和const命令]]></title>
      <url>/2017/05/15/2017-05-15-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Blet%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>最近一直在看阮大神的<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门</a>这本书，边学边记，加深印象。</p>
<hr>
<h1 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a><center>let和const命令</center></h1><p>ES5只有两种声明变量的方法：var命令和function命令。而ES6新增了四种声明变量的方法:let、const、import和class，所以ES6有6种声明变量的方法。</p>
<h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><hr>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>let用来声明变量， 用法类似于var，但是只在let命令所在的代码块有效。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i  = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 10</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>var声明的变量的能在变量声明之前访问，值为undefined，因为在脚本运行之前，变量foo已经存在，但是没有值，所以会输出undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">'hello'</span>;</div></pre></td></tr></table></figure></p>
<p>如果用let来声明的变量在没有声明之前就进行访问的话，会抛出异常。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></div><div class="line"><span class="keyword">var</span> <span class="keyword">let</span> = <span class="string">'hello'</span>;</div></pre></td></tr></table></figure></p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">  tmp = <span class="string">"hello"</span>;</div><div class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></div><div class="line">  <span class="keyword">let</span> tmp;</div><div class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></div><div class="line">  tmp = <span class="string">"abc"</span>;</div><div class="line">  <span class="built_in">console</span>.log(tmp)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上图说明在第四行用let声明变量tmp之前，都属于tmp的死区。<br><strong>注意</strong><br><strong>如果在let声明变量之前用typeof检测数据类型的话，会抛出异常。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x); <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>let不允许在相同的作用域内重复声明同一个变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码会抛出异常，改成下面这样就不会了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>)</span>&#123;</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">let</span> arg;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES5只有全局作用域和函数作用域,而ES6新增了块级作用域。</p>
<ol>
<li>ES6允许块级作用于任意嵌套<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&#123;&#123;&#123;let a = <span class="number">0</span>&#125;&#125;&#125;&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上图使用了5五层块级作用域。</p>
<ol>
<li><p>外层作用域无法读取内层作用域的变量</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&#123;&#123;</div><div class="line">  &#123;let a = <span class="number">0</span>&#125;</div><div class="line">  console.log(<span class="name">a</span>)<span class="comment">; // ReferenceError</span></div><div class="line">&#125;&#125;&#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>不同作用域可以定义同名变量</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&#123;&#123;</div><div class="line">  let a = <span class="number">1</span><span class="comment">;</span></div><div class="line">  &#123;</div><div class="line">    let a = <span class="number">0</span><span class="comment">;</span></div><div class="line">    console.log(<span class="name">a</span>) // <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">  console.log(<span class="name">a</span>) // <span class="number">1</span></div><div class="line">&#125;&#125;&#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>const声明一个只读的常量，一旦声明，值就不可以改变。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const <span class="literal">PI</span> = <span class="number">3.1415</span>;</div><div class="line"><span class="literal">PI</span> = <span class="number">3.14</span>;</div><div class="line">console.log(<span class="literal">PI</span>) <span class="comment">// Assignment to constant variable</span></div></pre></td></tr></table></figure></p>
<p>const一旦声明变量，必须立即初始化。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const foo <span class="comment">;</span></div><div class="line"><span class="attribute">foo</span> = <span class="string">"hello"</span><span class="comment">;</span></div><div class="line">console.log(foo)<span class="comment">; // Missing initializer in const declaration</span></div></pre></td></tr></table></figure></p>
<p>const和let相同，声明的变量只有在其所在的块级作用于有效，变量不会提升，同时也存在“暂时性死区”。</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><blockquote>
<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。</p>
</blockquote>
<p>意思就是说用const声明的基本数据的变量是不可以改变值，而引用数据类型（主要是对象和数值）,const只能保证指针是固定的，而指向的数据是可以进行变化的。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const foo = &#123;&#125;<span class="comment">;</span></div><div class="line">foo.name = <span class="string">"Tom"</span><span class="comment">;</span></div><div class="line">console.log(foo)<span class="comment">; // &#123;name: "Tom"&#125;</span></div><div class="line"></div><div class="line"><span class="attribute">foo</span> = &#123;&#125;<span class="comment">; // 当把foo指向另一个对象的时候就会报错</span></div></pre></td></tr></table></figure></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const arr = []<span class="comment">;</span></div><div class="line">arr.push(<span class="string">"hello"</span>)<span class="comment">;</span></div><div class="line">console.log(arr)<span class="comment">; ["hello"]</span></div><div class="line"></div><div class="line"><span class="attribute">arr</span> = []<span class="comment">; // Assignment to constant variable.</span></div></pre></td></tr></table></figure>
<p>如果要冻结一个对象，应该使用<em>Object.freeze</em>方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</div><div class="line">foo.name = <span class="string">"Tom"</span>;</div><div class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// &#123;&#125;</span></div></pre></td></tr></table></figure></p>
<p>常规模式下，添加属性不起作用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</div><div class="line">foo.name = <span class="string">"Tom"</span>;</div><div class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// Cannot add property name, object is not extensible</span></div></pre></td></tr></table></figure></p>
<p>在严格模式下会抛出异常</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数 - . -暂时没有理解到这个方法，先直接拷过来用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">Object</span>.freeze(obj);</div><div class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</div><div class="line">      constantize( obj[key] );</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css之position属性]]></title>
      <url>/2017/05/15/2017-05-15-css%E4%B9%8Bposition%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>position CSS属性选择用于定位元素的替代规则，被设计为对脚本动画效果有用。</p>
</blockquote>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 关键字  值 */</span></div><div class="line"><span class="attribute">position</span>: static;</div><div class="line"><span class="attribute">position</span>: relative;</div><div class="line"><span class="attribute">position</span>: absolute;</div><div class="line"><span class="attribute">position</span>: fixed;</div><div class="line"><span class="attribute">position</span>: sticky; <span class="comment">//实验性API</span></div><div class="line"></div><div class="line"><span class="comment">/* 全局值 */</span></div><div class="line"><span class="attribute">position</span>: inherit;</div><div class="line"><span class="attribute">position</span>: initial;</div><div class="line"><span class="attribute">position</span>: unset;</div></pre></td></tr></table></figure>
<h3 id="static-元素默认定位属性"><a href="#static-元素默认定位属性" class="headerlink" title="static 元素默认定位属性"></a>static 元素默认定位属性</h3><p>默认值。没有定位，元素出现在正常的文档流中，忽略top, right, bottom, left, z-index声明。</p>
<h3 id="relative-相对定位"><a href="#relative-相对定位" class="headerlink" title="relative 相对定位"></a>relative 相对定位</h3><p>相对自己文档流中的原始位置进行定位，<strong>不会脱离文档流</strong>。<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170512/165119169.png?imageslim" alt=""><br>上图给test4加上了position:relative效果，代码如下<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">position</span>: relative; <span class="attribute">top</span>:<span class="number">10px</span>; <span class="attribute">left</span>:-<span class="number">20px</span></div></pre></td></tr></table></figure></p>
<p>可以看出test4并没有对周围的元素造成影响， 它还是存在于正常的文档流中。position:relative对 table-*-group, table-row, table-column, table-cell, table-caption 元素没有效果。</p>
<h3 id="absolute-绝对定位"><a href="#absolute-绝对定位" class="headerlink" title="absolute 绝对定位"></a>absolute 绝对定位</h3><ol>
<li><p>相对于static定位以外的第一个父元素进行定位， <strong>脱离文档流</strong><br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170512/170435114.png?imageslim" alt="mark"><br>上图给test4加上了position:absolute效果<br>明显可以看到test4从正常的文档流中脱离了出来， test5填补了test4原本的位置。 </p>
</li>
<li><p>绝对定位元素可以设置外边距，且不会与其他边距合并<br>CSS代码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>&#123;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">background</span>: lightseagreen;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">30px</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box1</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">background</span>: red</div><div class="line">&#125;<span class="selector-tag">eight</span>: 50<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">red</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span>&gt;</div><div class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box1"</span>&gt;absolute定位元素&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170512/171943995.png?imageslim" alt="mark"></p>
<h3 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h3><p>position:sticky是一个新的CSS3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置<br>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">1000px</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.sticky-box</span> &#123;</div><div class="line">  <span class="attribute">position</span>: -webkit-sticky;</div><div class="line">  <span class="attribute">position</span>: sticky;</div><div class="line">  <span class="attribute">height</span>: <span class="number">60px</span>;</div><div class="line">  <span class="attribute">margin-bottom</span>: <span class="number">30px</span>;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#ff7300</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">60px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"container"</span>&gt;</div><div class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"sticky-box"</span>&gt;内容<span class="number">1</span>&lt;/<span class="keyword">div</span>&gt;</div><div class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"sticky-box"</span>&gt;内容<span class="number">2</span>&lt;/<span class="keyword">div</span>&gt;</div><div class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"sticky-box"</span>&gt;内容<span class="number">3</span>&lt;/<span class="keyword">div</span>&gt;</div><div class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"sticky-box"</span>&gt;内容<span class="number">4</span>&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170515/100352640.png?imageslim" alt="mark"><br>因为设定的阈值是 top:0 ，这个值表示当元素距离页面视口（Viewport，也就是fixed定位的参照）顶部距离大于 0px 时，元素以 relative 定位表现，而当元素距离页面视口小于 0px 时，元素表现为 fixed 定位，也就会固定在顶部。<br>浏览器支持情况<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170515/100532644.png?imageslim" alt="mark"><br>IOS 家族（SAFARI &amp;&amp; IOS SAFARI）和 Firefox 很早开始就支持 position:sticky 了。而 Chrome53~55 则需要启用实验性网络平台功能才行。其中 webkit 内核的要添加上私有前缀 -webkit-。</p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS之float属性]]></title>
      <url>/2017/05/12/2017-05-12-CSS%E4%B9%8Bfloat%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>CSS的float属性可以使一个元素脱离正常的文档流，然后被安放在它所在容器的左端或者右端，并且其他的文本和行内元素环绕它。</p>
</blockquote>
<h3 id="float属性介绍"><a href="#float属性介绍" class="headerlink" title="float属性介绍"></a>float属性介绍</h3><ul>
<li>left: 元素向左浮动</li>
<li>float: 元素向右浮动</li>
<li>none: 默认值</li>
<li>inherit： 默认值 </li>
</ul>
<p>由于float使用了块布局， 所以它会改变display的计算值</p>
<table>
<thead>
<tr>
<th>指定值</th>
<th>计算值</th>
</tr>
</thead>
<tbody>
<tr>
<td>inline</td>
<td>block</td>
</tr>
<tr>
<td>inline-block</td>
<td>block</td>
</tr>
<tr>
<td>inline-table</td>
<td>table</td>
</tr>
<tr>
<td>table-row</td>
<td>block</td>
</tr>
<tr>
<td>table-row-group</td>
<td>block</td>
</tr>
<tr>
<td>table-column</td>
<td>block</td>
</tr>
<tr>
<td>tabale-column-group</td>
<td>block</td>
</tr>
<tr>
<td>tabel-cell</td>
<td>block</td>
</tr>
<tr>
<td>table-caption</td>
<td>block</td>
</tr>
<tr>
<td>table-header-group</td>
<td>block</td>
</tr>
<tr>
<td>table-footer-group</td>
<td>block</td>
</tr>
<tr>
<td>flex</td>
<td>flex,float对这样的元素不起作用</td>
</tr>
<tr>
<td>inline-flex</td>
<td>inline-flex, float对这样的元素不起作用</td>
</tr>
</tbody>
</table>
<h3 id="浮动元素是如何定位的"><a href="#浮动元素是如何定位的" class="headerlink" title="浮动元素是如何定位的"></a>浮动元素是如何定位的</h3><p>当一个元素浮动后，它会被移除正常的文档流，然后向左或是向右平移，一直平移到碰到了所处容器的边缘或者碰到另外一个浮动元素。<br>不管一个元素是行内元素还是块级元素，如果被设置了浮动，那浮动元素会生成一个块级框，可以设置它的width和height</p>
<h3 id="浮动元素的一些特性"><a href="#浮动元素的一些特性" class="headerlink" title="浮动元素的一些特性"></a>浮动元素的一些特性</h3><p>  浮动元素浮动的时候， margin不会超过包含块的padding</p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123; <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">height</span>: <span class="number">500px</span>; <span class="attribute">background</span>: lightseagreen; <span class="attribute">padding</span>: <span class="number">10px</span>&#125;</div><div class="line"><span class="selector-class">.box1</span>&#123; <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">50px</span>; <span class="attribute">background</span>: orangered; <span class="attribute">margin</span>: <span class="number">20px</span>&#125;</div></pre></td></tr></table></figure></p>
<p>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span>&gt;</div><div class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box1"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170512/151930154.png?imageslim" alt="mark"></p>
<p>  如果有多个浮动元素，后面浮动元素的margin不会超过前面浮动元素的margin, 多个浮动元素，浮动元素会按顺序排列而不发生重叠现象</p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123; <span class="attribute">width</span>: <span class="number">400px</span>; <span class="attribute">height</span>: <span class="number">500px</span>; <span class="attribute">background</span>: lightseagreen; <span class="attribute">padding</span>: <span class="number">10px</span>&#125;</div><div class="line"><span class="selector-class">.box1</span>&#123; <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">50px</span>; <span class="attribute">background</span>: orangered; <span class="attribute">margin</span>: <span class="number">10px</span>; <span class="attribute">float</span>: left&#125;</div></pre></td></tr></table></figure></p>
<p>HTML代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span>&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170512/152028555.png?imageslim" alt="mark"></p>
<p>如果两个元素一个左浮动，一个右浮动，左浮动元素的marginRinght和右浮动的marginLeft不会重叠</p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123; <span class="attribute">width</span>: <span class="number">219px</span>; <span class="attribute">height</span>: <span class="number">500px</span>; <span class="attribute">background</span>: lightseagreen;&#125;</div><div class="line"><span class="selector-class">.box1</span>&#123; <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">50px</span>; <span class="attribute">background</span>: orangered; <span class="attribute">margin-right</span>: <span class="number">10px</span>; <span class="attribute">float</span>: left&#125;</div><div class="line"><span class="selector-class">.box2</span>&#123; <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">50px</span>; <span class="attribute">background</span>: orangered; <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="attribute">float</span>: left&#125;</div></pre></td></tr></table></figure></p>
<p>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span>&gt;</div><div class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box1"</span>&gt;左浮动元素&lt;/<span class="keyword">div</span>&gt;</div><div class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box2"</span>&gt;右浮动元素&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170512/152111850.png?imageslim" alt="mark"></p>
<h3 id="浮动元素重叠问题"><a href="#浮动元素重叠问题" class="headerlink" title="浮动元素重叠问题"></a>浮动元素重叠问题</h3><ol>
<li>块级元素与浮动元素发生重叠，边框和背景会显示在浮动元素之下，内容会显示在浮动元素之上<br>CSS<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123; <span class="attribute">width</span>: <span class="number">400px</span>; <span class="attribute">height</span>: <span class="number">500px</span>; <span class="attribute">background</span>: lightseagreen;&#125;</div><div class="line"><span class="selector-class">.box1</span>&#123;<span class="attribute">background</span>: blue; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>&#125;</div><div class="line"><span class="selector-class">.box2</span>&#123; <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">50px</span>; <span class="attribute">background</span>: orangered; <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="attribute">float</span>: left; <span class="attribute">margin-top</span>: -<span class="number">10px</span>&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>HTML<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span>&gt;</div><div class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box1"</span>&gt;我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字&lt;/<span class="keyword">div</span>&gt;</div><div class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box2"</span>&gt;右浮动元素&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170512/152124073.png?imageslim" alt="mark"></p>
<ol>
<li>行内元素与浮动元素发生重叠，其边框，背景和内容都会显示在浮动元素之上<br>CSS<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123; <span class="attribute">width</span>: <span class="number">400px</span>; <span class="attribute">height</span>: <span class="number">500px</span>; <span class="attribute">background</span>: lightseagreen;&#125;</div><div class="line"><span class="selector-tag">span</span>&#123; <span class="attribute">background</span>: palevioletred; &#125;</div><div class="line"><span class="selector-class">.box2</span>&#123; <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">50px</span>; <span class="attribute">background</span>: orangered; <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="attribute">float</span>: left; <span class="attribute">margin-top</span>: -<span class="number">10px</span>&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>HTML<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span>&gt;</div><div class="line">  &lt;span&gt;我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字&lt;/span&gt;</div><div class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box2"</span>&gt;浮动元素&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170512/152135066.png?imageslim" alt="mark"></p>
<hr>
<h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ol>
<li>增加额外的div<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div style=<span class="string">"clear: both"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>优点：简单粗暴<br>缺点: 增加额外的无意义的标签，不利于语义化</p>
<ol>
<li>父级元素增加overflow: hidden(关键在于触发了BFC)<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clearfix</span>&#123; <span class="attribute">overflow</span>:hidden&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>优点：代码量少，没有额外的标签<br>缺点： 如果子元素超出父元素的范围，会造成超出的部分被隐藏</p>
<ol>
<li>after伪类<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">clearfix</span>&#123;<span class="attribute">zoom</span>:<span class="number">1</span>&#125;</div><div class="line"><span class="selector-tag">clearfix</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">display</span>:block; <span class="attribute">content</span>:<span class="string">""</span>; <span class="attribute">clear</span>:both; <span class="attribute">visibility</span>: hidden;&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>优点：没有额外标签，综合起来算比较好的方法<br>缺点：稍显复杂<br><em>推荐使用这种方法</em></p>
<h3 id="float应用场景"><a href="#float应用场景" class="headerlink" title="float应用场景"></a>float应用场景</h3><p>float最初应用就是文字环绕效果<br>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123; <span class="attribute">width</span>: <span class="number">400px</span>; <span class="attribute">height</span>: <span class="number">500px</span>; <span class="attribute">background</span>: lightseagreen;&#125;</div><div class="line"><span class="selector-tag">img</span>&#123; <span class="attribute">float</span>: left&#125;</div></pre></td></tr></table></figure></p>
<p>HTML代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span>&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"demo6.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span></div><div class="line">  文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://optwq0urg.bkt.clouddn.com/blog/20170512/152143717.png?imageslim" alt="mark"></p>
<p>还可用于横向菜单排列，但是更推荐使用display:inline-block,除了文字环绕效果，在其他几乎所有的应用场景中，float能实现的效果，display:inline-block都能实现。<br>推荐一篇张鑫旭大神的关于<a href="http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/" target="_blank" rel="external">float</a>的文章,写的特别有意思。</p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS的数组去重]]></title>
      <url>/2017/05/07/2017-05-07-js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      <content type="html"><![CDATA[<h3 id="判断浏览器是否支持indexOf方法"><a href="#判断浏览器是否支持indexOf方法" class="headerlink" title="判断浏览器是否支持indexOf方法"></a>判断浏览器是否支持indexOf方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断是否支持indexOf方法</span></div><div class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.prototype.indexOf)&#123;</div><div class="line">  <span class="built_in">Array</span>.prototype.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="number">-1</span>;</div><div class="line">    <span class="comment">//数组为空的时候返回-1</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.length == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>[i] === item) &#123;</div><div class="line">        <span class="comment">//当当前项的值与参数值相等的时候，结束循环</span></div><div class="line">        result = i;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="遍历数组法：新建一新数组，遍历数组，值不在新数组中就加入新数组"><a href="#遍历数组法：新建一新数组，遍历数组，值不在新数组中就加入新数组" class="headerlink" title="遍历数组法：新建一新数组，遍历数组，值不在新数组中就加入新数组"></a>遍历数组法：新建一新数组，遍历数组，值不在新数组中就加入新数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="comment">//新建数组</span></div><div class="line">	<span class="keyword">var</span> newArr = [];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">	  <span class="comment">//值不在新数组中就添加到新数组</span></div><div class="line">	  <span class="keyword">if</span>(newArr.indexOf(array[i]) == <span class="number">-1</span>)&#123;</div><div class="line">		newArr.push(array[i]);</div><div class="line">	  &#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> newArr</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="对象键值法：该方法执行速度比其他任何方法都快，就是占用内存大一些。新建一JS对象和数组，遍历传入数组时，判断值是否为JS对象的值，不是的话给对象新增该键并放入新数组。注意点，判断是否为JS对象键时，会自动对传入的键执行”toString-”-不同的键可能会被误认为一样。"><a href="#对象键值法：该方法执行速度比其他任何方法都快，就是占用内存大一些。新建一JS对象和数组，遍历传入数组时，判断值是否为JS对象的值，不是的话给对象新增该键并放入新数组。注意点，判断是否为JS对象键时，会自动对传入的键执行”toString-”-不同的键可能会被误认为一样。" class="headerlink" title="对象键值法：该方法执行速度比其他任何方法都快，就是占用内存大一些。新建一JS对象和数组，遍历传入数组时，判断值是否为JS对象的值，不是的话给对象新增该键并放入新数组。注意点，判断是否为JS对象键时，会自动对传入的键执行”toString()”,不同的键可能会被误认为一样。"></a>对象键值法：该方法执行速度比其他任何方法都快，就是占用内存大一些。新建一JS对象和数组，遍历传入数组时，判断值是否为JS对象的值，不是的话给对象新增该键并放入新数组。注意点，判断是否为JS对象键时，会自动对传入的键执行”toString()”,不同的键可能会被误认为一样。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;,</div><div class="line">          newArr = [],</div><div class="line">          len = array.length,</div><div class="line">          val,</div><div class="line">          type;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">      val = array[i];</div><div class="line">      <span class="comment">//获取值的数据类型</span></div><div class="line">      type = <span class="keyword">typeof</span> val;</div><div class="line">      <span class="comment">//判断值是否存在</span></div><div class="line">      <span class="keyword">if</span> (!obj[val]) &#123;</div><div class="line">        <span class="comment">//把type以数组的形式存入便于用indexOf对比</span></div><div class="line">        obj[val] = [type];</div><div class="line">        newArr.push(val);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(obj[val].indexOf(type) &lt; <span class="number">0</span>) &#123;  <span class="comment">//值存在的情况下判断是否是相同的数据类型</span></div><div class="line">        obj[val].push(type);</div><div class="line">        newArr.push(val);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newArr;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="数组下标判断法：当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的。"><a href="#数组下标判断法：当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的。" class="headerlink" title="数组下标判断法：当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的。"></a>数组下标判断法：当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> newArr = [array[<span class="number">0</span>]];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">      <span class="comment">//判断第i项出现位置下标</span></div><div class="line">      <span class="keyword">if</span> (array.indexOf(array[i]) == i) &#123;</div><div class="line">        newArr.push(array[i])</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newArr;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="排序后相邻去除法：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。"><a href="#排序后相邻去除法：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。" class="headerlink" title="排序后相邻去除法：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。"></a>排序后相邻去除法：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="comment">//先排序</span></div><div class="line">    array.sort();</div><div class="line">    <span class="keyword">var</span> newArr = [array[<span class="number">0</span>]];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">      <span class="comment">//newArr最后一项就是array[i]的前一项</span></div><div class="line">      <span class="keyword">if</span>(array[i]  !== newArr[newArr.length - <span class="number">1</span>])&#123;</div><div class="line">        newArr.push(array[i]);</div><div class="line">      &#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> newArr;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="获取没重复的最右一值放入新数组。检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断"><a href="#获取没重复的最右一值放入新数组。检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断" class="headerlink" title="获取没重复的最右一值放入新数组。检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断"></a>获取没重复的最右一值放入新数组。检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> r = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</div><div class="line">        <span class="keyword">if</span>(array[i] === array[j])&#123;</div><div class="line">          <span class="comment">//当两个值相同的时候,i在内循环自增1，相当于跳出本次循环，执行下一次，当前值就不能添加到新数组</span></div><div class="line">          j = ++i;</div><div class="line">        &#125;;</div><div class="line">      &#125;</div><div class="line">      r.push(array[i]);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
