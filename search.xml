<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6学习笔记之字符串的扩展]]></title>
    <url>%2F2017%2F05%2F17%2F2017-05-17-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[ES5中字符串的属性和方法lengthSting类型的每个实例都有一个length的属性，表示字符串包含多少个字符。12let stringValue = 'hello';console.log(stringValue.length) // 5 charAt()和charCodeAt()用于访问字符串中特定的字符，两个方法都接受一个参数，即字符所在的下标位置。其中charAt()方法返回下标所在的字符，而charCodeAt()则返回下标对应的字符的字符编码。123let str = 'hello';console.log(str.charAt(1)); // econsole.log(str.charCodeAt(1)); // 101 还可以通过方括号加下标直接取到对应字符12let str = 'hello';console.log(str[1]); // e concat()用于将多个字符拼接起来，返回拼接得到的新字符，不会修改字符串本身的值。123let str = "hello";let result = str.concat(" world","!");console.log(result) //hello world! 但是实际应用中还是用“+”操作符更方便。 slice()、substr()、substring()这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串开始的位置，第二个参数表示子字符串到哪里结束。slice()和substring()的第二个参数指定子字符串最后一个字符的位置(不包含字符本身)。而substr()的第二个参数指定的则是返回的字符个数。如果不给这些方法指定第二个参数，则将字符串的长度作为结束位置。它们都不会修改字符串本身的值。12345678let str = "hello world";console.log(str.slice(3)); // lo worldconsole.log(str.substr(3)); // lo worldconsole.log(str.substring(3)); // lo worldconsole.log(str.slice(3, 7)); // lo wconsole.log(str.substr(3, 7)); // lo worlconsole.log(str.substring(3, 7)); // lo w 如果传递给这些方法的参数是负值，结果就不相同了。 slice()方法会将传入的负值与字符串的长度相加。 substr()将负的第一个参数加上字符串的长度，将负的第二个参数转换为0。 substring()方法会将所有的负的参数转换为0。12345678let str = "hello world";console.log(str.slice(-3)); // rldconsole.log(str.substr(-3)); // rldconsole.log(str.substring(-3)); // hello worldconsole.log(str.slice(3, -4)); // lo wconsole.log(str.substr(3, -4)); // (空字符串)console.log(str.substring(3, -4)); // hel 注意:substring()这个方法始终会将较小的数作为开始位置，较大的数作为结束位置。 indexOf()和lastIndexOf()两个方法都是从字符串中搜索给定的子字符串，然后返回字符串的位置。如果没有找到就返回-1。indexOf()从字符串的开头向后进行搜索，而lastIndexOf()与之相反。123let str = "hello world";console.log(str.indexOf('o')); // 4console.log(str.lastIndexOf('o')); // 7 这两个方法都可以接受第二个参数，指定搜索的起始位置。123let str = "hello world";console.log(str.indexOf('o', 6)); // 7console.log(str.lastIndexOf('o', 6)); // 4 搜索字符串中所有匹配的字符1234567let str = "hello world hello world hello world hello world";let arr = [];let pos = str.indexOf("o");while ( pos &gt; -1)&#123; arr.push(pos); pos = str.indexOf("o", pos+1);&#125; trim()这个方法会创建一个字符串的副本，删除前置及后缀的空格，返回结果，不会修改原始字符串。12let str = " hello world ";console.log(str.trim()); // "hello world" toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()常用的是toLowerCase()和toUpperCase(),toLocaleLowerCase()和toLocaleUpperCase()是针对特定的地区实现的。toUpperCase()小写转大写，toLowerCase()大写转小写。12345let str = "HELLO WORLD";console.log(str.toLowerCase()); // "hello wprld"let str = "hello wprld";console.log(str.toLowerCase()); // "HELLO WORLD" match()在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同，match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。1234let text = "cat, bat, sat, fat";let pattern = /.at/;let matchs = text.match(pattern);console.log(matchs) // ["cat", index: 0, input: "cat, bat, sat, fat"] search()这个方法唯一参数与match()参数相同，search()方法返回字符串第一个匹配项的索引，如果没有找到匹配项，则返回-1。123let text = "cat, bat, sat, fat";var pos = text.search(/at/);console.log(pos) // 1 replace()这个方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串，第二个参数可以是一个字符串或者一个函数。如果第一个参数是一个字符串，就只会替换第一个字符串，如果要替换所有的字符串，就必须要用正则表达式，全局(g)替换。1234567let text = "cat, bat, sat, fat";var result = text.replace("at", "fu");console.log(result); // "cfu, bat, sat, fat"let text = "cat, bat, sat, fat";var result = text.replace(/at/g, "fu");console.log(result); // "cfu, bfu, sfu, ffu" replace()的第二个方法可以是一个函数，在只有一个匹配项的情况下，会向这个函数传递三个参数：模式的匹配项，模式的匹配项在字符串中的位置和原始字符串。1234567891011121314let text = "&lt;p class=\"active\"&gt;Hello world&lt;/p&gt;";let result = text.replace(/[&lt;&gt;"&amp;]/g, function (match, pos, oldText) &#123; switch (match) &#123; case "&lt;" : return "&amp;lt;"; case "&gt;" : return "&amp;gt;"; case "&amp;" : return "&amp;amp;"; case "\"" : return "&amp;quot;"; &#125;&#125;);console.log(result) // "&amp;lt;p class=&amp;quot;active&amp;quot;&amp;gt;Hello world&amp;lt;/p&amp;gt;" split()这个方法可以基于指定的分隔符把一个字符串分割成多个子字符串，并将结果放在一个数组里面。分隔符可以是字符串，也可以是RegExp对象。split()方法可以接受可选的第二个参数，用于指定数组的大小。123let color = "red, yellow, green, pink";let color1 = color.split(","); // ["red", " yellow", " green", " pink"]let color2 = color.split(",", 2); // ["red", " yellow"] localeCompare()这个方法用于比较两个字符串，并返回下列结果之一: 如果字符串在字母表中位置在参数之前，则返回一个负数 字符串等于参数，返回0 如果字符串在字母表中位置在参数之后，返回一个正数 1234let str = "yellow";console.log(str.localeCompare("black")); // 1console.log(str.localeCompare("yellow")); // 0console.log(str.localeCompare("zoom")); // -1 注意:localeCompare()返回的数值取决于实现，不一定是1， -1， 0。 String.fromCharCode()这个方法是接收一个或多个字符编码，然后转换成字符串。1console.log(String.fromCharCode(104, 101, 108, 108, 111)); // hello ES6字符串的扩展javascript允许采用\uxxxx表示一个字符，但是只限于码点在\u0000~\uFFFF之间，超出这个范围的字符就必须用双字节表示。12console.log("\uD842\uDFB7"); // "𠮷"console.log("\u20BB7"); // " 7" 但是ES6只要将码点放入大括号中， 就能正确解读。1console.log("\u&#123;20BB7&#125;"); // "𠮷" codePointAt()codePointAt()方法能够正确处理四个字节的字符（Unicode码点大于0xFFFF的字符），返回一个字符的码点（十进制）。1234let str = '𠮷a';console.log(str.codePointAt(0).toString(16)); // "20bb7"console.log(str.codePointAt(1)); // "dfb7"console.log(str.codePointAt(2)); // "61" 可以看出codePointAt()的参数任然是不对的，要取到a必须的传入2才能取到，要解决这种问题可以用for...of循环实现，因为它会正确识别32位的UTF-16字符。1234let str = '𠮷a';for(let c of str)&#123; console.log(c.codePointAt(0).toString(16)); //"20bb7" "61"&#125; codePointAt()是判断一个字符是由两字节组成还是四字节组成最简单的办法。12345function isBit(value)&#123; return value.codePointAt(0) &gt; 0xFFFF;&#125;console.log(isBit("𠮷")); // trueconsole.log(isBit("a")); // false String.fromCodePoint()用于从码点返回对应字符，能够识别Unicode编号大于0xFFFF的字符。1String.fromCodePoint(0x20BB7) // "𠮷" ###字符串的遍历接口ES6新增字符串遍历接口，字符串可以用for...of循环遍历。1234let str = "hello";for(let s of str)&#123; console.log(s) // "h" "e" "l" "l" "o"&#125; 这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。12345678let str = "𠮷";for(let i = 0; i &lt; str.length; i++)&#123; console.log(str[i]) // � � (打印出来是这种无法识别的符号)&#125;for(let s of str)&#123; console.log(s) // "𠮷"&#125; includes()、startsWith()、endsWith() includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在源字符串头部 endsWith()：返回布尔值，表示参数字符串是否在源字符串尾部1234let str = "hello world!";console.log(str.includes("hello")); // trueconsole.log(str.startsWith("hello")); // trueconsole.log(str.endsWith("!")); // true 这三个方法都可以接受第二个参数，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。1234 let str = "hello world!";console.log(str.includes("world", 6))console.log(str.startsWith("world", 6 ))console.log(str.endsWith("hello", 5)) repeat()这个方法接收一个参数，表示要将原字符重复的次数。123let str = "abc";console.log( str.repeat(3)) // "abcabcabc"console.log( str.repeat(0)) // "" 如果参数不是正整数，则有下面几种情况： 如果参数是小数，会被取整 如果是负数或者是Infinity，会报错 如果是0~-1之间的小数，则为0 如果是NaN，则为0 如果是字符串，则会先转换成数字 padStart()和padEnd()字符串自动补全功能，如果字符串不够长度，会在头部或者尾部补全。这两个方法都可接收两个参数，第一个参数指定字符串的最小长度，第二个参数则是用来补全的字符串。12345console.log( 'x'.padStart(5, 'ab')); // "ababx"console.log( 'x'.padStart(4, 'ab')) // "abax"console.log( 'x'.padEnd(5, 'ab')); // "xabab"console.log( 'x'.padEnd(4, 'ab')); // "xaba" 当原字符串的长度大于指定的最小长度的时候，返回原字符串本身。1console.log( 'xxxxxxx'.padStart(5, 'ab')); // "xxxxxxx" 如果用来补全的字符串与原字符串长度的和大于指定的最小长度的时候，则会截取超出指定的最小长度的字符。1console.log( 'xxx'.padStart(10, '0123456789')); // "0123456xxx" 如果省略第二个参数，默认使用空格补全长度。12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。1'1'.padStart(10, '0') // "0000000001" 另一个用途是提示字符串格式。12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。123456789// 普通字符串`hello world!`;//多行字符串`How are youI'm fine`//字符串中嵌入变量let name="Tom";let age = 20;`my name is $&#123;name&#125;, I'm $&#123;age&#125; years old`; 模板中使用多行字符串，空格和缩进会保留在输出之中。1234567 let str = ` &lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;ul&gt;`;console.log(str) 效果图如下 模板字符串中嵌入变量，需要将变量名写在${}中。大括号内可以放任意的JavaScript表达式1234567891011let x = 1, y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;` // "1 + 2 = 3"let obj = &#123;x : 1, y : 2&#125;;`$&#123;obj.x&#125; + $&#123;obj.y&#125; = $&#123;obj.x + obj.y&#125;` // "1 + 2 = 3"function fn()&#123; return "hello world";&#125;`Hi, $&#123;fn()&#125;` // "Hi, hello world" 模板字符串中的变量没有声明，就会报错。1`hello, $&#123;text&#125;` // Uncaught ReferenceError: text is not defined 模板字符串的大括号内部是一个字符串，将会原样输出。1`hello, $&#123;'world'&#125;` // "hello, world" 标签模板模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。如果模板字符串里面有变量，就会将模板字符串先处理成多个参数，再调用函数。123456789let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;function tag(arr, value1, value2)&#123; console.log(arr); // ["Hello ", " world ", "", raw: Array(3)] console.log(value1); // 15 console.log(value2); // 50&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分。其他参数，都是模板字符串各个变量被替换后的值。 String.raw()String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。1console.log(String.raw`Hi\n$&#123;2+3&#125;!` === "Hi\\n5!") // true 如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。1console.log(String.raw`Hi\\n$&#123;2+3&#125;!`) // "Hi\\n5!" String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记之变量的解构赋值]]></title>
    <url>%2F2017%2F05%2F16%2F2017-05-16-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[数组的解构赋值 基本用法 ES6运行按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructuring)。 假设我们有一个变量arr，其值为[1, 2, 3]，我们想给数组的每个元素分别声明一个变量，在ES5中的做法就是单独取出来赋值。1234let arr = [1, 2, 3];let el1 = arr[0], el2 = arr[1], el3 = arr[2]; 现在ES6允许我们在左边使用表达式来达到和上面代码一样的效果。1let [el1, el2, el3] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。这种写法属于“模式匹配”，只要等号两边模式相同，左边的变量就会被赋予对应的值。同样的，数组还可以进行嵌套。1234let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3 如果解构不成功，变量的值就被赋予undefined，就是等号左边模式匹配不到等号右边数组的值。12345let [a] = [];a // undefinedlet [a, b] = [1];a // 1b // undefined 如果是不完全解构，就是等号左边的模式，只匹配一部分等号右边数组的值，解构依然可以成功。123456let [a, b, c] = [1, 2]a // 1b // 2let [a, [b, c]] = [1, [2]]a // 1b // 2 如果等号右边不是数组，就会报错123456let [a] = 1;let [a] = true;let [a] = NaN;let [a] = undefined;let [a] = null;let [a] = &#123;&#125;; 默认值解构赋值允许指定默认值。12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a'] //x = 'a', y = 'b'let [x, y = 'b'] = ['a', undefined]; //x = 'a', y = 'b' ES6使用全等运算符判断一个位置是否有值，所以一个数组成员不严格等于undefined，默认值是不会生效的。12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 如果默认值是表达式，那么这表达式则是惰性求值。用到的时候才会求值。1234let [x = f()] = [1];function f()&#123; alert(1)&#125; 上面代码因为x能取到值，所以函数不会执行，只有当等号右边数值的值为undefined时，函数才会执行。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。12345let [x = 1, y = x] = [2];x // 2y // 2let [x = y, y = 1] = []; // ReferenceError 上面报错是因为x用y作为默认值的时候，y还没有声明。 对象的解构赋值基本用法对象的解构与数组有一个很重要的不同，数组的元素是按次序排列的，变量的取值由位置决定，而对象的属性是没有次序的，变量必须要与属性同名才能取到值。123456let &#123;bar, foo&#125; = &#123;foo: "aa", bar: "bb"&#125;;foo // aabar // bblet &#123;baz&#125; = &#123;foo: "aa", bar: "bb"&#125;;baz // undefined 如果变量名与属性名不一致，必须写成下面的形式。123456let obj = &#123;first: 'hello', last: 'world'&#125;;let &#123;first: f, last: l&#125; = obj;f // hellol // worldfirst // ReferenceErrorlast // ReferenceError 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。first是匹配的模式，f才是变量。 用let或者const声明过的变量再通过这种方式重新声明会报错。12let a;let &#123;a, b&#125; = &#123;a: 1, b : 2&#125; // ReferenceError 对象解构同样可以用于嵌套。123456789let obj = &#123; a: [ 'hello', &#123;y: 'world'&#125; ]&#125;;let &#123;a:[x, &#123;y&#125;]&#125; = obj;x // helloy // world 对象解构也可以指定默认值。默认值生效的条件是对象的属性值严格等于undefined。12345678910111213let &#123;x = 1&#125; = &#123;&#125;;x // 1let &#123;x = 1&#125; = &#123;x: 3&#125;;x // 3let &#123;x:y = 1&#125; = &#123;&#125;;y // 1let &#123;x:y = 1&#125; = &#123;x:3&#125;;y // 3let &#123;x = 1&#125; = &#123;x: undefined&#125;;x // undefinedlet &#123;x = 1&#125; = &#123;x: null&#125;;x // null 解构失败，变量的值等于undefined。12let &#123;baz&#125; = &#123;foo: "aa", bar: "bb"&#125;;baz // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。12let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;;bar // ReferenceError 因为等号左边的foo属性在等号右边不存在，所以为undefined，而bar是foo下面的一个子属性undefined.bar肯定就会报错。 如果要将一个已经声明的变量用于解构赋值，需要小心。123let x;&#123;x&#125; = &#123;x: 1&#125;;x // Unexpected token = 上面代码报错是因为JavaScript引擎将{x}解析成一个代码块，所以导致错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。123let x;(&#123;x&#125; = &#123;x: 1&#125;);x // 1 将代码放在一个圆括号里面就可以正确执行。 对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量。1let &#123;log, sin, cos&#125; = Math 字符串的解构赋值基本用法字符串也可以解构赋值，被转化成一个类数组的对象。123456let [a, b, c, d, e] = "hello";a // hb // ec // ld // le // o 每个类数组的对象都有个length属性，还可以对这个属性进行解构赋值。12let &#123;length: len&#125; = "hello";len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 函数参数的解构赋值函数参数也可以使用解构赋值。1234function fn([a, b])&#123; return a + b;&#125;fn([1, 2]) // 3 函数被传入参数的时候，数组参数就被解构成了x和y。 函数参数的解构也可以使用默认值。1234567function fn(&#123;x = 0, y = 0&#125; = &#123;&#125;)&#123; return [x, y]&#125;fn(&#123;x: 3, y:5&#125;) // [3, 5]fn(&#123;x: 3&#125;) // [3, 0]fn(&#123;&#125;) // [0, 0]fn() // [0, 0] 而下面的代码会得到不一样的结果。12345678function fn(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;fn(&#123;x: 3, y: 8&#125;); // [3, 8]fn(&#123;x: 3&#125;); // [3, undefined]fn(&#123;&#125;); // [undefined, undefined]fn(); // [0, 0] 上面代码是为函数fn的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 不能使用圆括号的情况 变量声明语句不能带有圆括号，包括函数的参数。123456let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;function f([(z)]) &#123; return z; &#125; 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。123(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 可以使用圆括号的情况赋值语句的非模式部分，可以使用圆括号。123[(b)] = [3]; (&#123; p: (d) &#125; = &#123;&#125;); [(parseInt.prop)] = [3]; 用途交换变量的值123let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值1234function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example(); 函数参数的定义1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记之let和const命令]]></title>
    <url>%2F2017%2F05%2F15%2F2017-05-15-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Blet%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近一直在看阮大神的ECMAScript 6入门这本书，边学边记，加深印象。 let和const命令ES5只有两种声明变量的方法：var命令和function命令。而ES6新增了四种声明变量的方法:let、const、import和class，所以ES6有6种声明变量的方法。 let命令 基本用法let用来声明变量， 用法类似于var，但是只在let命令所在的代码块有效。1234for(var i = 0; i &lt; 10; i++)&#123;&#125;;console.log(i) // 10for(let i = 0; i &lt; 10; i++)&#123;&#125;console.log(i) // 报错 不存在变量提升var声明的变量的能在变量声明之前访问，值为undefined，因为在脚本运行之前，变量foo已经存在，但是没有值，所以会输出undefined。12console.log(a); // undefinedvar a = 'hello'; 如果用let来声明的变量在没有声明之前就进行访问的话，会抛出异常。12console.log(a); // Uncaught ReferenceError: a is not definedvar let = 'hello'; 暂时性死区在代码块内，使用let命令声明变量之前，该变量都是不可用的。12345678if(true)&#123; tmp = "hello"; console.log(tmp); // ReferenceError let tmp; console.log(tmp); // undefined tmp = "abc"; console.log(tmp)&#125; 上图说明在第四行用let声明变量tmp之前，都属于tmp的死区。注意如果在let声明变量之前用typeof检测数据类型的话，会抛出异常。12console.log(typeof x); // ReferenceErrorlet x = 1; 不允许重复声明let不允许在相同的作用域内重复声明同一个变量123function fn(arg)&#123; let arg;&#125; 上面代码会抛出异常，改成下面这样就不会了。12345function fn(arg)&#123; &#123; let arg; &#125;&#125; 块级作用域ES5只有全局作用域和函数作用域,而ES6新增了块级作用域。 ES6允许块级作用于任意嵌套1&#123;&#123;&#123;&#123;&#123;let a = 0&#125;&#125;&#125;&#125;&#125; 上图使用了5五层块级作用域。 外层作用域无法读取内层作用域的变量 1234&#123;&#123;&#123;&#123; &#123;let a = 0&#125; console.log(a); // ReferenceError&#125;&#125;&#125;&#125; 不同作用域可以定义同名变量 12345678&#123;&#123;&#123;&#123; let a = 1; &#123; let a = 0; console.log(a) // 0 &#125; console.log(a) // 1&#125;&#125;&#125;&#125; const命令基本用法const声明一个只读的常量，一旦声明，值就不可以改变。123const PI = 3.1415;PI = 3.14;console.log(PI) // Assignment to constant variable const一旦声明变量，必须立即初始化。123const foo ;foo = "hello";console.log(foo); // Missing initializer in const declaration const和let相同，声明的变量只有在其所在的块级作用于有效，变量不会提升，同时也存在“暂时性死区”。 本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。 意思就是说用const声明的基本数据的变量是不可以改变值，而引用数据类型（主要是对象和数值）,const只能保证指针是固定的，而指向的数据是可以进行变化的。12345const foo = &#123;&#125;;foo.name = "Tom";console.log(foo); // &#123;name: "Tom"&#125;foo = &#123;&#125;; // 当把foo指向另一个对象的时候就会报错 12345const arr = [];arr.push("hello");console.log(arr); ["hello"]arr = []; // Assignment to constant variable. 如果要冻结一个对象，应该使用Object.freeze方法。123const foo = Object.freeze(&#123;&#125;);foo.name = "Tom";console.log(foo) // &#123;&#125; 常规模式下，添加属性不起作用1234"use strict";const foo = Object.freeze(&#123;&#125;);foo.name = "Tom";console.log(foo) // Cannot add property name, object is not extensible 在严格模式下会抛出异常 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数 - . -暂时没有理解到这个方法，先直接拷过来用。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css之position属性]]></title>
    <url>%2F2017%2F05%2F15%2F2017-05-15-css%E4%B9%8Bposition%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[简介 position CSS属性选择用于定位元素的替代规则，被设计为对脚本动画效果有用。 语法1234567891011/* 关键字 值 */position: static;position: relative;position: absolute;position: fixed;position: sticky; //实验性API/* 全局值 */position: inherit;position: initial;position: unset; static 元素默认定位属性默认值。没有定位，元素出现在正常的文档流中，忽略top, right, bottom, left, z-index声明。 relative 相对定位相对自己文档流中的原始位置进行定位，不会脱离文档流。上图给test4加上了position:relative效果，代码如下1position: relative; top:10px; left:-20px 可以看出test4并没有对周围的元素造成影响， 它还是存在于正常的文档流中。position:relative对 table-*-group, table-row, table-column, table-cell, table-caption 元素没有效果。 absolute 绝对定位 相对于static定位以外的第一个父元素进行定位， 脱离文档流上图给test4加上了position:absolute效果明显可以看到test4从正常的文档流中脱离了出来， test5填补了test4原本的位置。 绝对定位元素可以设置外边距，且不会与其他边距合并CSS代码 12345678910111213141516171819202122body&#123; margin: 0; padding: 0;&#125;.box &#123; position: relative; width: 500px; height: 200px; background: lightseagreen; margin: 30px&#125;.box1 &#123; position: absolute; top: 0; left: 0; margin: 20px; width: 100px; height: 50px; background: red&#125;eight: 50px;background: red&#125; HTML代码123&lt;div class="box"&gt; &lt;div class="box1"&gt;absolute定位元素&lt;/div&gt;&lt;/div&gt; 效果图 stickyposition:sticky是一个新的CSS3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置CSS代码12345678910111213141516171819202122.container &#123; background: #eee; width: 600px; height: 1000px; margin: 0 auto;&#125;.sticky-box &#123; position: -webkit-sticky; position: sticky; height: 60px; margin-bottom: 30px; background: #ff7300; top: 0px;&#125;div &#123; font-size: 30px; text-align: center; color: #fff; line-height: 60px;&#125; HTML代码123456&lt;div class="container"&gt; &lt;div class="sticky-box"&gt;内容1&lt;/div&gt; &lt;div class="sticky-box"&gt;内容2&lt;/div&gt; &lt;div class="sticky-box"&gt;内容3&lt;/div&gt; &lt;div class="sticky-box"&gt;内容4&lt;/div&gt;&lt;/div&gt; 效果图因为设定的阈值是 top:0 ，这个值表示当元素距离页面视口（Viewport，也就是fixed定位的参照）顶部距离大于 0px 时，元素以 relative 定位表现，而当元素距离页面视口小于 0px 时，元素表现为 fixed 定位，也就会固定在顶部。浏览器支持情况IOS 家族（SAFARI &amp;&amp; IOS SAFARI）和 Firefox 很早开始就支持 position:sticky 了。而 Chrome53~55 则需要启用实验性网络平台功能才行。其中 webkit 内核的要添加上私有前缀 -webkit-。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之float属性]]></title>
    <url>%2F2017%2F05%2F12%2F2017-05-12-CSS%E4%B9%8Bfloat%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[概述 CSS的float属性可以使一个元素脱离正常的文档流，然后被安放在它所在容器的左端或者右端，并且其他的文本和行内元素环绕它。 float属性介绍 left: 元素向左浮动 float: 元素向右浮动 none: 默认值 inherit： 默认值 由于float使用了块布局， 所以它会改变display的计算值 指定值 计算值 inline block inline-block block inline-table table table-row block table-row-group block table-column block tabale-column-group block tabel-cell block table-caption block table-header-group block table-footer-group block flex flex,float对这样的元素不起作用 inline-flex inline-flex, float对这样的元素不起作用 浮动元素是如何定位的当一个元素浮动后，它会被移除正常的文档流，然后向左或是向右平移，一直平移到碰到了所处容器的边缘或者碰到另外一个浮动元素。不管一个元素是行内元素还是块级元素，如果被设置了浮动，那浮动元素会生成一个块级框，可以设置它的width和height 浮动元素的一些特性 浮动元素浮动的时候， margin不会超过包含块的padding CSS代码12.box&#123; width: 200px; height: 500px; background: lightseagreen; padding: 10px&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin: 20px&#125; HTML代码123&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt;&lt;/div&gt; 效果图 如果有多个浮动元素，后面浮动元素的margin不会超过前面浮动元素的margin, 多个浮动元素，浮动元素会按顺序排列而不发生重叠现象 CSS代码12.box&#123; width: 400px; height: 500px; background: lightseagreen; padding: 10px&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin: 10px; float: left&#125; HTML代码123456&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt;&lt;/div&gt; 效果图 如果两个元素一个左浮动，一个右浮动，左浮动元素的marginRinght和右浮动的marginLeft不会重叠 CSS代码123.box&#123; width: 219px; height: 500px; background: lightseagreen;&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin-right: 10px; float: left&#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left&#125; HTML代码1234&lt;div class="box"&gt; &lt;div class="box1"&gt;左浮动元素&lt;/div&gt; &lt;div class="box2"&gt;右浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 浮动元素重叠问题 块级元素与浮动元素发生重叠，边框和背景会显示在浮动元素之下，内容会显示在浮动元素之上CSS123.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;.box1&#123;background: blue; border: 1px solid #000&#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left; margin-top: -10px&#125; HTML1234&lt;div class="box"&gt; &lt;div class="box1"&gt;我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字&lt;/div&gt; &lt;div class="box2"&gt;右浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 行内元素与浮动元素发生重叠，其边框，背景和内容都会显示在浮动元素之上CSS123.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;span&#123; background: palevioletred; &#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left; margin-top: -10px&#125; HTML1234&lt;div class="box"&gt; &lt;span&gt;我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字&lt;/span&gt; &lt;div class="box2"&gt;浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 清除浮动的方法 增加额外的div1&lt;div style="clear: both"&gt;&lt;/div&gt; 优点：简单粗暴缺点: 增加额外的无意义的标签，不利于语义化 父级元素增加overflow: hidden(关键在于触发了BFC)1.clearfix&#123; overflow:hidden&#125; 优点：代码量少，没有额外的标签缺点： 如果子元素超出父元素的范围，会造成超出的部分被隐藏 after伪类12clearfix&#123;zoom:1&#125;clearfix:after&#123;display:block; content:""; clear:both; visibility: hidden;&#125; 优点：没有额外标签，综合起来算比较好的方法缺点：稍显复杂推荐使用这种方法 float应用场景float最初应用就是文字环绕效果CSS代码12.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;img&#123; float: left&#125; HTML代码1234&lt;div class="box"&gt; &lt;img src="demo6.png" alt=""&gt; 文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕&lt;/div&gt; 效果图 还可用于横向菜单排列，但是更推荐使用display:inline-block,除了文字环绕效果，在其他几乎所有的应用场景中，float能实现的效果，display:inline-block都能实现。推荐一篇张鑫旭大神的关于float的文章,写的特别有意思。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的数组去重]]></title>
    <url>%2F2017%2F05%2F07%2F2017-05-07-js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[判断浏览器是否支持indexOf方法123456789101112131415161718//判断是否支持indexOf方法if(!Array.prototype.indexOf)&#123; Array.prototype.indexOf = function (item)&#123; var result = -1; //数组为空的时候返回-1 if (this.length == 0) &#123; return result; &#125;; for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] === item) &#123; //当当前项的值与参数值相等的时候，结束循环 result = i; break; &#125; &#125;; return result; &#125;;&#125; 遍历数组法：新建一新数组，遍历数组，值不在新数组中就加入新数组1234567891011function unique(array)&#123; //新建数组 var newArr = []; for(var i = 0; i &lt; arr.length; i++)&#123; //值不在新数组中就添加到新数组 if(newArr.indexOf(array[i]) == -1)&#123; newArr.push(array[i]); &#125; &#125;; return newArr &#125; 对象键值法：该方法执行速度比其他任何方法都快，就是占用内存大一些。新建一JS对象和数组，遍历传入数组时，判断值是否为JS对象的值，不是的话给对象新增该键并放入新数组。注意点，判断是否为JS对象键时，会自动对传入的键执行”toString()”,不同的键可能会被误认为一样。12345678910111213141516171819202122function unique(array)&#123; var obj = &#123;&#125;, newArr = [], len = array.length, val, type; for (var i = 0; i &lt; len; i++) &#123; val = array[i]; //获取值的数据类型 type = typeof val; //判断值是否存在 if (!obj[val]) &#123; //把type以数组的形式存入便于用indexOf对比 obj[val] = [type]; newArr.push(val); &#125; else if(obj[val].indexOf(type) &lt; 0) &#123; //值存在的情况下判断是否是相同的数据类型 obj[val].push(type); newArr.push(val); &#125; &#125; return newArr; &#125; 数组下标判断法：当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的。12345678910function unique(array)&#123; var newArr = [array[0]]; for (var i = 1; i &lt; array.length; i++) &#123; //判断第i项出现位置下标 if (array.indexOf(array[i]) == i) &#123; newArr.push(array[i]) &#125;; &#125; return newArr; &#125; 排序后相邻去除法：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。123456789101112function unique(array)&#123; //先排序 array.sort(); var newArr = [array[0]]; for (var i =1; i &lt; array.length; i++) &#123; //newArr最后一项就是array[i]的前一项 if(array[i] !== newArr[newArr.length - 1])&#123; newArr.push(array[i]); &#125;; &#125;; return newArr; &#125; 获取没重复的最右一值放入新数组。检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断1234567891011121314function unique(array)&#123; var r = []; for(var i = 0, len = array.length; i &lt; len; i++)&#123; for(var j = i + 1; j &lt; len; j++)&#123; if(array[i] === array[j])&#123; //当两个值相同的时候,i在内循环自增1，相当于跳出本次循环，执行下一次，当前值就不能添加到新数组 j = ++i; &#125;; &#125; r.push(array[i]); &#125;; return r; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>