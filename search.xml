<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript高级程序设计-引用类型]]></title>
    <url>%2F2017%2F06%2F15%2F2017-06-15-Javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[引用类型Object类型创建Object实例的方式有两种。 第一种通过new操作符后跟Object构造函数。12var person = new Object();person.name = 'Tom'; 第二种使用对象字面量使用法。123var person = &#123; name: 'Tom'&#125; 在通过对象字面量定义对象的时候，实际上不会调用Object构造函数。 访问对象属性一般通过点表示法，也可以使用方括号表示法。123456var person = &#123; name: 'Tom'&#125;;console.log(person.name); // Tomconsole.log(person['name']); // Tom 以下情况可以使用方括号表示法： 可以通过变量来访问属性。 12345var person = &#123; name: 'Tom'&#125;;var propertyName = 'name';console.log(person[propertyName]); // Tom 属性名中包含会导致语法错误的的字符，或者属性名使用的是关键字或者保留字 1person['first name'] = 'Tom'; Array类型创建数组的基本方式有两种：第一种是通过Array构造函数。123var arr = new Array();// 也可以省略new操作符var arr = Array(); 可以在Array()构造函数中传入参数， 有以下几种情况： 传递单个数值，则会按照该数值创建给定项数的数组 123var arr = new Array(2);console.log(arr.lenght); // [undefined, undefined]console.log(arr.lenght); // 2 传递多个数值，则会创建包含传入数值的数组 123var arr = new Array(2, 3, 4);console.log(arr); // [2, 3, 4]console.log(arr.length); // 3 传递其他类型的参数，则会创建包含传入参数的数组 123var arr = new Array("a");console.log(arr); // ["a"]console.log(arr.length); // 1 第二种是通过数组字面量表示法。1var arr = ['a', 2, 'c']; 可以通过length动态的为数组添加或者删除值。12345678var color = ['red', 'green', 'blue'];// 删除值color.length = 2;console.log(color); //["red", "green"]// 添加值color[color.length] = 'black';color[[color.length]] = 'yellow';console.log(color); // ["red", "green", "black", "yellow"] 检测数组检测某个对象是不是数组有以下两种方法： instanceof 12var arr = [];console.log(arr instanceof Array); //true Array.isArray() 12var arr = [];console.log(Array.isArray(arr)); //true 转换方法所有的对象都具有toLocaleString()、toString()和valueOf()方法。调用toString()方法会返回由数组中每个值的字符串拼接而成的一个以逗号分割的字符串。调用valueOf()返回的是数值的本身。123var color = ['red', 'yellow', 'blue'];console.log(color.toString()); // "red,yellow,blue"console.log(color.valueOf()); // ["red", "yellow", "blue"] alert()一个数组的时候，会默认在后台调用toString()方法。 join()方法join()方法可以接收一个参数，用作分隔符的字符串。123var color = ['red', 'yellow', 'blue'];console.log(color.join('-')); // "red-yellow-blue"console.log(color.join('+')); // "red+yellow+blue" 栈方法栈是一种LIFO的数据结构。ECMAScript提供了push()和pop()方法，以便实现类似栈的行为。 push()push()方法可以接受任意数量的参数，把他们逐步添加到末尾，返回修改后数组的长度。1234var arr = [];var len = arr.push('1', '2', '3');console.log(arr); // ["1", "2", "3"]console.log(len); // 3 pop()pop()方法从数值末尾移除最后一项，返回移除的项。1234var arr = ['red', 'yellow', 'blue', 'green'];var item = arr.pop();console.log(arr); // ["red", "yellow", "blue"]console.log(item); // "green" 队列方法队列数据结构访问规则是FIFO。 shift()移除数组的第一项并返回该项。1234var arr = ['red', 'yellow', 'blue', 'green'];var item = arr.shift();console.log(arr); // ["yellow", "blue", "green"]console.log(item); // "red" unshift()unshift()方法可以接受任意数量的参数，把他们逐步添加数组的前端，返回修改后数组的长度。1234var arr = ['red', 'yellow'];var item = arr.unshift('black', 'pink');console.log(arr); //["black", "pink", "red", "yellow"]console.log(item); // 4 重排序方法reverse()方法能够反转数组项的顺序。1234var arr = [1, 2, 3, 4];var newArr = arr.reverse();console.log(arr); // [4, 3, 2, 1]console.log(newArr); // [4, 3, 2, 1] sort()方法默认按照升序排列，排序时会调用每个数组项的toString()转型方法，然后比较得到的字符串。1234var arr1 = [4, 2, 6, 3];var arr2 = [5, 15, 10, 1];console.log(arr1.sort()); // [2, 3, 4, 6]console.log(arr2.sort()); // [1, 10, 15, 5] sort()可以接收一个比较函数作为参数，比较函数有两个参数，如果第一个参数应该位于第二个参数之前返回负数，两个参数相等返回0， 第一个参数应该位于第二个参数后面返回正数。123let arr = [1, 10, 15, 5];console.log(arr.sort((v1, v2) =&gt; v1 - v2)); // [1, 5, 10, 15]console.log(arr.sort((v1, v2) =&gt; v2 - v1)); // [15, 10, 5, 1] reverse()和sort()的返回值都是经过排序后的数组。 操作方法concat()concat()方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。如果传递的值不是数组，这些值就会简单的被添加到数组的末尾。123var let = ['red', 'yellow'];console.log(arr.concat([1, 2], ['hello', 'hi'])); // ["red", "yellow", 1, 2, "hello", "hi"]console.log(arr.concat('green', 'black')); // ["red", "yellow", "green", "black"] slice()slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。123var let = ['red', 'yellow', 'green', 'black'];console.log(arr.slice(1)); // ["yellow", "green", "black"]console.log(arr.slice(1, 3)); // ["yellow", "green"] 如果该参数为负数，则用数组长度加上该数来确认位置，如果结束位置小于起始位置，则返回空数组。123var let = ['red', 'yellow', 'green', 'black'];// 相当于arr.slice(0, 2)console.log(arr.slice(-4, -2)); // ["red", "yellow"] slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个数组。123456function list()&#123; // return Array.prototype.slice.call(arguments); return [].slice.call(arguments); &#125; var let = list(1, 2, 3); console.log(arr); // [1, 2, 3] splice()splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。有以下几种用法： 删除： 删除任意数量的项，只需要提供两个参数，要删除的第一项和要删除的项数。 1234let arr1 = [1, 2, 3, 4, 5];let arr2 = arr1.splice(2, 2);console.log(arr1); // [1, 2, 5]console.log(arr2); // [3, 4] 插入：可以向指定位置插入任意数量的项，只需提供三个参数，起始位置和0（要删除的项数）和要插入的项，如果要插入多项，只需在后面继续添加要插入的参数即可。 1234let arr1 = [1, 2, 3, 4, 5];let arr2 = arr1.splice(2, 0, 6, 7);console.log(arr1); // [1, 2, 6, 7, 3, 4, 5]console.log(arr2); // [] 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需提供三个参数，起始位置，要删除的项数和要插入任意数量的项。 1234let arr1 = [1, 2, 3, 4, 5];let arr2 = arr1.splice(2, 2, 6, 7);console.log(arr1); // [1, 2, 6, 7, 5]console.log(arr2); // [3, 4] splice()方法始终都会返回一个新数组，包含从原始数组中删除的项。 位置方法indexOf()和lastIndexOf()都可以接收两个参数，要查找的项和表示查找起点位置的索引。两个方法都返回要查找的项在数组中的位置，没找到返回-1。在比较第一个参数与数组中每一项时，会使用全等操作符。12345var let = [1, 2, 3, 4, 5, 4, 3, 2, 1];console.log(arr.indexOf(4)); // 3console.log(arr.indexOf(4, 4)); // 5console.log(arr.indexOf(6)); // -1console.log(arr.lastIndexOf(4)); // 5 迭代方法ECMAScript5为数组定义了5个迭代方法，每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域。传入这些方法的函数会接收三个参数，数组项的值，该项在数组中的位置和数组对象本身。 every()对数组每一项都运行给定的函数，如果函数对每一项都返回true,则返回true。every()不会改变原数组。123const arr = [2, 4, 6, 8];let everyResult = arr.every((item, index, array) =&gt; item &gt; 1);console.log(everyResult); // true some()对数组中每一项运行给的的函数，任一项返回ture，则返回true。123const arr = [1, 2, 3, 4];let someResult = arr.some((item, index, array) =&gt; item &gt; 3)console.log(someResult); // true filter()对数组每一项都运行给定的函数，返回true的项组成的数组，不会改变原数组。123const arr = [2, 4, 6, 8];let everyResult = arr.filter((item, index, array) =&gt; item &gt; 5);console.log(everyResult); // [6, 8] forEach()对数组中的每一项运行给定的函数，没有返回值。12345678const arr = [2, 4, 6, 8];let pos = [];arr.forEach((item, index, array) =&gt; &#123; if (item &gt; 5) &#123; pos.push(index); &#125;&#125;);console.log(pos); // [2, 3] map()对数组中的每一项运行给定的函数，返回每次函数调用结果组成的数组。123const arr = [1, 2, 3, 4];let mapResult = arr.map((item, index, array) =&gt; item * 2);console.log(mapResult); // [2, 4, 6, 8] 缩小方法reduce()和reduceRight()这两个方法都会迭代数组所有项，然后构建一个最终返回值。 这两个方法都接收两个参数，一个在每一项上调用的函数和作为缩小基础的初始值。传给reduce()和reduceRight()的函数接收四个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。123456const arr = [1, 2, 3, 4, 5];let result = arr.reduce((prev, cur, index, array) =&gt; prev + cur);console.log(result); // 15let result = arr.reduce((prev, cur, index, array) =&gt; prev + cur, 20);console.log(result); // 35 和reduceRight()与reduce()作用类似，只不过方向相反而已。 Date类型要创建一个日期对象，使用new操作符和Date构造函数即可，新创建的对象会自动获取当前日期和时间。1var now = new Date(); 想根据特定的日期和时间创建日期对象，需要传入该日期的毫秒数。1console.log(new Date(600000000000)); // Thu Jan 05 1989 18:40:00 GMT+0800 (中国标准时间) Date.parse()Date.parse() 方法解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为NaN。1234var str = Date.parse('2017-06-15');var str = Date.parse('June 15, 2017'); var str = Date.parse('6/15/2017'); console.log(str); //1497484800000 将表示日期的字符串传给Date构造函数，会在后台默认调用Date.parse()。 Date.UTC()Date.UTC() 方法接受的参数同日期构造函数接受最多参数时一样，返回从1970-1-1 00:00:00 UTC到指定日期的的毫秒数。12var utcDate = new Date(Date.UTC(96, 11, 1, 0, 0, 0));console.log(utcDate); // Sun Dec 01 1996 08:00:00 GMT+0800 (中国标准时间) Date.now()返回调用这个方法时的日期和时间的毫秒数。12var now = Date.now();console.log(now); // 1497515369177 valueOf()返回日期的毫秒数。12var now = new Date();console.log(now.valueOf()); // 1497515607459 日期/时间组件方法日期/时间组件方法有下图这些。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript之深浅拷贝]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-06-Javascript%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在JavaScript中，对对象进行拷贝的场景比较常见。但是简单的复制语句只能对对象进行浅拷贝，即复制的是一份引用，而不是它所引用的对象。而更多的时候，我们希望对对象进行深拷贝，避免原始对象被无意修改。对象的深拷贝与浅拷贝的区别如下： 浅拷贝：仅仅复制对象的引用，而不是对象本身 深拷贝：把复制的对象所引用的全部对象都复制一遍 浅拷贝的实现简单的复制语句1234567function simpleClone(target) &#123; var obj = &#123;&#125;; for (var attr in target) &#123; obj[attr] = target[attr]; &#125; return obj;&#125;; Object.assign()Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。12var obj = &#123; a: &#123;a: "hello", b: 21&#125; &#125;;var newObj = Object.assign(&#123;&#125;, obj); 深拷贝的实现JSON.parse()最偷懒，也是浏览器层面优化比较好的方式，就是使用JSON的解析和序列化API,既简单，效率也非常高（v8层面又C++实现的解析引擎）:1JSON.parse(JSON.stringify(target)); 但是，这种拷贝的方法存在以下问题: 一旦对象中存在函数类型（Function），此解析器会自动忽略掉Function 字符串化之后必须是标准类型的JSON格式 原型链丢失 这种拷贝方式，最适合纯数据类型的对象或者数组。 递归拷贝1234567891011121314151617function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var attr in initalObj) &#123; var prop = initalObj[attr]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if (prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[attr] = (prop.constructor === Array) ? [] : &#123;&#125;; arguments.callee(prop, obj[attr]); &#125; else &#123; obj[attr] = prop; &#125; &#125; return obj;&#125; Object.create()123456789101112131415161718function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript高级程序设计-变量、作用域和内存问题]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-08-Javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Javascript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。变量的值及其数据类型可以在脚本的生命周期内改变。 基本类型和引用类型的值ECMAScript包含两种不同数据类型的值：基本类型值和引用类型值。Javascript不允许直接访问内存中的位置，在操作对象时，实际上是操作对象的引用而不是实际的对象。 基本类型值保存在栈内存中 引用类型值保存在堆内存中 动态的属性定义一个基本类型值和引用类型值是一样的：创建一个变量并为该变量赋值。对于引用类型的值，我们可以为其添加属性和方法。 复制变量值从一个变量向另一个变量复制基本类型值的时候，会在变量对象上创建一个新值，两个变量可以参与任何操作而不相互影响。1234var num1 = 5;var num2 = num1;console.log(num1) // 5console.log(num2) // 5 当从一个变量向另一个变量复制引用类型值的时候，其实复制的是对象的引用，复制操作结束后，两个变量的引用指向同一个对象。修改其中一个变量会影响到另一个变量。1234var obj1 = &#123;name: 'Tom'&#125;;var obj2 = obj1;obj2.name = 'joy';console.log(obj1.name); //joy 传递参数ECMAScript中所有参数都是按值传递的。12345678function setName(obj)&#123; obj.name = 'Tom'; obj = new Object(); obj.name = 'Joy';&#125;var person = new Object();setName(obj);console.log(person.name); // 'Tom' 当传入的参数是对象的时候，也是按值传递，如果是按引用传递的话，当obj被赋予新的对象的时候，person也会跟着变化。 检测类型检测一个变量是不是基本类型值的时候可以通过typeof操作符，注意当值为null的时候，使用typeof操作符会返回object。1console.log(typeof null); // object 检测是哪一种引用类型值的时候用instanceof12345var a = [];var b = new RegExp();console.log(a instanceof Array) // trueconsole.log(b instanceof RegExp) //true 所有引用类型的值都是Object的实例，所以在检测引用类型值和Object构造函数的时候，始终返回true。12345var a = [];var b = new RegExp();console.log(a instanceof Object) // trueconsole.log(b instanceof Object) //true 执行环境及作用域 执行环境定义了变量或函数有权访问的其他数据。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数也随之被销毁。 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中。而在函数执行之后，栈将环境弹出，把控制权交给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象和一个作用域链。作用域链的用途是保证对执行环境的有权访问和所有函数和变量的有序访问。作用域链的前端始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，活动对象在最开始只包含一个变量，即arguments对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。 标识符的解析是沿着作用域链一级一级搜索标识符的过程。搜索过程始终从作用域链的前端开始。然后逐级的向后回溯。123456789var color = "red";function changeColor()&#123; var anotherColor = "blue"; function swapColor()&#123; var tempColor = anotherColor; &#125;; swapColor();&#125;changeColor(); 上面代码有三个执行环境：全局环境、changeColor()的局部环境和swapColor()的局部环境。全局环境中有变量color和函数changeColor()，changeColor()的局部环境中包含变量anotherColor和函数swapColor()，swapColor()局部环境中包含变量tempColor。swapColor()局部环境能访问他的包含环境的所有变量，而changeColor()局部环境和全局环境就不能访问swapColor()局部环境中的变量。 内部环境能够通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。 延长作用域链下面两个语句能够在作用域链的前端增加一个变量对象。该变量对象会在代码执行后被移除出。 try-catch语句的catch块 with语句 with会将指定的对象添加到作用域链中，catch会创建一个新的变量，其中包含的是被抛出的错误对象的声明。12345678function bulidUrl()&#123; var qs = "?debug=true"; with(location) &#123; var url = href + qs; &#125; return url;&#125;console.log(bulidUrl()) // http://localhost:63342/test/93.html?_ijt=butdjev1qf9q4jjb9qetp365sp?debug=true with语句接收的是location对象，因此变量对象中就包含了所有location对象的属性和方法。其中的href就是location.href。 没有块级作用域Javascript没有块级作用域，for语句初始化变量的表达式所定义的变量，在循环外部的执行环境也能访问到。12for(var i = 0; i &lt; 10; i++)&#123;&#125;;console.log(i); // 10 声明变量使用var声明的变量会自动被添加到最接近的环境中。如果初始化变量没有用var声明，该变量会自动被添加到全局环境。123456function add(num1, num2)&#123; num = num1 + num2; return num;&#125;console.log(add(10, 20)); // 30console.log(num); // 30 查询标识符搜索过程从作用域链的前端开始，向上逐级查询与给的名字匹配的标识符。如果在局部环境没有找到标识符，则沿着作用域链向上搜索。12345var color = "red";function sayColor()&#123; return color;&#125;;console.log(sayColor()); //color 如果在局部环境找到标识符，则停止搜索。123456var color = "red";function sayColor()&#123; var color = "blue" return color;&#125;;console.log(sayColor()); //blue 垃圾收集Javascript具有自动垃圾收集机制。执行环境会负责管理代码执行过程中使用的内存。离开作用域的值将被自动标记为可回收，因此将在垃圾收集期间被删除。 标记清除Javascript最常用的垃圾收集方式是标记清除。这种算法的思想是给当前不用的值加上标记，然后再回收其内存。 引用计数这种算法的思想是跟踪所有的值被引用的次数。Javascript引擎目前都不再使用这种算法。 管理内存优化内存占用的最佳方式是解除引用，就是一旦数据不再使用，手动将值设置为null来释放引用。 12345678function createPerson(name)&#123; var localPerson = new Object(); localPerson.name = name; return localPerson;&#125;var globalPerson = createPerson('Tom');globalPerson = null; 解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用的正在目的是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript高级程序设计-基础概念]]></title>
    <url>%2F2017%2F06%2F02%2F2017-06-02-Javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[语法区分大小写ECMAScript是区分大小写的，包括变量，函数名和操作符。 标识符标识符指的是函数，变量，属性的名字。必须要遵循以下规则： 第一个字符必须是字母、下划线、或者美元符号 其他字符可以是字符、下划线、美元符号或者数字 标识符推荐采用驼峰大小写格式。 注释单行注释1// 单行注释 块级注释123/* * 块级注释 */ 严格模式除了正常运行模式，ECMAScript5添加了第二种正常运行模式：“严格模式”。设立严格模式的目的： 消除Javascript语法一些不合理、不严谨的地方，减少一些怪异的行为 消除代码运行的一些不安全之处，保证代码运行的安全 提高编译器效率，增加运行速度 为未来的新版本Javascript做好铺垫 严格模式有两种调用方法： 整个脚本启用严格模式 1"use strict"; 函数内部启用严格模式 123(function()&#123; "use strict";&#125;()) 不管在什么情况下启用严格模式都必须放在第一行，否则不会生效。 语句ECMAScript中的语句以分号结尾，虽然可以不写，但是不推荐。分号加与不加完全取决于个人习惯，但为了代码稳定（解析出错）还是建议使用分号断句。Javascript自动加分号规则： 当有换行符（包括含有换行符的多行注释），并且下一个token没法跟前面的语法匹配时，会自动补分号。 当有}时，如果缺少分号，会补分号。 当程序源代码结束时，如果缺少分号，会补分号。结论： 在return、break、continue、后自增、后自减五种语句中，换行符可以完全替代分号的作用。 var、if、do、while、for、continue、break、return、with、switch、throw、try、 debugger几种关键字开头的语句，以及空语句，上一行加不加分号影响不大。 凡表达式语句和函数表达式语句，后面不加分号非常危险，情况极其复杂。 凡(和[开头的语句，前面不加分号极度危险。 变量ECMAScript变量是松散类型的，可以用来保存任何类型的数据。声明变量要使用var操作符后跟变量名。1var message; 上面代码是未初始化变量，会保存特殊值“undefined”。也可以在声明的时候直接初始化变量。1var message = "hi"; 使用var声明的变量会成为定义该变量作用域的局部变量。在函数中通过var声明的变量会在函数退出后销毁。12345function test()&#123; var a = 1;&#125;;test();console.log(a) // Uncaught ReferenceError: a is not defined 上面代码如果省略var就会创建一个全局变量，在全局作用于内任何地方都能访问到。12345function test()&#123; a = 1;&#125;;test();console.log(a) // 1 一条语句可以定义多个变量，通过逗号分割开。123var a = 1, b = 2, c = "hello"; 严格模式下，定义名为eval和arguments的变量会报错。12"use strict";var eval = "hello" // Uncaught SyntaxError: Unexpected eval or arguments in strict mode 数据类型ECMAScript有5种基本数据类型：Undefined、Null、Boolean、Number、String和一种引用数据类型：Object。 typeof操作符用来检测变量的数据类型12345678910111213141516var a;var b = 'hi';var c = 1;var d = true;var e = &#123;&#125;;var f = function()&#123;&#125;;var g = new RegExp;var h = null;console.log(typeof a); // undefinedconsole.log(typeof b); // stringconsole.log(typeof c); // numberconsole.log(typeof d); // booleanconsole.log(typeof e); // objectconsole.log(typeof f); // functionconsole.log(typeof g); // objectconsole.log(typeof h); // object typeof null会返回object,因为null被认为是一个空的对象。 Undefined类型使用var声明变量时未进行初始化，这个变量的值就是undefined。主要用来区分空对象指针与未经初始化的变量。未初始化的变量和未定义的变量是不一样的，直接使用未定义的变量会报错。123var a;console.log(a); // undefinedconsole.log(b); // Uncaught ReferenceError: b is not defined Null类型null表示一个对象的空指针，如果定义的变量将来用于保存对象，最好将该变量初始化为null。undefined的值派生自null，所以相等测试返回true。1console.log(undefined == null); // true Boolean类型Boolean类型有两个字面值：true和false。ECMAScript所有类型的值都能通过Boolean()转型函数转换为Boolean值。转换规则如下： 数据类型 转化为true的值 转化为false的值 Boolean true false String 非空字符串 “”（空字符串） Number 非零数字 0和NaN Object 任何对象 null Undefined 不能转化为true Undefined Number类型Number类型使用IEEE754来表示整数和浮点数。整数可以通过十进制、八进制、十六进制来表示。八进制第一位必须是0，后面是八进制数字序列（0~7），如果数值超出了范围，则省略前导的0，后面数字以十进制解析。八进制在严格模式下无效，会抛出异常。12console.log(070) // 56console.log(079); // 79 十六进制前两位必须是0x开头，后面是十六进制数字序列（0~7及A~F）。1console.log(0xA); // 10 浮点数值浮点数值需要的内存空间是整数的两倍，所以ECMAScript会将小数点后没有数字的（如1.）和本身就表示一个整数的（如1.0）的浮点数值转化为整数。可以用科学计数法表示极大或者极小的浮点数值。默认情况下ECMAScript会将小数点后带有6个零以上的浮点数在转化为e表示法。如：123console.log(3.12e7) // 31200000console.log(3.12e-6) // 0.00000312console.log(3.12e-7) // 3.12e-7 浮点数值在任何机器的上都不能直接判断相等，最好通过精度来判断。 数值范围ECMAScripot的数值范围在Number.MIN_VALUE和Number.MAX_VALUE之间，如果超出这个范围， 将会被转换成Infinity值，该值不能用于计算，要想确定一个值是否是有穷的，通过isFinite()判断，函数参数位于最大值与最小值之间返回true。123console.log(Number.MIN_VALUE); // 5e-324console.log(Number.MAX_VALUE); // 1.7976931348623157e+308console.log(isFinite(Number.MIN_VALUE + Number.MIN_VALUE)); // false NaN这个数值表示一个本来要返回数值的操作数未返回数值的情况。 任何涉及到NaN的操作都会返回NaN NaN与任何值都不相等，包括自身1console.log(NaN === NaN) // false ECMAScript定义了isNaN()函数，该函数接收一个参数，会尝试将这个参数转换成数值，转换成功返回false, 失败返回true。12345console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // falseconsole.log(isNaN('10')); // falseconsole.log(isNaN('color')); // trueconsole.log(isNaN(true)); // false 数值转换有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。Number()可用于任何数据类型，另两个则专门用于把字符串转换成数值。 Number()转换规则如下： 如果是Boolean值，则把true和false转换成1和0 如果是数值，返回本身 如果是Null， 返回0 如果是undefined，返回NaN 如果是字符串，则有一下几种情况 如果字符串中只包含数字，则转换成对应十进制 1234console.log(Number("10")); // 10console.log(Number("+10")); //10console.log(Number("-10")); // -10console.log(Number("010")); // 10 如果字符串中包含有效的浮点格式，则转换成对应的浮点数值。 1234console.log(Number("10.3")); // 10.3console.log(Number("+10.3")); // 10.3console.log(Number("-10.3")); //-10.3console.log(Number("010.3")); // 10.3 如果字符串中包含有效的十六进制格式，则转换成相同大小的十进制整数值。 1console.log(Number("0xF")); // 15 如果字符串为空，则转换为0 1console.log(Number(" ")); // 0 字符串中包含除上述格式之外的字符， 则转换为NaN 如果是对象， 则调用对象的valueOf()方法，然后按照前面规则转换，如果转换结果是NaN，则调用对象的toString()方法，再次依照前面规则转换。日期对象会转换成相应的毫秒数。 12let now = new Date();console.log(Number(now)); // 1495076392196 parseInt()函数在转换字符串时会忽略字符串前面的空格，直到找到第一个非空格字符串。如果第一个字符不是数字字符或者负号，就会返回NaN，如果第一个字符是数字字符，parseInt()会继续解析后面的字符，直到解析完所有字符或者遇到非数字字符。parseInt()解析空字符串会返回NaN。同样，parseInt()也能辨别各种整数格式。123456console.log(parseInt("")); // NaNconsole.log(parseInt("123abc")); // 123console.log(parseInt("abc123")); // NaNconsole.log(parseInt("10.2")); // 10console.log(parseInt("070")); // 70 (ECMAScript5已经不具备解析八进制的能力，所以认为前导的0无效)console.log(parseInt("0xFWQR")); // 15 parseInt()可以接受第二个参数来指定整数的格式。默认是转换成十进制。1234console.log(parseInt("10", 2)); // 2console.log(parseInt("10", 8)); // 8console.log(parseInt("10", 10)); // 10console.log(parseInt("10", 16)); // 16 parseFloat()函数与parseInt()类似，不同的是parseFloat()解析完成或者遇到第一个无效的浮点数字字符为止，但是第一个小数点是有效的。parseFloat()始终会忽略前导的零，十六进制的字符串始终会被转换成0，由于parseFloat()只解析十进制值，所以不能指定第二个参数，如果字符串包含的是一个可解析成整数的数值，parseFloat()会返回整数。123456console.log(parseFloat("123abc")); // 123console.log(parseFloat("0xF")); // 0console.log(parseFloat("10.5")); // 10.5console.log(parseFloat("10.5.5")); // 10.5console.log(parseFloat("010.5")); // 10.5console.log(parseFloat("10.0")); // 10 String类型String由零或者多个16为Unicode字符组成的字符序列，可以用双引号或者单引号表示。 字符串的特点字符串是不可变的，要改变某个变量保存的字符串首先要先销毁原来的字符串。然后用新值填充该变量。 转换为字符串可以通过toString()将Number、Boolean、Object和String类型的数据转换为字符串，该方法可以接收一个参数：输出数值的基数。在不知道值是不是Null或Undefined的情况下，可以通过String()方法进行转换。转换规则如下： 如果值有toString()方法，则直接调用该方法 如果值为null，返回null 如果值为undefined，返回undefined Object类型ECMAScript对象就是一组数据和功能的集合。可以通过new操作符后跟要创建的对象类型的名称来创建。创建Object类型的实例并为其添加属性和方法就可以创建自定义对象。123456var person = new Object();person.name = "Tom";person.sayName = function()&#123; alert(this.name);&#125;person.sayName(); // Tom Object类型是所有它的实例的基础，它所具有的所有属性和方法都能被实例所共享。Object每个实例都有一下属性和方法： constructor: 保存着用于创建当前对象的函数 12var obj = new Object();console.log(obj.constructor === Object) // true hasOwnProperty(): 检查给定属性是否存在当前实例中，如果存在于原型中返回true，实例本身属性返回false 123456function Person()&#123;&#125;;Person.prototype.name = "Tom";var person = new Person();person.age = 20;console.log(Person.hasOwnProperty("name")); // trueconsole.log(Person.hasOwnProperty("age")); // false isPrototypeOf(): 用于检查传入的对象是否是另一个对象的原型 12345function Foo()&#123;&#125;;function Bar()&#123;&#125;;Foo.prototype = new Bar();var f1 = new Foo();console.log(Bar.prototype.isPrototypeOf(f1)) // true propertyIsEnumerable(): 检查给定的属性能否通过for-in来枚举 这个属性必须属于实例的，并且不属于原型。 这个属性必须是可枚举的，也就是自定义的属性。 如果对象没有指定的属性，该方法返回false 12345678910function Person()&#123;&#125;;Person.prototype.name = 'Tom';var p1 = new Person();p1.age = 20;for(var attr in p1) &#123;console.log(attr) // age name&#125;console.log(p1.propertyIsEnumerable('age')) // trueconsole.log(p1.propertyIsEnumerable('name')); // falseconsole.log(p1.propertyIsEnumerable('toString')); //false toLocaleString(): 返回对象的字符串表示法，该字符串与执行环境的地区对应 toString(): 返回对象的字符串表示 valueOf(): 返回对象的字符串、数值和布尔值表示 操作符一元操作符只能操作一个值的操作符叫做一元操作符。分为递增和递减操作符，递增和递减操作符又有前置型和后置型两种。前置型：递增和递减操作在语句求值之前执行123456var num1 = 2, num2 = 10;var num3 = --num1 + num2;var num4 = num1 + num2;console.log(num3); // 11console.log(num4); // 11 后置型：递增和递减操作在语句求值之后执行123456var num1 = 2, num2 = 10;var num3 = num1-- + num2;var num4 = num1 + num2;console.log(num3); // 12console.log(num4); // 11 这四个操作符对任何值都适用，内部默认调用Number()进行转换。 一元加和减操作符一元加操作符以一个加号表示，放在数值前面。对数值不会产生任何影响。123var num = 20;num = +num;console.log(num) // 20 如果是非数值则内部调用Number()进行数据类型转化。 一元减操作符用于将一个数值转化为负数123var num = 20;num = -num;console.log(num) // -20 如果是非数值则先内部调用Number()进行数据类型转化，然后再变为负数。 位操作符ECMAScript中所有数值都以IEEE-754 64位格式存储，但位操作符不直接操作64位的值，而是将64位值转换为32位的整数，操作完成后再转换为64位。对于有符号的整数，前31位表示整数的值，第32位表示符号：0表示正数，1表示负数。表示符号的叫符号位。正数以纯二进制格式存储，31位中的每一位都表示2的幂，没有用到的位以0填充，忽略不计。二进制转化成十进制如下1210010 =&gt; (2⁴*1)+(2³*0)+(2²*0)+(2¹*1)+(2⁰*0) 16 + 0 + 0 + 2 + 0 = 18 负数是用二进制的补码进行存储。计算一个数值的二进制补码需要经过下面步骤： 求这个数值绝对值的二进制码 求二进制的反码，即0替换成1，1替换成0 得到二进制反码加1 求-18的二进制码步骤如下： 123456789(1)先取到18的二进制码0000 0000 0000 0000 0000 0000 0001 0010(2)取其反码1111 1111 1111 1111 1111 1111 1110 1101(3)反码加一1111 1111 1111 1111 1111 1111 1110 1101 1----------------------------------------1111 1111 1111 1111 1111 1111 1111 1110 按位非（~）执行按位非的结果返回数值的反码，按位非的本质是操作数的负值减1。123var num1 = 2;var num2 = ~num1;console.log(num2); // -3 浮点数取整12console.log(~~3.14); // 3console.log(~~-3.14); //-3 indexOf判断字符是否存在1234var str = "hello";if(~str.indexOf('e'))&#123; ...&#125; 按位与（&amp;）按位与的操作是将两个数值的每一位对齐，两个数的值为1时，才返回1，其他为零。1234567 var result = 3 &amp; 5; console.log(result) // 1 0011&amp; 0101------ 0001 可以用一个数和1进行按位&amp;操作来判断一个数是奇数还是偶数1234567function assert(n) &#123; if (n &amp; 1) &#123; console.log("奇数"); &#125; else &#123; console.log("偶数"); &#125;&#125; 因为奇数的最后一位肯定是1，而1只有最后一位为1，按位&amp;操作之后，结果肯定只有最后一位数为1。而偶数的二进制表示的最后一位数是0，和1进行按位&amp;操作，结果所有位数都为0。 按位或（|）只要两个数中有一个数为1，结果就为1，其他则为0。1234 0001| 0011------ 0011 可以用来对浮点数向下求整1var num = 1.1 | 0; // 1 按位异或（^）按位异或是两个数中只有一个1时返回1，其他情况返回0。1234 0001^ 0011------- 0010 可以用来调换两个数值的值。1234567var num1 = 1, num2 = 2;num1 ^= num2;num2 ^= num1;num1 ^= num2;console.log(num1); // 2console.log(num2); // 1 有符号左移（&lt;&lt;）有符号左移会将32位二进制数的所有位向左移动指定位数。如：12var num = 2; // 二进制10num = num &lt;&lt; 5; // 二进制1000000，十进制64 如果要求2的n次方，可以这样：1234function power(n) &#123; return 1 &lt;&lt; n;&#125;power(5); // 32 有符号右移（&gt;&gt;）有符号右移会将32位二进制数的所有位向右移动指定位数。如：12var num = 64; // 二进制1000000num = num &gt;&gt; 5; // 二进制10，十进制2 可以用来求一个数的二分之一1var num = 10 &gt;&gt; 1; // 5 无符号右移（&gt;&gt;&gt;）正数的无符号右移与有符号右移结果是一样的。负数的无符号右移会把符号位也一起移动，而且无符号右移会把负数的二进制码当成正数的二进制码：12var num = -64; // 11111111111111111111111111000000num = num &gt;&gt;&gt; 5; // 134217726 可以利用无符号右移来判断一个数的正负：123456function isPos(n) &#123;return (n === (n &gt;&gt;&gt; 0)) ? true : false; &#125;isPos(-1); // falseisPos(1); // true -1&gt;&gt;&gt;0虽然没有向右移动位数，但-1的二进制码已经变成了正数的二进制码,所以不会相等。 应该尽量少用位操作符进行运算，这会导致代码阅读困难。 布尔操作符布尔操作符一共有三个：非（!）、与（&amp;&amp;）、或（||）。 逻辑非（!）逻辑非会将操作数转化为布尔值，然后对其求反。转换规则与Boolean()函数类似。!!会将一个数转换为Boolean值。12345console.log(!!"hello"); // trueconsole.log(!!0); // falseconsole.log(!!NaN); // falseconsole.log(!!""); // falseconsole.log(!!10); // true 逻辑与（&amp;&amp;）逻辑与有两个操作数。只要其中有一个为false，则返回false。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值，遵循以下规则： 第一个操作数是对象，则返回第二个操作数 第二个操作数是对象，则在第一个操作数求值结果为true的情况下返回该对象 两个操作数都是对象，则返回第二个 如果有一个操作数为null,则返回null 如果有一个操作数为NaN,则返回NaN 如果有一个操作数为Undefined,则返回Undefined 逻辑与属于短路操作，第一个操作数为false，就不会对第二个操作数求值。 逻辑或（||）逻辑或有两个操作数。只要其中有一个为true，则返回true。 在有一个操作数不是布尔值的情况下，逻辑或操作不一定返回布尔值，遵循以下规则： 第一个操作数是对象，则返回第一个操作数 第一个操作数求值结果为false，则返回第二个操作数 两个操作数都是对象，则返回第一个 如果有一个操作数为null,则返回null 如果有一个操作数为NaN,则返回NaN 如果有一个操作数为Undefined,则返回Undefined 逻辑或也属于短路操作，第一个操作为true，就不会对第二个操作数求值。可以利用这一行为避免为变量赋null和undefined值。123var obj = null;var result = obj || &#123;&#125;;console.log(result); // object 乘性操作符ECMAScript定义了三个乘性操作符：乘法、除法和求模。在操作数是非数值的情况下会默认在内部调用Number()函数进行数据类型的转换。 乘法处理特殊值乘法操作遵循一下规则： 如果乘积超过ECMAScript数值范围，则返回Infinity或者-Infinity 123var num = Number.MAX_VALUE;var result = num * 2;console.log(result); // Infinity 如果有一个操作数为NaN，则返回NaN 如果是Infinity与0相乘， 则返回NaN 如果是Infinity与非0相乘，则返回Infinity或者-Infinity 如果一个操作数不是数值，则在内部调用Number()将其转换为数值，再应用上面规则 除法处理特殊值乘法操作遵循一下规则： 如果乘积超过ECMAScript数值范围，则返回Infinity或者-Infinity 如果有一个操作数为NaN，则返回NaN 如果是Infinity被Infinity除，则结果是NaN 如果是0被0除，结果是NaN 如果是非0的有限数被0除，则返回Infinity或者-Infinity 1console.log(100 / 0); // Infinity 如果是Infinity被任何非零的数除，则返回Infinity或者-Infinity 1console.log(Infinity / 100); //Infinity 如果一个操作数不是数值，则在内部调用Number()将其转换为数值，再应用上面规则 加性操作符加性操作符分为加法和减法。加性操作符和乘性操作符类似，也会在后台转换不同的数据类型 加法如果两个操作符都是数值，返回下列结果： 如果有一个操作数是NaN，则结果是NaN Infinity加Infinity，结果是Infinity -Infinity加-Infinity，结果是-Infinity Infinity加-Infinity，结果是NaN +0加+0，结果是+0 -0加-0，结果是-0 +0加-0，结果是+0 如果有一个操作符是字符串，就要应用如下规则： 两个操作符都是字符串，则把他们两个拼接起来 如果只有一个操作符是字符串，则将另一个转换为字符串，然后拼接起来 减法如果两个操作符都是数值，返回下列结果： 如果有一个操作数是NaN，则结果是NaN Infinity减Infinity，结果是NaN -Infinity减-Infinity，结果是NaN Infinity减-Infinity，结果是Infinity -Infinity减Infinity，结果是-Infinity +0减+0，结果是+0 -0减-0，结果是-0 +0减-0，结果是+0 如果一个操作数是字符串、布尔值、null、undefined，则现在内部调用Number()函数将其转换为数值，再根据前面的规则进行计算 如果一个操作数是对象，则调用valueOf()方法以取得该对象的数值，如果该对象没有valueOf()方法，则调用其toString()方法。 关系操作符关系操作符返回一个布尔值。当关系操作符的操作数使用了非数值的时候，也要进行数据转换，转换规则如下： 如果都是字符串，则比较字符串对应的Unicode编码 如果其中一个是数值，则把另一个也转换成数值 如果一个操作数是对象，则调用valueOf()方法以取得该对象的数值，如果该对象没有valueOf()方法，则调用其toString()方法。 如果一个操作数是布尔值，则将其转换成数值进行比较 相等操作符ECMAScript提供两组操作符：相等和不相等-先转换再比较，全等和不全等-仅比较而不转换。 比较对象时，比较的是对象的存储地址。如果两个对象的引用都指向相同的地址，则为true。 undefined和null执行相等比较的时候返回true。 在代码中尽量使用全等进行比较。 条件操作符条件操作符格式如下：1var num = (num1 &gt; num2) ? num1 : num2; 当num1大于num2的时候，将num1赋值给num，否则将num2赋值给num。 赋值操作符作用就是把右侧的值赋给左侧的变量。1var num = 10; 逗号操作符使用逗号操作符可以在一个语句中执行多个操作。可以用逗号操作符来声明多个变量：123var num1 = 10, num2 = 20, num3 = 30; 也可以用于赋值，但返回的是最后一个：12var num = (1, 2, 3, 5, 6);console.log(num); // 6 语句if语句当指定条件为 true 时，if 语句 会执行一条语句。如果该条件为 false，则执行另一条语句。12345if (condition) &#123; statements1&#125; else &#123; statements2&#125; do-while语句在对表达式求值前，循环体内的代码至少会被执行一次。123do &#123; statement&#125; while (expression) while语句while 语句可以在某个条件表达式为真的前提下，循环执行指定的一段代码，直到那个表达式不为真时结束循环。123while (condition) &#123; statement&#125; for语句for语句用于创建一个循环,它包含了三个可选的表达式,三个可选的表达式包围在圆括号中并由分号分隔,后面跟随一个语句或一组语句在循环中执行。1234for (var i = 0; i &lt; 9; i++) &#123; console.log(i); // more statements&#125; 由于ECMAScript不存在块级作用域，在循环内定义的变量也能在循环外访问到。12for(var i = 0; i &lt; 10; i++)&#123;&#125;;console.log(i); // 10 for-in语句for…in 语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。12345678var obj = &#123; name: "Tom", age: 20, job: 'student'&#125;;for(var attr in obj) &#123; console.log(attr) // name, age, job&#125; 通过for-in循环输出的属性名顺序是不可预测的。 break和continue语句break语句会立刻退出循环，强制执行循环后面的语句。123456for(var i = 0; i &lt; 5; i++ )&#123; if( i == 3) &#123; break; &#125;; console.log(i) // 0 1 2&#125; continue退出循环后从循环的顶部继续执行。123456for(var i = 0; i &lt; 5; i++ )&#123; if( i == 3) &#123; continue; &#125;; console.log(i) // 0 1 2 4&#125; switch语句switch语句评估一个表达式，，将表达式的值与case子句匹配，并执行与该情况相关联的语句。12345678910111213141516171819switch (expression) &#123; case value1: // 当 expression 的结果与 value1 匹配时，从此处开始执行 statements1； [break;] case value2: // 当 expression 的结果与 value2 匹配时，从此处开始执行 statements2; [break;] ... case valueN: // 当 expression 的结果与 valueN 匹配时，从此处开始执行 statementsN; [break;] default: // 如果 expression 与上面的 value 值都不匹配时，执行此处的语句 statements_def; [break;]&#125; 函数函数使用function关键字来声明，后跟一组参数以及函数体。1function functionName(arg0, arg1, ...argN)&#123;&#125; argumentsarguments 是一个类似数组的对象, 对应于传递给函数的参数。arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。例如，如果一个函数传递了三个参数，你可以参考它们如下：123arguments[0]arguments[1]arguments[2] 参数也可以被设置：1arguments[1] = 'new value'; arguments对象不是一个 Array 。它类似于数组，但除了 长度之外没有任何数组属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的数组：12var args = Array.prototype.slice.call(arguments); var args = [].slice.call(arguments); 没有重载ECMAScript函数不能实现重载，两个相同名字的函数，后面的会覆盖前面的函数。1234567function fn(num) &#123; alert(2)&#125;;function fn() &#123; alert(1)&#125;;fn(10); // 1]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记之数值的扩展]]></title>
    <url>%2F2017%2F05%2F18%2F2017-05-18-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[ES5中的Number类型Number采用IEEE754格式来表示整数和浮点数。整数可以通过十进制、八进制、十六进制字面量来表示。 八进制字面量第一位必须是0，如果字面值中的数值超过范围，前导的零将会被省略，后面数值当作十进制解析。123console.log(070); // 56console.log(08); // 8console.log(089)； // 89 八进制字面量在严格模式下会报错 十六进制字面量前两位必须是0x,超出字面量会报错。12console.log(0xF); // 15console.log(0xG); // Uncaught SyntaxError: Invalid or unexpected token 在进行算术计算的时候，八进制和十六进制的数值最终都会转换成十进制。 浮点数值浮点数值需要的内存空间是保存整数值的两倍，如果小数点后面没有任何数值，或者浮点数本身就表示一个整数，那么都会转换为整数。12console.log(10.); // 10console.log(10.0); // 10 数值范围ECMAScripot的数值范围在Number.MIN_VALUE和Number.MAX_VALUE之间，如果超出这个范围， 将会被转换成Infinity值，该值不能用于计算，要想确定一个值是否是有穷的，通过isFinite()判断，函数参数位于最大值与最小值之间返回true。123console.log(Number.MIN_VALUE); // 5e-324console.log(Number.MAX_VALUE); // 1.7976931348623157e+308console.log(isFinite(Number.MIN_VALUE + Number.MIN_VALUE)); // false NaN这个数值表示一个本来要返回数值的操作数未返回数值的情况。 任何涉及到NaN的操作都会返回NaN NaN与任何值都不相等，包括自身1console.log(NaN === NaN) // false ECMAScript定义了isNaN()函数，该函数接收一个参数，会尝试将这个参数转换成数值，转换成功返回false, 失败返回true。12345console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // falseconsole.log(isNaN('10')); // falseconsole.log(isNaN('color')); // trueconsole.log(isNaN(true)); // false 数值转换有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。Number()可用于任何数据类型，另两个则专门用于把字符串转换成数值。 Number()转换规则如下： 如果是Boolean值，则把true和false转换成1和0 如果是数值，返回本身 如果是Null， 返回0 如果是undefined，返回NaN 如果是字符串，则有一下几种情况 如果字符串中只包含数字，则转换成对应十进制 1234console.log(Number("10")); // 10console.log(Number("+10")); //10console.log(Number("-10")); // -10console.log(Number("010")); // 10 如果字符串中包含有效的浮点格式，则转换成对应的浮点数值。 1234console.log(Number("10.3")); // 10.3console.log(Number("+10.3")); // 10.3console.log(Number("-10.3")); //-10.3console.log(Number("010.3")); // 10.3 如果字符串中包含有效的十六进制格式，则转换成相同大小的十进制整数值。 1console.log(Number("0xF")); // 15 如果字符串为空，则转换为0 1console.log(Number(" ")); // 0 字符串中包含除上述格式之外的字符， 则转换为NaN 如果是对象， 则调用对象的valueOf()方法，然后按照前面规则转换，如果转换结果是NaN，则调用对象的toString()方法，再次依照前面规则转换。日期对象会转换成相应的毫秒数。 12let now = new Date();console.log(Number(now)); // 1495076392196 parseInt()函数在转换字符串时会忽略字符串前面的空格，直到找到第一个非空格字符串。如果第一个字符不是数字字符或者负号，就会返回NaN，如果第一个字符是数字字符，parseInt()会继续解析后面的字符，直到解析完所有字符或者遇到非数字字符。parseInt()解析空字符串会返回NaN。同样，parseInt()也能辨别各种整数格式。123456console.log(parseInt("")); // NaNconsole.log(parseInt("123abc")); // 123console.log(parseInt("abc123")); // NaNconsole.log(parseInt("10.2")); // 10console.log(parseInt("070")); // 70 (ECMAScript5已经不具备解析八进制的能力，所以认为前导的0无效)console.log(parseInt("0xFWQR")); // 15 parseInt()可以接受第二个参数来指定整数的格式。默认是转换成十进制。1234console.log(parseInt("10", 2)); // 2console.log(parseInt("10", 8)); // 8console.log(parseInt("10", 10)); // 10console.log(parseInt("10", 16)); // 16 parseFloat()函数与parseInt()类似，不同的是parseFloat()解析完成或者遇到第一个无效的浮点数字字符为止，但是第一个小数点是有效的。parseFloat()始终会忽略前导的零，十六进制的字符串始终会被转换成0，由于parseFloat()只解析十进制值，所以布恩那个指定第二个参数，如果字符串包含的是一个可解析成整数的数值，parseFloat()会返回整数。123456console.log(parseFloat("123abc")); // 123console.log(parseFloat("0xF")); // 0console.log(parseFloat("10.5")); // 10.5console.log(parseFloat("10.5.5")); // 10.5console.log(parseFloat("010.5")); // 10.5console.log(parseFloat("10.0")); // 10 ES6数值扩展二进制和八进制表示法ES6提供了新的二进制和八进制数值的新写法，分别用0b和0o表示。12console.log(0b0001); // 1console.log(0o70); // 56 要把二进制和八进制转换成十进制，调用Number()方法。12console.log(Number(0b0001)); // 1console.log(Number(0o70)); // 56 Number.isFinite()、Number.isNaN()这两个方法与传统的全局方法isFinite()和isNaN()相比，这两个新方法只对数值有效。12345console.log(isFinite("10")); // trueconsole.log(Number.isFinite("10")); // falseconsole.log(isNaN("NaN")); // trueconsole.log(Number.isNaN("NaN")); // false Number.parseInt(), Number.parseFloat()与ES5parseInt()和parseFloat()行为完全一样。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 Number.isInteger()用来判断一个数是否为整数。同样能够识别不同格式的整数，如果第一位是零，则忽略。123456console.log(Number.isInteger(10)); // trueconsole.log(Number.isInteger("10")); // falseconsole.log(Number.isInteger(10.0)); // trueconsole.log(Number.isInteger(10.1)); // falseconsole.log(Number.isInteger(010)); // trueconsole.log(Number.isInteger(0xF)); // true Number.EPSILON引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。如果浮点数的计算误差小于Number.EPSILON，我们就可以认为等到了正确的结果。1console.log(Number.EPSILON); // 2.220446049250313e-16 安全整数和Number.isSafeInteger()ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示安全整数范围的上下限。12console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991 Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。1console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1)); //false 验证的时候不止要验证结果是否为安全数，还要验证参与计算的值是否为安全数。 ES6在Math对象上新增了17个与数学相关的方法，新增了4个对数相关方法，新增了6个三角函数方法，一个指数运算符。具体请参考MDN]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记之字符串的扩展]]></title>
    <url>%2F2017%2F05%2F17%2F2017-05-17-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[ES5中字符串的属性和方法lengthSting类型的每个实例都有一个length的属性，表示字符串包含多少个字符。12let stringValue = 'hello';console.log(stringValue.length) // 5 charAt()和charCodeAt()用于访问字符串中特定的字符，两个方法都接受一个参数，即字符所在的下标位置。其中charAt()方法返回下标所在的字符，而charCodeAt()则返回下标对应的字符的字符编码。123let str = 'hello';console.log(str.charAt(1)); // econsole.log(str.charCodeAt(1)); // 101 还可以通过方括号加下标直接取到对应字符12let str = 'hello';console.log(str[1]); // e concat()用于将多个字符拼接起来，返回拼接得到的新字符，不会修改字符串本身的值。123let str = "hello";let result = str.concat(" world","!");console.log(result) //hello world! 但是实际应用中还是用“+”操作符更方便。 slice()、substr()、substring()这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串开始的位置，第二个参数表示子字符串到哪里结束。slice()和substring()的第二个参数指定子字符串最后一个字符的位置(不包含字符本身)。而substr()的第二个参数指定的则是返回的字符个数。如果不给这些方法指定第二个参数，则将字符串的长度作为结束位置。它们都不会修改字符串本身的值。12345678let str = "hello world";console.log(str.slice(3)); // lo worldconsole.log(str.substr(3)); // lo worldconsole.log(str.substring(3)); // lo worldconsole.log(str.slice(3, 7)); // lo wconsole.log(str.substr(3, 7)); // lo worlconsole.log(str.substring(3, 7)); // lo w 如果传递给这些方法的参数是负值，结果就不相同了。 slice()方法会将传入的负值与字符串的长度相加。 substr()将负的第一个参数加上字符串的长度，将负的第二个参数转换为0。 substring()方法会将所有的负的参数转换为0。12345678let str = "hello world";console.log(str.slice(-3)); // rldconsole.log(str.substr(-3)); // rldconsole.log(str.substring(-3)); // hello worldconsole.log(str.slice(3, -4)); // lo wconsole.log(str.substr(3, -4)); // (空字符串)console.log(str.substring(3, -4)); // hel 注意:substring()这个方法始终会将较小的数作为开始位置，较大的数作为结束位置。 indexOf()和lastIndexOf()两个方法都是从字符串中搜索给定的子字符串，然后返回字符串的位置。如果没有找到就返回-1。indexOf()从字符串的开头向后进行搜索，而lastIndexOf()与之相反。123let str = "hello world";console.log(str.indexOf('o')); // 4console.log(str.lastIndexOf('o')); // 7 这两个方法都可以接受第二个参数，指定搜索的起始位置。123let str = "hello world";console.log(str.indexOf('o', 6)); // 7console.log(str.lastIndexOf('o', 6)); // 4 搜索字符串中所有匹配的字符1234567let str = "hello world hello world hello world hello world";let arr = [];let pos = str.indexOf("o");while ( pos &gt; -1)&#123; arr.push(pos); pos = str.indexOf("o", pos+1);&#125; trim()这个方法会创建一个字符串的副本，删除前置及后缀的空格，返回结果，不会修改原始字符串。12let str = " hello world ";console.log(str.trim()); // "hello world" toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()常用的是toLowerCase()和toUpperCase(),toLocaleLowerCase()和toLocaleUpperCase()是针对特定的地区实现的。toUpperCase()小写转大写，toLowerCase()大写转小写。12345let str = "HELLO WORLD";console.log(str.toLowerCase()); // "hello wprld"let str = "hello wprld";console.log(str.toLowerCase()); // "HELLO WORLD" match()在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同，match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。1234let text = "cat, bat, sat, fat";let pattern = /.at/;let matchs = text.match(pattern);console.log(matchs) // ["cat", index: 0, input: "cat, bat, sat, fat"] search()这个方法唯一参数与match()参数相同，search()方法返回字符串第一个匹配项的索引，如果没有找到匹配项，则返回-1。123let text = "cat, bat, sat, fat";var pos = text.search(/at/);console.log(pos) // 1 replace()这个方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串，第二个参数可以是一个字符串或者一个函数。如果第一个参数是一个字符串，就只会替换第一个字符串，如果要替换所有的字符串，就必须要用正则表达式，全局(g)替换。1234567let text = "cat, bat, sat, fat";var result = text.replace("at", "fu");console.log(result); // "cfu, bat, sat, fat"let text = "cat, bat, sat, fat";var result = text.replace(/at/g, "fu");console.log(result); // "cfu, bfu, sfu, ffu" replace()的第二个方法可以是一个函数，在只有一个匹配项的情况下，会向这个函数传递三个参数：模式的匹配项，模式的匹配项在字符串中的位置和原始字符串。1234567891011121314let text = "&lt;p class=\"active\"&gt;Hello world&lt;/p&gt;";let result = text.replace(/[&lt;&gt;"&amp;]/g, function (match, pos, oldText) &#123; switch (match) &#123; case "&lt;" : return "&amp;lt;"; case "&gt;" : return "&amp;gt;"; case "&amp;" : return "&amp;amp;"; case "\"" : return "&amp;quot;"; &#125;&#125;);console.log(result) // "&amp;lt;p class=&amp;quot;active&amp;quot;&amp;gt;Hello world&amp;lt;/p&amp;gt;" split()这个方法可以基于指定的分隔符把一个字符串分割成多个子字符串，并将结果放在一个数组里面。分隔符可以是字符串，也可以是RegExp对象。split()方法可以接受可选的第二个参数，用于指定数组的大小。123let color = "red, yellow, green, pink";let color1 = color.split(","); // ["red", " yellow", " green", " pink"]let color2 = color.split(",", 2); // ["red", " yellow"] localeCompare()这个方法用于比较两个字符串，并返回下列结果之一: 如果字符串在字母表中位置在参数之前，则返回一个负数 字符串等于参数，返回0 如果字符串在字母表中位置在参数之后，返回一个正数 1234let str = "yellow";console.log(str.localeCompare("black")); // 1console.log(str.localeCompare("yellow")); // 0console.log(str.localeCompare("zoom")); // -1 注意:localeCompare()返回的数值取决于实现，不一定是1， -1， 0。 String.fromCharCode()这个方法是接收一个或多个字符编码，然后转换成字符串。1console.log(String.fromCharCode(104, 101, 108, 108, 111)); // hello ES6字符串的扩展javascript允许采用\uxxxx表示一个字符，但是只限于码点在\u0000~\uFFFF之间，超出这个范围的字符就必须用双字节表示。12console.log("\uD842\uDFB7"); // "𠮷"console.log("\u20BB7"); // " 7" 但是ES6只要将码点放入大括号中， 就能正确解读。1console.log("\u&#123;20BB7&#125;"); // "𠮷" codePointAt()codePointAt()方法能够正确处理四个字节的字符（Unicode码点大于0xFFFF的字符），返回一个字符的码点（十进制）。1234let str = '𠮷a';console.log(str.codePointAt(0).toString(16)); // "20bb7"console.log(str.codePointAt(1)); // "dfb7"console.log(str.codePointAt(2)); // "61" 可以看出codePointAt()的参数任然是不对的，要取到a必须的传入2才能取到，要解决这种问题可以用for...of循环实现，因为它会正确识别32位的UTF-16字符。1234let str = '𠮷a';for(let c of str)&#123; console.log(c.codePointAt(0).toString(16)); //"20bb7" "61"&#125; codePointAt()是判断一个字符是由两字节组成还是四字节组成最简单的办法。12345function isBit(value)&#123; return value.codePointAt(0) &gt; 0xFFFF;&#125;console.log(isBit("𠮷")); // trueconsole.log(isBit("a")); // false String.fromCodePoint()用于从码点返回对应字符，能够识别Unicode编号大于0xFFFF的字符。1String.fromCodePoint(0x20BB7) // "𠮷" ###字符串的遍历接口ES6新增字符串遍历接口，字符串可以用for...of循环遍历。1234let str = "hello";for(let s of str)&#123; console.log(s) // "h" "e" "l" "l" "o"&#125; 这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。12345678let str = "𠮷";for(let i = 0; i &lt; str.length; i++)&#123; console.log(str[i]) // � � (打印出来是这种无法识别的符号)&#125;for(let s of str)&#123; console.log(s) // "𠮷"&#125; includes()、startsWith()、endsWith() includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在源字符串头部 endsWith()：返回布尔值，表示参数字符串是否在源字符串尾部1234let str = "hello world!";console.log(str.includes("hello")); // trueconsole.log(str.startsWith("hello")); // trueconsole.log(str.endsWith("!")); // true 这三个方法都可以接受第二个参数，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。1234 let str = "hello world!";console.log(str.includes("world", 6))console.log(str.startsWith("world", 6 ))console.log(str.endsWith("hello", 5)) repeat()这个方法接收一个参数，表示要将原字符重复的次数。123let str = "abc";console.log( str.repeat(3)) // "abcabcabc"console.log( str.repeat(0)) // "" 如果参数不是正整数，则有下面几种情况： 如果参数是小数，会被取整 如果是负数或者是Infinity，会报错 如果是0~-1之间的小数，则为0 如果是NaN，则为0 如果是字符串，则会先转换成数字 padStart()和padEnd()字符串自动补全功能，如果字符串不够长度，会在头部或者尾部补全。这两个方法都可接收两个参数，第一个参数指定字符串的最小长度，第二个参数则是用来补全的字符串。12345console.log( 'x'.padStart(5, 'ab')); // "ababx"console.log( 'x'.padStart(4, 'ab')) // "abax"console.log( 'x'.padEnd(5, 'ab')); // "xabab"console.log( 'x'.padEnd(4, 'ab')); // "xaba" 当原字符串的长度大于指定的最小长度的时候，返回原字符串本身。1console.log( 'xxxxxxx'.padStart(5, 'ab')); // "xxxxxxx" 如果用来补全的字符串与原字符串长度的和大于指定的最小长度的时候，则会截取超出指定的最小长度的字符。1console.log( 'xxx'.padStart(10, '0123456789')); // "0123456xxx" 如果省略第二个参数，默认使用空格补全长度。12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。1'1'.padStart(10, '0') // "0000000001" 另一个用途是提示字符串格式。12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。123456789// 普通字符串`hello world!`;//多行字符串`How are youI'm fine`//字符串中嵌入变量let name="Tom";let age = 20;`my name is $&#123;name&#125;, I'm $&#123;age&#125; years old`; 模板中使用多行字符串，空格和缩进会保留在输出之中。1234567 let str = ` &lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;ul&gt;`;console.log(str) 效果图如下 模板字符串中嵌入变量，需要将变量名写在${}中。大括号内可以放任意的JavaScript表达式1234567891011let x = 1, y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;` // "1 + 2 = 3"let obj = &#123;x : 1, y : 2&#125;;`$&#123;obj.x&#125; + $&#123;obj.y&#125; = $&#123;obj.x + obj.y&#125;` // "1 + 2 = 3"function fn()&#123; return "hello world";&#125;`Hi, $&#123;fn()&#125;` // "Hi, hello world" 模板字符串中的变量没有声明，就会报错。1`hello, $&#123;text&#125;` // Uncaught ReferenceError: text is not defined 模板字符串的大括号内部是一个字符串，将会原样输出。1`hello, $&#123;'world'&#125;` // "hello, world" 标签模板模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。如果模板字符串里面有变量，就会将模板字符串先处理成多个参数，再调用函数。123456789let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;function tag(arr, value1, value2)&#123; console.log(arr); // ["Hello ", " world ", "", raw: Array(3)] console.log(value1); // 15 console.log(value2); // 50&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分。其他参数，都是模板字符串各个变量被替换后的值。 String.raw()String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。1console.log(String.raw`Hi\n$&#123;2+3&#125;!` === "Hi\\n5!") // true 如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。1console.log(String.raw`Hi\\n$&#123;2+3&#125;!`) // "Hi\\n5!" String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记之变量的解构赋值]]></title>
    <url>%2F2017%2F05%2F16%2F2017-05-16-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[数组的解构赋值 基本用法 ES6运行按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructuring)。 假设我们有一个变量arr，其值为[1, 2, 3]，我们想给数组的每个元素分别声明一个变量，在ES5中的做法就是单独取出来赋值。1234let arr = [1, 2, 3];let el1 = arr[0], el2 = arr[1], el3 = arr[2]; 现在ES6允许我们在左边使用表达式来达到和上面代码一样的效果。1let [el1, el2, el3] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。这种写法属于“模式匹配”，只要等号两边模式相同，左边的变量就会被赋予对应的值。同样的，数组还可以进行嵌套。1234let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3 如果解构不成功，变量的值就被赋予undefined，就是等号左边模式匹配不到等号右边数组的值。12345let [a] = [];a // undefinedlet [a, b] = [1];a // 1b // undefined 如果是不完全解构，就是等号左边的模式，只匹配一部分等号右边数组的值，解构依然可以成功。123456let [a, b, c] = [1, 2]a // 1b // 2let [a, [b, c]] = [1, [2]]a // 1b // 2 如果等号右边不是数组，就会报错123456let [a] = 1;let [a] = true;let [a] = NaN;let [a] = undefined;let [a] = null;let [a] = &#123;&#125;; 默认值解构赋值允许指定默认值。12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a'] //x = 'a', y = 'b'let [x, y = 'b'] = ['a', undefined]; //x = 'a', y = 'b' ES6使用全等运算符判断一个位置是否有值，所以一个数组成员不严格等于undefined，默认值是不会生效的。12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 如果默认值是表达式，那么这表达式则是惰性求值。用到的时候才会求值。1234let [x = f()] = [1];function f()&#123; alert(1)&#125; 上面代码因为x能取到值，所以函数不会执行，只有当等号右边数值的值为undefined时，函数才会执行。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。12345let [x = 1, y = x] = [2];x // 2y // 2let [x = y, y = 1] = []; // ReferenceError 上面报错是因为x用y作为默认值的时候，y还没有声明。 对象的解构赋值基本用法对象的解构与数组有一个很重要的不同，数组的元素是按次序排列的，变量的取值由位置决定，而对象的属性是没有次序的，变量必须要与属性同名才能取到值。123456let &#123;bar, foo&#125; = &#123;foo: "aa", bar: "bb"&#125;;foo // aabar // bblet &#123;baz&#125; = &#123;foo: "aa", bar: "bb"&#125;;baz // undefined 如果变量名与属性名不一致，必须写成下面的形式。123456let obj = &#123;first: 'hello', last: 'world'&#125;;let &#123;first: f, last: l&#125; = obj;f // hellol // worldfirst // ReferenceErrorlast // ReferenceError 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。first是匹配的模式，f才是变量。 用let或者const声明过的变量再通过这种方式重新声明会报错。12let a;let &#123;a, b&#125; = &#123;a: 1, b : 2&#125; // ReferenceError 对象解构同样可以用于嵌套。123456789let obj = &#123; a: [ 'hello', &#123;y: 'world'&#125; ]&#125;;let &#123;a:[x, &#123;y&#125;]&#125; = obj;x // helloy // world 对象解构也可以指定默认值。默认值生效的条件是对象的属性值严格等于undefined。12345678910111213let &#123;x = 1&#125; = &#123;&#125;;x // 1let &#123;x = 1&#125; = &#123;x: 3&#125;;x // 3let &#123;x:y = 1&#125; = &#123;&#125;;y // 1let &#123;x:y = 1&#125; = &#123;x:3&#125;;y // 3let &#123;x = 1&#125; = &#123;x: undefined&#125;;x // undefinedlet &#123;x = 1&#125; = &#123;x: null&#125;;x // null 解构失败，变量的值等于undefined。12let &#123;baz&#125; = &#123;foo: "aa", bar: "bb"&#125;;baz // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。12let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;;bar // ReferenceError 因为等号左边的foo属性在等号右边不存在，所以为undefined，而bar是foo下面的一个子属性undefined.bar肯定就会报错。 如果要将一个已经声明的变量用于解构赋值，需要小心。123let x;&#123;x&#125; = &#123;x: 1&#125;;x // Unexpected token = 上面代码报错是因为JavaScript引擎将{x}解析成一个代码块，所以导致错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。123let x;(&#123;x&#125; = &#123;x: 1&#125;);x // 1 将代码放在一个圆括号里面就可以正确执行。 对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量。1let &#123;log, sin, cos&#125; = Math 字符串的解构赋值基本用法字符串也可以解构赋值，被转化成一个类数组的对象。123456let [a, b, c, d, e] = "hello";a // hb // ec // ld // le // o 每个类数组的对象都有个length属性，还可以对这个属性进行解构赋值。12let &#123;length: len&#125; = "hello";len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 函数参数的解构赋值函数参数也可以使用解构赋值。1234function fn([a, b])&#123; return a + b;&#125;fn([1, 2]) // 3 函数被传入参数的时候，数组参数就被解构成了x和y。 函数参数的解构也可以使用默认值。1234567function fn(&#123;x = 0, y = 0&#125; = &#123;&#125;)&#123; return [x, y]&#125;fn(&#123;x: 3, y:5&#125;) // [3, 5]fn(&#123;x: 3&#125;) // [3, 0]fn(&#123;&#125;) // [0, 0]fn() // [0, 0] 而下面的代码会得到不一样的结果。12345678function fn(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;fn(&#123;x: 3, y: 8&#125;); // [3, 8]fn(&#123;x: 3&#125;); // [3, undefined]fn(&#123;&#125;); // [undefined, undefined]fn(); // [0, 0] 上面代码是为函数fn的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 不能使用圆括号的情况 变量声明语句不能带有圆括号，包括函数的参数。123456let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;function f([(z)]) &#123; return z; &#125; 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。123(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 可以使用圆括号的情况赋值语句的非模式部分，可以使用圆括号。123[(b)] = [3]; (&#123; p: (d) &#125; = &#123;&#125;); [(parseInt.prop)] = [3]; 用途交换变量的值123let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值1234function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example(); 函数参数的定义1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css之position属性]]></title>
    <url>%2F2017%2F05%2F15%2F2017-05-15-css%E4%B9%8Bposition%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[简介 position CSS属性选择用于定位元素的替代规则，被设计为对脚本动画效果有用。 语法1234567891011/* 关键字 值 */position: static;position: relative;position: absolute;position: fixed;position: sticky; //实验性API/* 全局值 */position: inherit;position: initial;position: unset; static 元素默认定位属性默认值。没有定位，元素出现在正常的文档流中，忽略top, right, bottom, left, z-index声明。 relative 相对定位相对自己文档流中的原始位置进行定位，不会脱离文档流。上图给test4加上了position:relative效果，代码如下1position: relative; top:10px; left:-20px 可以看出test4并没有对周围的元素造成影响， 它还是存在于正常的文档流中。position:relative对 table-*-group, table-row, table-column, table-cell, table-caption 元素没有效果。 absolute 绝对定位 相对于static定位以外的第一个父元素进行定位， 脱离文档流上图给test4加上了position:absolute效果明显可以看到test4从正常的文档流中脱离了出来， test5填补了test4原本的位置。 绝对定位元素可以设置外边距，且不会与其他边距合并CSS代码 12345678910111213141516171819202122body&#123; margin: 0; padding: 0;&#125;.box &#123; position: relative; width: 500px; height: 200px; background: lightseagreen; margin: 30px&#125;.box1 &#123; position: absolute; top: 0; left: 0; margin: 20px; width: 100px; height: 50px; background: red&#125;eight: 50px;background: red&#125; HTML代码123&lt;div class="box"&gt; &lt;div class="box1"&gt;absolute定位元素&lt;/div&gt;&lt;/div&gt; 效果图 stickyposition:sticky是一个新的CSS3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置CSS代码12345678910111213141516171819202122.container &#123; background: #eee; width: 600px; height: 1000px; margin: 0 auto;&#125;.sticky-box &#123; position: -webkit-sticky; position: sticky; height: 60px; margin-bottom: 30px; background: #ff7300; top: 0px;&#125;div &#123; font-size: 30px; text-align: center; color: #fff; line-height: 60px;&#125; HTML代码123456&lt;div class="container"&gt; &lt;div class="sticky-box"&gt;内容1&lt;/div&gt; &lt;div class="sticky-box"&gt;内容2&lt;/div&gt; &lt;div class="sticky-box"&gt;内容3&lt;/div&gt; &lt;div class="sticky-box"&gt;内容4&lt;/div&gt;&lt;/div&gt; 效果图因为设定的阈值是 top:0 ，这个值表示当元素距离页面视口（Viewport，也就是fixed定位的参照）顶部距离大于 0px 时，元素以 relative 定位表现，而当元素距离页面视口小于 0px 时，元素表现为 fixed 定位，也就会固定在顶部。浏览器支持情况IOS 家族（SAFARI &amp;&amp; IOS SAFARI）和 Firefox 很早开始就支持 position:sticky 了。而 Chrome53~55 则需要启用实验性网络平台功能才行。其中 webkit 内核的要添加上私有前缀 -webkit-。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记之let和const命令]]></title>
    <url>%2F2017%2F05%2F15%2F2017-05-15-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Blet%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近一直在看阮大神的ECMAScript 6入门这本书，边学边记，加深印象。 let和const命令ES5只有两种声明变量的方法：var命令和function命令。而ES6新增了四种声明变量的方法:let、const、import和class，所以ES6有6种声明变量的方法。 let命令 基本用法let用来声明变量， 用法类似于var，但是只在let命令所在的代码块有效。1234for(var i = 0; i &lt; 10; i++)&#123;&#125;;console.log(i) // 10for(let i = 0; i &lt; 10; i++)&#123;&#125;console.log(i) // 报错 不存在变量提升var声明的变量的能在变量声明之前访问，值为undefined，因为在脚本运行之前，变量foo已经存在，但是没有值，所以会输出undefined。12console.log(a); // undefinedvar a = 'hello'; 如果用let来声明的变量在没有声明之前就进行访问的话，会抛出异常。12console.log(a); // Uncaught ReferenceError: a is not definedvar let = 'hello'; 暂时性死区在代码块内，使用let命令声明变量之前，该变量都是不可用的。12345678if(true)&#123; tmp = "hello"; console.log(tmp); // ReferenceError let tmp; console.log(tmp); // undefined tmp = "abc"; console.log(tmp)&#125; 上图说明在第四行用let声明变量tmp之前，都属于tmp的死区。注意如果在let声明变量之前用typeof检测数据类型的话，会抛出异常。12console.log(typeof x); // ReferenceErrorlet x = 1; 不允许重复声明let不允许在相同的作用域内重复声明同一个变量123function fn(arg)&#123; let arg;&#125; 上面代码会抛出异常，改成下面这样就不会了。12345function fn(arg)&#123; &#123; let arg; &#125;&#125; 块级作用域ES5只有全局作用域和函数作用域,而ES6新增了块级作用域。 ES6允许块级作用于任意嵌套1&#123;&#123;&#123;&#123;&#123;let a = 0&#125;&#125;&#125;&#125;&#125; 上图使用了5五层块级作用域。 外层作用域无法读取内层作用域的变量 1234&#123;&#123;&#123;&#123; &#123;let a = 0&#125; console.log(a); // ReferenceError&#125;&#125;&#125;&#125; 不同作用域可以定义同名变量 12345678&#123;&#123;&#123;&#123; let a = 1; &#123; let a = 0; console.log(a) // 0 &#125; console.log(a) // 1&#125;&#125;&#125;&#125; const命令基本用法const声明一个只读的常量，一旦声明，值就不可以改变。123const PI = 3.1415;PI = 3.14;console.log(PI) // Assignment to constant variable const一旦声明变量，必须立即初始化。123const foo ;foo = "hello";console.log(foo); // Missing initializer in const declaration const和let相同，声明的变量只有在其所在的块级作用于有效，变量不会提升，同时也存在“暂时性死区”。 本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。 意思就是说用const声明的基本数据的变量是不可以改变值，而引用数据类型（主要是对象和数值）,const只能保证指针是固定的，而指向的数据是可以进行变化的。12345const foo = &#123;&#125;;foo.name = "Tom";console.log(foo); // &#123;name: "Tom"&#125;foo = &#123;&#125;; // 当把foo指向另一个对象的时候就会报错 12345const arr = [];arr.push("hello");console.log(arr); ["hello"]arr = []; // Assignment to constant variable. 如果要冻结一个对象，应该使用Object.freeze方法。123const foo = Object.freeze(&#123;&#125;);foo.name = "Tom";console.log(foo) // &#123;&#125; 常规模式下，添加属性不起作用1234"use strict";const foo = Object.freeze(&#123;&#125;);foo.name = "Tom";console.log(foo) // Cannot add property name, object is not extensible 在严格模式下会抛出异常 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数 - . -暂时没有理解到这个方法，先直接拷过来用。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之float属性]]></title>
    <url>%2F2017%2F05%2F12%2F2017-05-12-CSS%E4%B9%8Bfloat%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[概述 CSS的float属性可以使一个元素脱离正常的文档流，然后被安放在它所在容器的左端或者右端，并且其他的文本和行内元素环绕它。 float属性介绍 left: 元素向左浮动 float: 元素向右浮动 none: 默认值 inherit： 默认值 由于float使用了块布局， 所以它会改变display的计算值 指定值 计算值 inline block inline-block block inline-table table table-row block table-row-group block table-column block tabale-column-group block tabel-cell block table-caption block table-header-group block table-footer-group block flex flex,float对这样的元素不起作用 inline-flex inline-flex, float对这样的元素不起作用 浮动元素是如何定位的当一个元素浮动后，它会被移除正常的文档流，然后向左或是向右平移，一直平移到碰到了所处容器的边缘或者碰到另外一个浮动元素。不管一个元素是行内元素还是块级元素，如果被设置了浮动，那浮动元素会生成一个块级框，可以设置它的width和height 浮动元素的一些特性 浮动元素浮动的时候， margin不会超过包含块的padding CSS代码12.box&#123; width: 200px; height: 500px; background: lightseagreen; padding: 10px&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin: 20px&#125; HTML代码123&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt;&lt;/div&gt; 效果图 如果有多个浮动元素，后面浮动元素的margin不会超过前面浮动元素的margin, 多个浮动元素，浮动元素会按顺序排列而不发生重叠现象 CSS代码12.box&#123; width: 400px; height: 500px; background: lightseagreen; padding: 10px&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin: 10px; float: left&#125; HTML代码123456&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt;&lt;/div&gt; 效果图 如果两个元素一个左浮动，一个右浮动，左浮动元素的marginRinght和右浮动的marginLeft不会重叠 CSS代码123.box&#123; width: 219px; height: 500px; background: lightseagreen;&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin-right: 10px; float: left&#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left&#125; HTML代码1234&lt;div class="box"&gt; &lt;div class="box1"&gt;左浮动元素&lt;/div&gt; &lt;div class="box2"&gt;右浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 浮动元素重叠问题 块级元素与浮动元素发生重叠，边框和背景会显示在浮动元素之下，内容会显示在浮动元素之上CSS123.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;.box1&#123;background: blue; border: 1px solid #000&#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left; margin-top: -10px&#125; HTML1234&lt;div class="box"&gt; &lt;div class="box1"&gt;我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字&lt;/div&gt; &lt;div class="box2"&gt;右浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 行内元素与浮动元素发生重叠，其边框，背景和内容都会显示在浮动元素之上CSS123.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;span&#123; background: palevioletred; &#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left; margin-top: -10px&#125; HTML1234&lt;div class="box"&gt; &lt;span&gt;我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字&lt;/span&gt; &lt;div class="box2"&gt;浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 清除浮动的方法 增加额外的div1&lt;div style="clear: both"&gt;&lt;/div&gt; 优点：简单粗暴缺点: 增加额外的无意义的标签，不利于语义化 父级元素增加overflow: hidden(关键在于触发了BFC)1.clearfix&#123; overflow:hidden&#125; 优点：代码量少，没有额外的标签缺点： 如果子元素超出父元素的范围，会造成超出的部分被隐藏 after伪类12clearfix&#123;zoom:1&#125;clearfix:after&#123;display:block; content:""; clear:both; visibility: hidden;&#125; 优点：没有额外标签，综合起来算比较好的方法缺点：稍显复杂推荐使用这种方法 float应用场景float最初应用就是文字环绕效果CSS代码12.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;img&#123; float: left&#125; HTML代码1234&lt;div class="box"&gt; &lt;img src="demo6.png" alt=""&gt; 文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕&lt;/div&gt; 效果图 还可用于横向菜单排列，但是更推荐使用display:inline-block,除了文字环绕效果，在其他几乎所有的应用场景中，float能实现的效果，display:inline-block都能实现。推荐一篇张鑫旭大神的关于float的文章,写的特别有意思。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的数组去重]]></title>
    <url>%2F2017%2F05%2F07%2F2017-05-07-js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[判断浏览器是否支持indexOf方法123456789101112131415161718//判断是否支持indexOf方法if(!Array.prototype.indexOf)&#123; Array.prototype.indexOf = function (item)&#123; var result = -1; //数组为空的时候返回-1 if (this.length == 0) &#123; return result; &#125;; for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] === item) &#123; //当当前项的值与参数值相等的时候，结束循环 result = i; break; &#125; &#125;; return result; &#125;;&#125; 遍历数组法：新建一新数组，遍历数组，值不在新数组中就加入新数组1234567891011function unique(array)&#123; //新建数组 var newArr = []; for(var i = 0; i &lt; arr.length; i++)&#123; //值不在新数组中就添加到新数组 if(newArr.indexOf(array[i]) == -1)&#123; newArr.push(array[i]); &#125; &#125;; return newArr &#125; 对象键值法：该方法执行速度比其他任何方法都快，就是占用内存大一些。新建一JS对象和数组，遍历传入数组时，判断值是否为JS对象的值，不是的话给对象新增该键并放入新数组。注意点，判断是否为JS对象键时，会自动对传入的键执行”toString()”,不同的键可能会被误认为一样。12345678910111213141516171819202122function unique(array)&#123; var obj = &#123;&#125;, newArr = [], len = array.length, val, type; for (var i = 0; i &lt; len; i++) &#123; val = array[i]; //获取值的数据类型 type = typeof val; //判断值是否存在 if (!obj[val]) &#123; //把type以数组的形式存入便于用indexOf对比 obj[val] = [type]; newArr.push(val); &#125; else if(obj[val].indexOf(type) &lt; 0) &#123; //值存在的情况下判断是否是相同的数据类型 obj[val].push(type); newArr.push(val); &#125; &#125; return newArr; &#125; 数组下标判断法：当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的。12345678910function unique(array)&#123; var newArr = [array[0]]; for (var i = 1; i &lt; array.length; i++) &#123; //判断第i项出现位置下标 if (array.indexOf(array[i]) == i) &#123; newArr.push(array[i]) &#125;; &#125; return newArr; &#125; 排序后相邻去除法：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。123456789101112function unique(array)&#123; //先排序 array.sort(); var newArr = [array[0]]; for (var i =1; i &lt; array.length; i++) &#123; //newArr最后一项就是array[i]的前一项 if(array[i] !== newArr[newArr.length - 1])&#123; newArr.push(array[i]); &#125;; &#125;; return newArr; &#125; 获取没重复的最右一值放入新数组。检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断1234567891011121314function unique(array)&#123; var r = []; for(var i = 0, len = array.length; i &lt; len; i++)&#123; for(var j = i + 1; j &lt; len; j++)&#123; if(array[i] === array[j])&#123; //当两个值相同的时候,i在内循环自增1，相当于跳出本次循环，执行下一次，当前值就不能添加到新数组 j = ++i; &#125;; &#125; r.push(array[i]); &#125;; return r; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>