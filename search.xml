<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript高级程序设计-基础概念]]></title>
    <url>%2F2017%2F06%2F02%2F2017-06-02-Javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[语法区分大小写ECMAScript是区分大小写的，包括变量，函数名和操作符。 标识符标识符指的是函数，变量，属性的名字。必须要遵循以下规则： 第一个字符必须是字母、下划线、或者美元符号 其他字符可以是字符、下划线、美元符号或者数字 标识符推荐采用驼峰大小写格式。 注释单行注释1// 单行注释 块级注释123/* * 块级注释 */ 严格模式除了正常运行模式，ECMAScript5添加了第二种正常运行模式：“严格模式”。设立严格模式的目的： 消除Javascript语法一些不合理、不严谨的地方，减少一些怪异的行为 消除代码运行的一些不安全之处，保证代码运行的安全 提高编译器效率，增加运行速度 为未来的新版本Javascript做好铺垫 严格模式有两种调用方法： 整个脚本启用严格模式 1"use strict"; 函数内部启用严格模式 123(function()&#123; "use strict";&#125;()) 不管在什么情况下启用严格模式都必须放在第一行，否则不会生效。 语句ECMAScript中的语句以分号结尾，虽然可以不写，但是不推荐。分号加与不加完全取决于个人习惯，但为了代码稳定（解析出错）还是建议使用分号断句。Javascript自动加分号规则： 当有换行符（包括含有换行符的多行注释），并且下一个token没法跟前面的语法匹配时，会自动补分号。 当有}时，如果缺少分号，会补分号。 当程序源代码结束时，如果缺少分号，会补分号。结论： 在return、break、continue、后自增、后自减五种语句中，换行符可以完全替代分号的作用。 var、if、do、while、for、continue、break、return、with、switch、throw、try、 debugger几种关键字开头的语句，以及空语句，上一行加不加分号影响不大。 凡表达式语句和函数表达式语句，后面不加分号非常危险，情况极其复杂。 凡(和[开头的语句，前面不加分号极度危险。 变量ECMAScript变量是松散类型的，可以用来保存任何类型的数据。声明变量要使用var操作符后跟变量名。1var message; 上面代码是未初始化变量，会保存特殊值“undefined”。也可以在声明的时候直接初始化变量。1var message = "hi"; 使用var声明的变量会成为定义该变量作用域的局部变量。在函数中通过var声明的变量会在函数退出后销毁。12345function test()&#123; var a = 1;&#125;;test();console.log(a) // Uncaught ReferenceError: a is not defined 上面代码如果省略var就会创建一个全局变量，在全局作用于内任何地方都能访问到。12345function test()&#123; a = 1;&#125;;test();console.log(a) // 1 一条语句可以定义多个变量，通过逗号分割开。123var a = 1, b = 2, c = "hello"; 严格模式下，定义名为eval和arguments的变量会报错。12"use strict";var eval = "hello" // Uncaught SyntaxError: Unexpected eval or arguments in strict mode 数据类型ECMAScript有5种基本数据类型：Undefined、Null、Boolean、Number、String和一种引用数据类型：Object。 typeof操作符用来检测变量的数据类型12345678910111213141516var a;var b = 'hi';var c = 1;var d = true;var e = &#123;&#125;;var f = function()&#123;&#125;;var g = new RegExp;var h = null;console.log(typeof a); // undefinedconsole.log(typeof b); // stringconsole.log(typeof c); // numberconsole.log(typeof d); // booleanconsole.log(typeof e); // objectconsole.log(typeof f); // functionconsole.log(typeof g); // objectconsole.log(typeof h); // object typeof null会返回object,因为null被认为是一个空的对象。 Undefined类型使用var声明变量时未进行初始化，这个变量的值就是undefined。主要用来区分空对象指针与未经初始化的变量。未初始化的变量和未定义的变量是不一样的，直接使用未定义的变量会报错。123var a;console.log(a); // undefinedconsole.log(b); // Uncaught ReferenceError: b is not defined Null类型null表示一个对象的空指针，如果定义的变量将来用于保存对象，最好将该变量初始化为null。undefined的值派生自null，所以相等测试返回true。1console.log(undefined == null); // true Boolean类型Boolean类型有两个字面值：true和false。ECMAScript所有类型的值都能通过Boolean()转型函数转换为Boolean值。转换规则如下： 数据类型 转化为true的值 转化为false的值 Boolean true false String 非空字符串 “”（空字符串） Number 非零数字 0和NaN Object 任何对象 null Undefined 不能转化为true Undefined Number类型Number类型使用IEEE754来表示整数和浮点数。整数可以通过十进制、八进制、十六进制来表示。八进制第一位必须是0，后面是八进制数字序列（0~7），如果数值超出了范围，则省略前导的0，后面数字以十进制解析。八进制在严格模式下无效，会抛出异常。12console.log(070) // 56console.log(079); // 79 十六进制前两位必须是0x开头，后面是十六进制数字序列（0~7及A~F）。1console.log(0xA); // 10 浮点数值浮点数值需要的内存空间是整数的两倍，所以ECMAScript会将小数点后没有数字的（如1.）和本身就表示一个整数的（如1.0）的浮点数值转化为整数。可以用科学计数法表示极大或者极小的浮点数值。默认情况下ECMAScript会将小数点后带有6个零以上的浮点数在转化为e表示法。如：123console.log(3.12e7) // 31200000console.log(3.12e-6) // 0.00000312console.log(3.12e-7) // 3.12e-7 浮点数值在任何机器的上都不能直接判断相等，最好通过精度来判断。 数值范围ECMAScripot的数值范围在Number.MIN_VALUE和Number.MAX_VALUE之间，如果超出这个范围， 将会被转换成Infinity值，该值不能用于计算，要想确定一个值是否是有穷的，通过isFinite()判断，函数参数位于最大值与最小值之间返回true。123console.log(Number.MIN_VALUE); // 5e-324console.log(Number.MAX_VALUE); // 1.7976931348623157e+308console.log(isFinite(Number.MIN_VALUE + Number.MIN_VALUE)); // false NaN这个数值表示一个本来要返回数值的操作数未返回数值的情况。 任何涉及到NaN的操作都会返回NaN NaN与任何值都不相等，包括自身1console.log(NaN === NaN) // false ECMAScript定义了isNaN()函数，该函数接收一个参数，会尝试将这个参数转换成数值，转换成功返回false, 失败返回true。12345console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // falseconsole.log(isNaN('10')); // falseconsole.log(isNaN('color')); // trueconsole.log(isNaN(true)); // false 数值转换有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。Number()可用于任何数据类型，另两个则专门用于把字符串转换成数值。 Number()转换规则如下： 如果是Boolean值，则把true和false转换成1和0 如果是数值，返回本身 如果是Null， 返回0 如果是undefined，返回NaN 如果是字符串，则有一下几种情况 如果字符串中只包含数字，则转换成对应十进制 1234console.log(Number("10")); // 10console.log(Number("+10")); //10console.log(Number("-10")); // -10console.log(Number("010")); // 10 如果字符串中包含有效的浮点格式，则转换成对应的浮点数值。 1234console.log(Number("10.3")); // 10.3console.log(Number("+10.3")); // 10.3console.log(Number("-10.3")); //-10.3console.log(Number("010.3")); // 10.3 如果字符串中包含有效的十六进制格式，则转换成相同大小的十进制整数值。 1console.log(Number("0xF")); // 15 如果字符串为空，则转换为0 1console.log(Number(" ")); // 0 字符串中包含除上述格式之外的字符， 则转换为NaN 如果是对象， 则调用对象的valueOf()方法，然后按照前面规则转换，如果转换结果是NaN，则调用对象的toString()方法，再次依照前面规则转换。日期对象会转换成相应的毫秒数。 12let now = new Date();console.log(Number(now)); // 1495076392196 parseInt()函数在转换字符串时会忽略字符串前面的空格，直到找到第一个非空格字符串。如果第一个字符不是数字字符或者负号，就会返回NaN，如果第一个字符是数字字符，parseInt()会继续解析后面的字符，直到解析完所有字符或者遇到非数字字符。parseInt()解析空字符串会返回NaN。同样，parseInt()也能辨别各种整数格式。123456console.log(parseInt("")); // NaNconsole.log(parseInt("123abc")); // 123console.log(parseInt("abc123")); // NaNconsole.log(parseInt("10.2")); // 10console.log(parseInt("070")); // 70 (ECMAScript5已经不具备解析八进制的能力，所以认为前导的0无效)console.log(parseInt("0xFWQR")); // 15 parseInt()可以接受第二个参数来指定整数的格式。默认是转换成十进制。1234console.log(parseInt("10", 2)); // 2console.log(parseInt("10", 8)); // 8console.log(parseInt("10", 10)); // 10console.log(parseInt("10", 16)); // 16 parseFloat()函数与parseInt()类似，不同的是parseFloat()解析完成或者遇到第一个无效的浮点数字字符为止，但是第一个小数点是有效的。parseFloat()始终会忽略前导的零，十六进制的字符串始终会被转换成0，由于parseFloat()只解析十进制值，所以不能指定第二个参数，如果字符串包含的是一个可解析成整数的数值，parseFloat()会返回整数。123456console.log(parseFloat("123abc")); // 123console.log(parseFloat("0xF")); // 0console.log(parseFloat("10.5")); // 10.5console.log(parseFloat("10.5.5")); // 10.5console.log(parseFloat("010.5")); // 10.5console.log(parseFloat("10.0")); // 10 String类型String由零或者多个16为Unicode字符组成的字符序列，可以用双引号或者单引号表示。 字符串的特点字符串是不可变的，要改变某个变量保存的字符串首先要先销毁原来的字符串。然后用新值填充该变量。 转换为字符串可以通过toString()将Number、Boolean、Object和String类型的数据转换为字符串，该方法可以接收一个参数：输出数值的基数。在不知道值是不是Null或Undefined的情况下，可以通过String()方法进行转换。转换规则如下： 如果值有toString()方法，则直接调用该方法 如果值为null，返回null 如果值为undefined，返回undefined Object类型ECMAScript对象就是一组数据和功能的集合。可以通过new操作符后跟要创建的对象类型的名称来创建。创建Object类型的实例并为其添加属性和方法就可以创建自定义对象。123456var person = new Object();person.name = "Tom";person.sayName = function()&#123; alert(this.name);&#125;person.sayName(); // Tom Object类型是所有它的实例的基础，它所具有的所有属性和方法都能被实例所共享。Object每个实例都有一下属性和方法： constructor: 保存着用于创建当前对象的函数 12var obj = new Object();console.log(obj.constructor === Object) // true hasOwnProperty(): 检查给定属性是否存在当前实例中，如果存在于原型中返回true，实例本身属性返回false 123456function Person()&#123;&#125;;Person.prototype.name = "Tom";var person = new Person();person.age = 20;console.log(Person.hasOwnProperty("name")); // trueconsole.log(Person.hasOwnProperty("age")); // false isPrototypeOf(): 用于检查传入的对象是否是另一个对象的原型 12345function Foo()&#123;&#125;;function Bar()&#123;&#125;;Foo.prototype = new Bar();var f1 = new Foo();console.log(Bar.prototype.isPrototypeOf(f1)) // true propertyIsEnumerable(): 检查给定的属性能否通过for-in来枚举 这个属性必须属于实例的，并且不属于原型。 这个属性必须是可枚举的，也就是自定义的属性。 如果对象没有指定的属性，该方法返回false 12345678910function Person()&#123;&#125;;Person.prototype.name = 'Tom';var p1 = new Person();p1.age = 20;for(var attr in p1) &#123;console.log(attr) // age name&#125;console.log(p1.propertyIsEnumerable('age')) // trueconsole.log(p1.propertyIsEnumerable('name')); // falseconsole.log(p1.propertyIsEnumerable('toString')); //false toLocaleString(): 返回对象的字符串表示法，该字符串与执行环境的地区对应 toString(): 返回对象的字符串表示 valueOf(): 返回对象的字符串、数值和布尔值表示 操作符一元操作符只能操作一个值的操作符叫做一元操作符。分为递增和递减操作符，递增和递减操作符又有前置型和后置型两种。前置型：递增和递减操作在语句求值之前执行123456var num1 = 2, num2 = 10;var num3 = --num1 + num2;var num4 = num1 + num2;console.log(num3); // 11console.log(num4); // 11 后置型：递增和递减操作在语句求值之后执行123456var num1 = 2, num2 = 10;var num3 = num1-- + num2;var num4 = num1 + num2;console.log(num3); // 12console.log(num4); // 11 这四个操作符对任何值都适用，内部默认调用Number()进行转换。 一元加和减操作符一元加操作符以一个加号表示，放在数值前面。对数值不会产生任何影响。123var num = 20;num = +num;console.log(num) // 20 如果是非数值则内部调用Number()进行数据类型转化。 一元减操作符用于将一个数值转化为负数123var num = 20;num = -num;console.log(num) // -20 如果是非数值则先内部调用Number()进行数据类型转化，然后再变为负数。 位操作符ECMAScript中所有数值都以IEEE-754 64位格式存储，但位操作符不直接操作64位的值，而是将64位值转换为32位的整数，操作完成后再转换为64位。对于有符号的整数，前31位表示整数的值，第32位表示符号：0表示正数，1表示负数。表示符号的叫符号位。正数以纯二进制格式存储，31位中的每一位都表示2的幂，没有用到的位以0填充，忽略不计。二进制转化成十进制如下1210010 =&gt; (2⁴*1)+(2³*0)+(2²*0)+(2¹*1)+(2⁰*0) 16 + 0 + 0 + 2 + 0 = 18 负数是用二进制的补码进行存储。计算一个数值的二进制补码需要经过下面步骤： 求这个数值绝对值的二进制码 求二进制的反码，即0替换成1，1替换成0 得到二进制反码加1 求-18的二进制码步骤如下： 123456789(1)先取到18的二进制码0000 0000 0000 0000 0000 0000 0001 0010(2)取其反码1111 1111 1111 1111 1111 1111 1110 1101(3)反码加一1111 1111 1111 1111 1111 1111 1110 1101 1----------------------------------------1111 1111 1111 1111 1111 1111 1111 1110 按位非（~）执行按位非的结果返回数值的反码，按位非的本质是操作数的负值减1。123var num1 = 2;var num2 = ~num1;console.log(num2); // -3 浮点数取整12console.log(~~3.14); // 3console.log(~~-3.14); //-3 indexOf判断字符是否存在1234var str = "hello";if(~str.indexOf('e'))&#123; ...&#125; 按位与（&amp;）按位与的操作是将两个数值的每一位对齐，两个数的值为1时，才返回1，其他为零。1234567 var result = 3 &amp; 5; console.log(result) // 1 0011&amp; 0101------ 0001 可以用一个数和1进行按位&amp;操作来判断一个数是奇数还是偶数1234567function assert(n) &#123; if (n &amp; 1) &#123; console.log("奇数"); &#125; else &#123; console.log("偶数"); &#125;&#125; 因为奇数的最后一位肯定是1，而1只有最后一位为1，按位&amp;操作之后，结果肯定只有最后一位数为1。而偶数的二进制表示的最后一位数是0，和1进行按位&amp;操作，结果所有位数都为0。 按位或（|）只要两个数中有一个数为1，结果就为1，其他则为0。1234 0001| 0011------ 0011 可以用来对浮点数向下求整1var num = 1.1 | 0; // 1 按位异或（^）按位异或是两个数中只有一个1时返回1，其他情况返回0。1234 0001^ 0011------- 0010 可以用来调换两个数值的值。1234567var num1 = 1, num2 = 2;num1 ^= num2;num2 ^= num1;num1 ^= num2;console.log(num1); // 2console.log(num2); // 1 有符号左移（&lt;&lt;）有符号左移会将32位二进制数的所有位向左移动指定位数。如：12var num = 2; // 二进制10num = num &lt;&lt; 5; // 二进制1000000，十进制64 如果要求2的n次方，可以这样：1234function power(n) &#123; return 1 &lt;&lt; n;&#125;power(5); // 32 有符号右移（&gt;&gt;）有符号右移会将32位二进制数的所有位向右移动指定位数。如：12var num = 64; // 二进制1000000num = num &gt;&gt; 5; // 二进制10，十进制2 可以用来求一个数的二分之一1var num = 10 &gt;&gt; 1; // 5 无符号右移（&gt;&gt;&gt;）正数的无符号右移与有符号右移结果是一样的。负数的无符号右移会把符号位也一起移动，而且无符号右移会把负数的二进制码当成正数的二进制码：12var num = -64; // 11111111111111111111111111000000num = num &gt;&gt;&gt; 5; // 134217726 可以利用无符号右移来判断一个数的正负：123456function isPos(n) &#123;return (n === (n &gt;&gt;&gt; 0)) ? true : false; &#125;isPos(-1); // falseisPos(1); // true -1&gt;&gt;&gt;0虽然没有向右移动位数，但-1的二进制码已经变成了正数的二进制码,所以不会相等。 应该尽量少用位操作符进行运算，这会导致代码阅读困难。 布尔操作符布尔操作符一共有三个：非（!）、与（&amp;&amp;）、或（||）。 逻辑非（!）逻辑非会将操作数转化为布尔值，然后对其求反。转换规则与Boolean()函数类似。!!会将一个数转换为Boolean值。12345console.log(!!"hello"); // trueconsole.log(!!0); // falseconsole.log(!!NaN); // falseconsole.log(!!""); // falseconsole.log(!!10); // true 逻辑与（&amp;&amp;）逻辑与有两个操作数。只要其中有一个为false，则返回false。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值，遵循以下规则： 第一个操作数是对象，则返回第二个操作数 第二个操作数是对象，则在第一个操作数求值结果为true的情况下返回该对象 两个操作数都是对象，则返回第二个 如果有一个操作数为null,则返回null 如果有一个操作数为NaN,则返回NaN 如果有一个操作数为Undefined,则返回Undefined 逻辑与属于短路操作，第一个操作数为false，就不会对第二个操作数求值。 逻辑或（||）逻辑或有两个操作数。只要其中有一个为true，则返回true。 在有一个操作数不是布尔值的情况下，逻辑或操作不一定返回布尔值，遵循以下规则： 第一个操作数是对象，则返回第一个操作数 第一个操作数求值结果为false，则返回第二个操作数 两个操作数都是对象，则返回第一个 如果有一个操作数为null,则返回null 如果有一个操作数为NaN,则返回NaN 如果有一个操作数为Undefined,则返回Undefined 逻辑或也属于短路操作，第一个操作为true，就不会对第二个操作数求值。可以利用这一行为避免为变量赋null和undefined值。123var obj = null;var result = obj || &#123;&#125;;console.log(result); // object]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记之数值的扩展]]></title>
    <url>%2F2017%2F05%2F18%2F2017-05-18-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[ES5中的Number类型Number采用IEEE754格式来表示整数和浮点数。整数可以通过十进制、八进制、十六进制字面量来表示。 八进制字面量第一位必须是0，如果字面值中的数值超过范围，前导的零将会被省略，后面数值当作十进制解析。123console.log(070); // 56console.log(08); // 8console.log(089)； // 89 八进制字面量在严格模式下会报错 十六进制字面量前两位必须是0x,超出字面量会报错。12console.log(0xF); // 15console.log(0xG); // Uncaught SyntaxError: Invalid or unexpected token 在进行算术计算的时候，八进制和十六进制的数值最终都会转换成十进制。 浮点数值浮点数值需要的内存空间是保存整数值的两倍，如果小数点后面没有任何数值，或者浮点数本身就表示一个整数，那么都会转换为整数。12console.log(10.); // 10console.log(10.0); // 10 数值范围ECMAScripot的数值范围在Number.MIN_VALUE和Number.MAX_VALUE之间，如果超出这个范围， 将会被转换成Infinity值，该值不能用于计算，要想确定一个值是否是有穷的，通过isFinite()判断，函数参数位于最大值与最小值之间返回true。123console.log(Number.MIN_VALUE); // 5e-324console.log(Number.MAX_VALUE); // 1.7976931348623157e+308console.log(isFinite(Number.MIN_VALUE + Number.MIN_VALUE)); // false NaN这个数值表示一个本来要返回数值的操作数未返回数值的情况。 任何涉及到NaN的操作都会返回NaN NaN与任何值都不相等，包括自身1console.log(NaN === NaN) // false ECMAScript定义了isNaN()函数，该函数接收一个参数，会尝试将这个参数转换成数值，转换成功返回false, 失败返回true。12345console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // falseconsole.log(isNaN('10')); // falseconsole.log(isNaN('color')); // trueconsole.log(isNaN(true)); // false 数值转换有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。Number()可用于任何数据类型，另两个则专门用于把字符串转换成数值。 Number()转换规则如下： 如果是Boolean值，则把true和false转换成1和0 如果是数值，返回本身 如果是Null， 返回0 如果是undefined，返回NaN 如果是字符串，则有一下几种情况 如果字符串中只包含数字，则转换成对应十进制 1234console.log(Number("10")); // 10console.log(Number("+10")); //10console.log(Number("-10")); // -10console.log(Number("010")); // 10 如果字符串中包含有效的浮点格式，则转换成对应的浮点数值。 1234console.log(Number("10.3")); // 10.3console.log(Number("+10.3")); // 10.3console.log(Number("-10.3")); //-10.3console.log(Number("010.3")); // 10.3 如果字符串中包含有效的十六进制格式，则转换成相同大小的十进制整数值。 1console.log(Number("0xF")); // 15 如果字符串为空，则转换为0 1console.log(Number(" ")); // 0 字符串中包含除上述格式之外的字符， 则转换为NaN 如果是对象， 则调用对象的valueOf()方法，然后按照前面规则转换，如果转换结果是NaN，则调用对象的toString()方法，再次依照前面规则转换。日期对象会转换成相应的毫秒数。 12let now = new Date();console.log(Number(now)); // 1495076392196 parseInt()函数在转换字符串时会忽略字符串前面的空格，直到找到第一个非空格字符串。如果第一个字符不是数字字符或者负号，就会返回NaN，如果第一个字符是数字字符，parseInt()会继续解析后面的字符，直到解析完所有字符或者遇到非数字字符。parseInt()解析空字符串会返回NaN。同样，parseInt()也能辨别各种整数格式。123456console.log(parseInt("")); // NaNconsole.log(parseInt("123abc")); // 123console.log(parseInt("abc123")); // NaNconsole.log(parseInt("10.2")); // 10console.log(parseInt("070")); // 70 (ECMAScript5已经不具备解析八进制的能力，所以认为前导的0无效)console.log(parseInt("0xFWQR")); // 15 parseInt()可以接受第二个参数来指定整数的格式。默认是转换成十进制。1234console.log(parseInt("10", 2)); // 2console.log(parseInt("10", 8)); // 8console.log(parseInt("10", 10)); // 10console.log(parseInt("10", 16)); // 16 parseFloat()函数与parseInt()类似，不同的是parseFloat()解析完成或者遇到第一个无效的浮点数字字符为止，但是第一个小数点是有效的。parseFloat()始终会忽略前导的零，十六进制的字符串始终会被转换成0，由于parseFloat()只解析十进制值，所以布恩那个指定第二个参数，如果字符串包含的是一个可解析成整数的数值，parseFloat()会返回整数。123456console.log(parseFloat("123abc")); // 123console.log(parseFloat("0xF")); // 0console.log(parseFloat("10.5")); // 10.5console.log(parseFloat("10.5.5")); // 10.5console.log(parseFloat("010.5")); // 10.5console.log(parseFloat("10.0")); // 10 ES6数值扩展二进制和八进制表示法ES6提供了新的二进制和八进制数值的新写法，分别用0b和0o表示。12console.log(0b0001); // 1console.log(0o70); // 56 要把二进制和八进制转换成十进制，调用Number()方法。12console.log(Number(0b0001)); // 1console.log(Number(0o70)); // 56 Number.isFinite()、Number.isNaN()这两个方法与传统的全局方法isFinite()和isNaN()相比，这两个新方法只对数值有效。12345console.log(isFinite("10")); // trueconsole.log(Number.isFinite("10")); // falseconsole.log(isNaN("NaN")); // trueconsole.log(Number.isNaN("NaN")); // false Number.parseInt(), Number.parseFloat()与ES5parseInt()和parseFloat()行为完全一样。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 Number.isInteger()用来判断一个数是否为整数。同样能够识别不同格式的整数，如果第一位是零，则忽略。123456console.log(Number.isInteger(10)); // trueconsole.log(Number.isInteger("10")); // falseconsole.log(Number.isInteger(10.0)); // trueconsole.log(Number.isInteger(10.1)); // falseconsole.log(Number.isInteger(010)); // trueconsole.log(Number.isInteger(0xF)); // true Number.EPSILON引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。如果浮点数的计算误差小于Number.EPSILON，我们就可以认为等到了正确的结果。1console.log(Number.EPSILON); // 2.220446049250313e-16 安全整数和Number.isSafeInteger()ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示安全整数范围的上下限。12console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991 Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。1console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1)); //false 验证的时候不止要验证结果是否为安全数，还要验证参与计算的值是否为安全数。 ES6在Math对象上新增了17个与数学相关的方法，新增了4个对数相关方法，新增了6个三角函数方法，一个指数运算符。具体请参考MDN]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记之字符串的扩展]]></title>
    <url>%2F2017%2F05%2F17%2F2017-05-17-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[ES5中字符串的属性和方法lengthSting类型的每个实例都有一个length的属性，表示字符串包含多少个字符。12let stringValue = 'hello';console.log(stringValue.length) // 5 charAt()和charCodeAt()用于访问字符串中特定的字符，两个方法都接受一个参数，即字符所在的下标位置。其中charAt()方法返回下标所在的字符，而charCodeAt()则返回下标对应的字符的字符编码。123let str = 'hello';console.log(str.charAt(1)); // econsole.log(str.charCodeAt(1)); // 101 还可以通过方括号加下标直接取到对应字符12let str = 'hello';console.log(str[1]); // e concat()用于将多个字符拼接起来，返回拼接得到的新字符，不会修改字符串本身的值。123let str = "hello";let result = str.concat(" world","!");console.log(result) //hello world! 但是实际应用中还是用“+”操作符更方便。 slice()、substr()、substring()这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串开始的位置，第二个参数表示子字符串到哪里结束。slice()和substring()的第二个参数指定子字符串最后一个字符的位置(不包含字符本身)。而substr()的第二个参数指定的则是返回的字符个数。如果不给这些方法指定第二个参数，则将字符串的长度作为结束位置。它们都不会修改字符串本身的值。12345678let str = "hello world";console.log(str.slice(3)); // lo worldconsole.log(str.substr(3)); // lo worldconsole.log(str.substring(3)); // lo worldconsole.log(str.slice(3, 7)); // lo wconsole.log(str.substr(3, 7)); // lo worlconsole.log(str.substring(3, 7)); // lo w 如果传递给这些方法的参数是负值，结果就不相同了。 slice()方法会将传入的负值与字符串的长度相加。 substr()将负的第一个参数加上字符串的长度，将负的第二个参数转换为0。 substring()方法会将所有的负的参数转换为0。12345678let str = "hello world";console.log(str.slice(-3)); // rldconsole.log(str.substr(-3)); // rldconsole.log(str.substring(-3)); // hello worldconsole.log(str.slice(3, -4)); // lo wconsole.log(str.substr(3, -4)); // (空字符串)console.log(str.substring(3, -4)); // hel 注意:substring()这个方法始终会将较小的数作为开始位置，较大的数作为结束位置。 indexOf()和lastIndexOf()两个方法都是从字符串中搜索给定的子字符串，然后返回字符串的位置。如果没有找到就返回-1。indexOf()从字符串的开头向后进行搜索，而lastIndexOf()与之相反。123let str = "hello world";console.log(str.indexOf('o')); // 4console.log(str.lastIndexOf('o')); // 7 这两个方法都可以接受第二个参数，指定搜索的起始位置。123let str = "hello world";console.log(str.indexOf('o', 6)); // 7console.log(str.lastIndexOf('o', 6)); // 4 搜索字符串中所有匹配的字符1234567let str = "hello world hello world hello world hello world";let arr = [];let pos = str.indexOf("o");while ( pos &gt; -1)&#123; arr.push(pos); pos = str.indexOf("o", pos+1);&#125; trim()这个方法会创建一个字符串的副本，删除前置及后缀的空格，返回结果，不会修改原始字符串。12let str = " hello world ";console.log(str.trim()); // "hello world" toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()常用的是toLowerCase()和toUpperCase(),toLocaleLowerCase()和toLocaleUpperCase()是针对特定的地区实现的。toUpperCase()小写转大写，toLowerCase()大写转小写。12345let str = "HELLO WORLD";console.log(str.toLowerCase()); // "hello wprld"let str = "hello wprld";console.log(str.toLowerCase()); // "HELLO WORLD" match()在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同，match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。1234let text = "cat, bat, sat, fat";let pattern = /.at/;let matchs = text.match(pattern);console.log(matchs) // ["cat", index: 0, input: "cat, bat, sat, fat"] search()这个方法唯一参数与match()参数相同，search()方法返回字符串第一个匹配项的索引，如果没有找到匹配项，则返回-1。123let text = "cat, bat, sat, fat";var pos = text.search(/at/);console.log(pos) // 1 replace()这个方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串，第二个参数可以是一个字符串或者一个函数。如果第一个参数是一个字符串，就只会替换第一个字符串，如果要替换所有的字符串，就必须要用正则表达式，全局(g)替换。1234567let text = "cat, bat, sat, fat";var result = text.replace("at", "fu");console.log(result); // "cfu, bat, sat, fat"let text = "cat, bat, sat, fat";var result = text.replace(/at/g, "fu");console.log(result); // "cfu, bfu, sfu, ffu" replace()的第二个方法可以是一个函数，在只有一个匹配项的情况下，会向这个函数传递三个参数：模式的匹配项，模式的匹配项在字符串中的位置和原始字符串。1234567891011121314let text = "&lt;p class=\"active\"&gt;Hello world&lt;/p&gt;";let result = text.replace(/[&lt;&gt;"&amp;]/g, function (match, pos, oldText) &#123; switch (match) &#123; case "&lt;" : return "&amp;lt;"; case "&gt;" : return "&amp;gt;"; case "&amp;" : return "&amp;amp;"; case "\"" : return "&amp;quot;"; &#125;&#125;);console.log(result) // "&amp;lt;p class=&amp;quot;active&amp;quot;&amp;gt;Hello world&amp;lt;/p&amp;gt;" split()这个方法可以基于指定的分隔符把一个字符串分割成多个子字符串，并将结果放在一个数组里面。分隔符可以是字符串，也可以是RegExp对象。split()方法可以接受可选的第二个参数，用于指定数组的大小。123let color = "red, yellow, green, pink";let color1 = color.split(","); // ["red", " yellow", " green", " pink"]let color2 = color.split(",", 2); // ["red", " yellow"] localeCompare()这个方法用于比较两个字符串，并返回下列结果之一: 如果字符串在字母表中位置在参数之前，则返回一个负数 字符串等于参数，返回0 如果字符串在字母表中位置在参数之后，返回一个正数 1234let str = "yellow";console.log(str.localeCompare("black")); // 1console.log(str.localeCompare("yellow")); // 0console.log(str.localeCompare("zoom")); // -1 注意:localeCompare()返回的数值取决于实现，不一定是1， -1， 0。 String.fromCharCode()这个方法是接收一个或多个字符编码，然后转换成字符串。1console.log(String.fromCharCode(104, 101, 108, 108, 111)); // hello ES6字符串的扩展javascript允许采用\uxxxx表示一个字符，但是只限于码点在\u0000~\uFFFF之间，超出这个范围的字符就必须用双字节表示。12console.log("\uD842\uDFB7"); // "𠮷"console.log("\u20BB7"); // " 7" 但是ES6只要将码点放入大括号中， 就能正确解读。1console.log("\u&#123;20BB7&#125;"); // "𠮷" codePointAt()codePointAt()方法能够正确处理四个字节的字符（Unicode码点大于0xFFFF的字符），返回一个字符的码点（十进制）。1234let str = '𠮷a';console.log(str.codePointAt(0).toString(16)); // "20bb7"console.log(str.codePointAt(1)); // "dfb7"console.log(str.codePointAt(2)); // "61" 可以看出codePointAt()的参数任然是不对的，要取到a必须的传入2才能取到，要解决这种问题可以用for...of循环实现，因为它会正确识别32位的UTF-16字符。1234let str = '𠮷a';for(let c of str)&#123; console.log(c.codePointAt(0).toString(16)); //"20bb7" "61"&#125; codePointAt()是判断一个字符是由两字节组成还是四字节组成最简单的办法。12345function isBit(value)&#123; return value.codePointAt(0) &gt; 0xFFFF;&#125;console.log(isBit("𠮷")); // trueconsole.log(isBit("a")); // false String.fromCodePoint()用于从码点返回对应字符，能够识别Unicode编号大于0xFFFF的字符。1String.fromCodePoint(0x20BB7) // "𠮷" ###字符串的遍历接口ES6新增字符串遍历接口，字符串可以用for...of循环遍历。1234let str = "hello";for(let s of str)&#123; console.log(s) // "h" "e" "l" "l" "o"&#125; 这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。12345678let str = "𠮷";for(let i = 0; i &lt; str.length; i++)&#123; console.log(str[i]) // � � (打印出来是这种无法识别的符号)&#125;for(let s of str)&#123; console.log(s) // "𠮷"&#125; includes()、startsWith()、endsWith() includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在源字符串头部 endsWith()：返回布尔值，表示参数字符串是否在源字符串尾部1234let str = "hello world!";console.log(str.includes("hello")); // trueconsole.log(str.startsWith("hello")); // trueconsole.log(str.endsWith("!")); // true 这三个方法都可以接受第二个参数，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。1234 let str = "hello world!";console.log(str.includes("world", 6))console.log(str.startsWith("world", 6 ))console.log(str.endsWith("hello", 5)) repeat()这个方法接收一个参数，表示要将原字符重复的次数。123let str = "abc";console.log( str.repeat(3)) // "abcabcabc"console.log( str.repeat(0)) // "" 如果参数不是正整数，则有下面几种情况： 如果参数是小数，会被取整 如果是负数或者是Infinity，会报错 如果是0~-1之间的小数，则为0 如果是NaN，则为0 如果是字符串，则会先转换成数字 padStart()和padEnd()字符串自动补全功能，如果字符串不够长度，会在头部或者尾部补全。这两个方法都可接收两个参数，第一个参数指定字符串的最小长度，第二个参数则是用来补全的字符串。12345console.log( 'x'.padStart(5, 'ab')); // "ababx"console.log( 'x'.padStart(4, 'ab')) // "abax"console.log( 'x'.padEnd(5, 'ab')); // "xabab"console.log( 'x'.padEnd(4, 'ab')); // "xaba" 当原字符串的长度大于指定的最小长度的时候，返回原字符串本身。1console.log( 'xxxxxxx'.padStart(5, 'ab')); // "xxxxxxx" 如果用来补全的字符串与原字符串长度的和大于指定的最小长度的时候，则会截取超出指定的最小长度的字符。1console.log( 'xxx'.padStart(10, '0123456789')); // "0123456xxx" 如果省略第二个参数，默认使用空格补全长度。12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。1'1'.padStart(10, '0') // "0000000001" 另一个用途是提示字符串格式。12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。123456789// 普通字符串`hello world!`;//多行字符串`How are youI'm fine`//字符串中嵌入变量let name="Tom";let age = 20;`my name is $&#123;name&#125;, I'm $&#123;age&#125; years old`; 模板中使用多行字符串，空格和缩进会保留在输出之中。1234567 let str = ` &lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;ul&gt;`;console.log(str) 效果图如下 模板字符串中嵌入变量，需要将变量名写在${}中。大括号内可以放任意的JavaScript表达式1234567891011let x = 1, y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;` // "1 + 2 = 3"let obj = &#123;x : 1, y : 2&#125;;`$&#123;obj.x&#125; + $&#123;obj.y&#125; = $&#123;obj.x + obj.y&#125;` // "1 + 2 = 3"function fn()&#123; return "hello world";&#125;`Hi, $&#123;fn()&#125;` // "Hi, hello world" 模板字符串中的变量没有声明，就会报错。1`hello, $&#123;text&#125;` // Uncaught ReferenceError: text is not defined 模板字符串的大括号内部是一个字符串，将会原样输出。1`hello, $&#123;'world'&#125;` // "hello, world" 标签模板模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。如果模板字符串里面有变量，就会将模板字符串先处理成多个参数，再调用函数。123456789let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;function tag(arr, value1, value2)&#123; console.log(arr); // ["Hello ", " world ", "", raw: Array(3)] console.log(value1); // 15 console.log(value2); // 50&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分。其他参数，都是模板字符串各个变量被替换后的值。 String.raw()String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。1console.log(String.raw`Hi\n$&#123;2+3&#125;!` === "Hi\\n5!") // true 如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。1console.log(String.raw`Hi\\n$&#123;2+3&#125;!`) // "Hi\\n5!" String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记之变量的解构赋值]]></title>
    <url>%2F2017%2F05%2F16%2F2017-05-16-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[数组的解构赋值 基本用法 ES6运行按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructuring)。 假设我们有一个变量arr，其值为[1, 2, 3]，我们想给数组的每个元素分别声明一个变量，在ES5中的做法就是单独取出来赋值。1234let arr = [1, 2, 3];let el1 = arr[0], el2 = arr[1], el3 = arr[2]; 现在ES6允许我们在左边使用表达式来达到和上面代码一样的效果。1let [el1, el2, el3] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。这种写法属于“模式匹配”，只要等号两边模式相同，左边的变量就会被赋予对应的值。同样的，数组还可以进行嵌套。1234let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3 如果解构不成功，变量的值就被赋予undefined，就是等号左边模式匹配不到等号右边数组的值。12345let [a] = [];a // undefinedlet [a, b] = [1];a // 1b // undefined 如果是不完全解构，就是等号左边的模式，只匹配一部分等号右边数组的值，解构依然可以成功。123456let [a, b, c] = [1, 2]a // 1b // 2let [a, [b, c]] = [1, [2]]a // 1b // 2 如果等号右边不是数组，就会报错123456let [a] = 1;let [a] = true;let [a] = NaN;let [a] = undefined;let [a] = null;let [a] = &#123;&#125;; 默认值解构赋值允许指定默认值。12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a'] //x = 'a', y = 'b'let [x, y = 'b'] = ['a', undefined]; //x = 'a', y = 'b' ES6使用全等运算符判断一个位置是否有值，所以一个数组成员不严格等于undefined，默认值是不会生效的。12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 如果默认值是表达式，那么这表达式则是惰性求值。用到的时候才会求值。1234let [x = f()] = [1];function f()&#123; alert(1)&#125; 上面代码因为x能取到值，所以函数不会执行，只有当等号右边数值的值为undefined时，函数才会执行。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。12345let [x = 1, y = x] = [2];x // 2y // 2let [x = y, y = 1] = []; // ReferenceError 上面报错是因为x用y作为默认值的时候，y还没有声明。 对象的解构赋值基本用法对象的解构与数组有一个很重要的不同，数组的元素是按次序排列的，变量的取值由位置决定，而对象的属性是没有次序的，变量必须要与属性同名才能取到值。123456let &#123;bar, foo&#125; = &#123;foo: "aa", bar: "bb"&#125;;foo // aabar // bblet &#123;baz&#125; = &#123;foo: "aa", bar: "bb"&#125;;baz // undefined 如果变量名与属性名不一致，必须写成下面的形式。123456let obj = &#123;first: 'hello', last: 'world'&#125;;let &#123;first: f, last: l&#125; = obj;f // hellol // worldfirst // ReferenceErrorlast // ReferenceError 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。first是匹配的模式，f才是变量。 用let或者const声明过的变量再通过这种方式重新声明会报错。12let a;let &#123;a, b&#125; = &#123;a: 1, b : 2&#125; // ReferenceError 对象解构同样可以用于嵌套。123456789let obj = &#123; a: [ 'hello', &#123;y: 'world'&#125; ]&#125;;let &#123;a:[x, &#123;y&#125;]&#125; = obj;x // helloy // world 对象解构也可以指定默认值。默认值生效的条件是对象的属性值严格等于undefined。12345678910111213let &#123;x = 1&#125; = &#123;&#125;;x // 1let &#123;x = 1&#125; = &#123;x: 3&#125;;x // 3let &#123;x:y = 1&#125; = &#123;&#125;;y // 1let &#123;x:y = 1&#125; = &#123;x:3&#125;;y // 3let &#123;x = 1&#125; = &#123;x: undefined&#125;;x // undefinedlet &#123;x = 1&#125; = &#123;x: null&#125;;x // null 解构失败，变量的值等于undefined。12let &#123;baz&#125; = &#123;foo: "aa", bar: "bb"&#125;;baz // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。12let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;;bar // ReferenceError 因为等号左边的foo属性在等号右边不存在，所以为undefined，而bar是foo下面的一个子属性undefined.bar肯定就会报错。 如果要将一个已经声明的变量用于解构赋值，需要小心。123let x;&#123;x&#125; = &#123;x: 1&#125;;x // Unexpected token = 上面代码报错是因为JavaScript引擎将{x}解析成一个代码块，所以导致错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。123let x;(&#123;x&#125; = &#123;x: 1&#125;);x // 1 将代码放在一个圆括号里面就可以正确执行。 对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量。1let &#123;log, sin, cos&#125; = Math 字符串的解构赋值基本用法字符串也可以解构赋值，被转化成一个类数组的对象。123456let [a, b, c, d, e] = "hello";a // hb // ec // ld // le // o 每个类数组的对象都有个length属性，还可以对这个属性进行解构赋值。12let &#123;length: len&#125; = "hello";len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 函数参数的解构赋值函数参数也可以使用解构赋值。1234function fn([a, b])&#123; return a + b;&#125;fn([1, 2]) // 3 函数被传入参数的时候，数组参数就被解构成了x和y。 函数参数的解构也可以使用默认值。1234567function fn(&#123;x = 0, y = 0&#125; = &#123;&#125;)&#123; return [x, y]&#125;fn(&#123;x: 3, y:5&#125;) // [3, 5]fn(&#123;x: 3&#125;) // [3, 0]fn(&#123;&#125;) // [0, 0]fn() // [0, 0] 而下面的代码会得到不一样的结果。12345678function fn(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;fn(&#123;x: 3, y: 8&#125;); // [3, 8]fn(&#123;x: 3&#125;); // [3, undefined]fn(&#123;&#125;); // [undefined, undefined]fn(); // [0, 0] 上面代码是为函数fn的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 不能使用圆括号的情况 变量声明语句不能带有圆括号，包括函数的参数。123456let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;function f([(z)]) &#123; return z; &#125; 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。123(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 可以使用圆括号的情况赋值语句的非模式部分，可以使用圆括号。123[(b)] = [3]; (&#123; p: (d) &#125; = &#123;&#125;); [(parseInt.prop)] = [3]; 用途交换变量的值123let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值1234function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example(); 函数参数的定义1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css之position属性]]></title>
    <url>%2F2017%2F05%2F15%2F2017-05-15-css%E4%B9%8Bposition%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[简介 position CSS属性选择用于定位元素的替代规则，被设计为对脚本动画效果有用。 语法1234567891011/* 关键字 值 */position: static;position: relative;position: absolute;position: fixed;position: sticky; //实验性API/* 全局值 */position: inherit;position: initial;position: unset; static 元素默认定位属性默认值。没有定位，元素出现在正常的文档流中，忽略top, right, bottom, left, z-index声明。 relative 相对定位相对自己文档流中的原始位置进行定位，不会脱离文档流。上图给test4加上了position:relative效果，代码如下1position: relative; top:10px; left:-20px 可以看出test4并没有对周围的元素造成影响， 它还是存在于正常的文档流中。position:relative对 table-*-group, table-row, table-column, table-cell, table-caption 元素没有效果。 absolute 绝对定位 相对于static定位以外的第一个父元素进行定位， 脱离文档流上图给test4加上了position:absolute效果明显可以看到test4从正常的文档流中脱离了出来， test5填补了test4原本的位置。 绝对定位元素可以设置外边距，且不会与其他边距合并CSS代码 12345678910111213141516171819202122body&#123; margin: 0; padding: 0;&#125;.box &#123; position: relative; width: 500px; height: 200px; background: lightseagreen; margin: 30px&#125;.box1 &#123; position: absolute; top: 0; left: 0; margin: 20px; width: 100px; height: 50px; background: red&#125;eight: 50px;background: red&#125; HTML代码123&lt;div class="box"&gt; &lt;div class="box1"&gt;absolute定位元素&lt;/div&gt;&lt;/div&gt; 效果图 stickyposition:sticky是一个新的CSS3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置CSS代码12345678910111213141516171819202122.container &#123; background: #eee; width: 600px; height: 1000px; margin: 0 auto;&#125;.sticky-box &#123; position: -webkit-sticky; position: sticky; height: 60px; margin-bottom: 30px; background: #ff7300; top: 0px;&#125;div &#123; font-size: 30px; text-align: center; color: #fff; line-height: 60px;&#125; HTML代码123456&lt;div class="container"&gt; &lt;div class="sticky-box"&gt;内容1&lt;/div&gt; &lt;div class="sticky-box"&gt;内容2&lt;/div&gt; &lt;div class="sticky-box"&gt;内容3&lt;/div&gt; &lt;div class="sticky-box"&gt;内容4&lt;/div&gt;&lt;/div&gt; 效果图因为设定的阈值是 top:0 ，这个值表示当元素距离页面视口（Viewport，也就是fixed定位的参照）顶部距离大于 0px 时，元素以 relative 定位表现，而当元素距离页面视口小于 0px 时，元素表现为 fixed 定位，也就会固定在顶部。浏览器支持情况IOS 家族（SAFARI &amp;&amp; IOS SAFARI）和 Firefox 很早开始就支持 position:sticky 了。而 Chrome53~55 则需要启用实验性网络平台功能才行。其中 webkit 内核的要添加上私有前缀 -webkit-。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记之let和const命令]]></title>
    <url>%2F2017%2F05%2F15%2F2017-05-15-ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Blet%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近一直在看阮大神的ECMAScript 6入门这本书，边学边记，加深印象。 let和const命令ES5只有两种声明变量的方法：var命令和function命令。而ES6新增了四种声明变量的方法:let、const、import和class，所以ES6有6种声明变量的方法。 let命令 基本用法let用来声明变量， 用法类似于var，但是只在let命令所在的代码块有效。1234for(var i = 0; i &lt; 10; i++)&#123;&#125;;console.log(i) // 10for(let i = 0; i &lt; 10; i++)&#123;&#125;console.log(i) // 报错 不存在变量提升var声明的变量的能在变量声明之前访问，值为undefined，因为在脚本运行之前，变量foo已经存在，但是没有值，所以会输出undefined。12console.log(a); // undefinedvar a = 'hello'; 如果用let来声明的变量在没有声明之前就进行访问的话，会抛出异常。12console.log(a); // Uncaught ReferenceError: a is not definedvar let = 'hello'; 暂时性死区在代码块内，使用let命令声明变量之前，该变量都是不可用的。12345678if(true)&#123; tmp = "hello"; console.log(tmp); // ReferenceError let tmp; console.log(tmp); // undefined tmp = "abc"; console.log(tmp)&#125; 上图说明在第四行用let声明变量tmp之前，都属于tmp的死区。注意如果在let声明变量之前用typeof检测数据类型的话，会抛出异常。12console.log(typeof x); // ReferenceErrorlet x = 1; 不允许重复声明let不允许在相同的作用域内重复声明同一个变量123function fn(arg)&#123; let arg;&#125; 上面代码会抛出异常，改成下面这样就不会了。12345function fn(arg)&#123; &#123; let arg; &#125;&#125; 块级作用域ES5只有全局作用域和函数作用域,而ES6新增了块级作用域。 ES6允许块级作用于任意嵌套1&#123;&#123;&#123;&#123;&#123;let a = 0&#125;&#125;&#125;&#125;&#125; 上图使用了5五层块级作用域。 外层作用域无法读取内层作用域的变量 1234&#123;&#123;&#123;&#123; &#123;let a = 0&#125; console.log(a); // ReferenceError&#125;&#125;&#125;&#125; 不同作用域可以定义同名变量 12345678&#123;&#123;&#123;&#123; let a = 1; &#123; let a = 0; console.log(a) // 0 &#125; console.log(a) // 1&#125;&#125;&#125;&#125; const命令基本用法const声明一个只读的常量，一旦声明，值就不可以改变。123const PI = 3.1415;PI = 3.14;console.log(PI) // Assignment to constant variable const一旦声明变量，必须立即初始化。123const foo ;foo = "hello";console.log(foo); // Missing initializer in const declaration const和let相同，声明的变量只有在其所在的块级作用于有效，变量不会提升，同时也存在“暂时性死区”。 本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。 意思就是说用const声明的基本数据的变量是不可以改变值，而引用数据类型（主要是对象和数值）,const只能保证指针是固定的，而指向的数据是可以进行变化的。12345const foo = &#123;&#125;;foo.name = "Tom";console.log(foo); // &#123;name: "Tom"&#125;foo = &#123;&#125;; // 当把foo指向另一个对象的时候就会报错 12345const arr = [];arr.push("hello");console.log(arr); ["hello"]arr = []; // Assignment to constant variable. 如果要冻结一个对象，应该使用Object.freeze方法。123const foo = Object.freeze(&#123;&#125;);foo.name = "Tom";console.log(foo) // &#123;&#125; 常规模式下，添加属性不起作用1234"use strict";const foo = Object.freeze(&#123;&#125;);foo.name = "Tom";console.log(foo) // Cannot add property name, object is not extensible 在严格模式下会抛出异常 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数 - . -暂时没有理解到这个方法，先直接拷过来用。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之float属性]]></title>
    <url>%2F2017%2F05%2F12%2F2017-05-12-CSS%E4%B9%8Bfloat%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[概述 CSS的float属性可以使一个元素脱离正常的文档流，然后被安放在它所在容器的左端或者右端，并且其他的文本和行内元素环绕它。 float属性介绍 left: 元素向左浮动 float: 元素向右浮动 none: 默认值 inherit： 默认值 由于float使用了块布局， 所以它会改变display的计算值 指定值 计算值 inline block inline-block block inline-table table table-row block table-row-group block table-column block tabale-column-group block tabel-cell block table-caption block table-header-group block table-footer-group block flex flex,float对这样的元素不起作用 inline-flex inline-flex, float对这样的元素不起作用 浮动元素是如何定位的当一个元素浮动后，它会被移除正常的文档流，然后向左或是向右平移，一直平移到碰到了所处容器的边缘或者碰到另外一个浮动元素。不管一个元素是行内元素还是块级元素，如果被设置了浮动，那浮动元素会生成一个块级框，可以设置它的width和height 浮动元素的一些特性 浮动元素浮动的时候， margin不会超过包含块的padding CSS代码12.box&#123; width: 200px; height: 500px; background: lightseagreen; padding: 10px&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin: 20px&#125; HTML代码123&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt;&lt;/div&gt; 效果图 如果有多个浮动元素，后面浮动元素的margin不会超过前面浮动元素的margin, 多个浮动元素，浮动元素会按顺序排列而不发生重叠现象 CSS代码12.box&#123; width: 400px; height: 500px; background: lightseagreen; padding: 10px&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin: 10px; float: left&#125; HTML代码123456&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box1"&gt;&lt;/div&gt;&lt;/div&gt; 效果图 如果两个元素一个左浮动，一个右浮动，左浮动元素的marginRinght和右浮动的marginLeft不会重叠 CSS代码123.box&#123; width: 219px; height: 500px; background: lightseagreen;&#125;.box1&#123; width: 100px; height: 50px; background: orangered; margin-right: 10px; float: left&#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left&#125; HTML代码1234&lt;div class="box"&gt; &lt;div class="box1"&gt;左浮动元素&lt;/div&gt; &lt;div class="box2"&gt;右浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 浮动元素重叠问题 块级元素与浮动元素发生重叠，边框和背景会显示在浮动元素之下，内容会显示在浮动元素之上CSS123.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;.box1&#123;background: blue; border: 1px solid #000&#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left; margin-top: -10px&#125; HTML1234&lt;div class="box"&gt; &lt;div class="box1"&gt;我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字&lt;/div&gt; &lt;div class="box2"&gt;右浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 行内元素与浮动元素发生重叠，其边框，背景和内容都会显示在浮动元素之上CSS123.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;span&#123; background: palevioletred; &#125;.box2&#123; width: 100px; height: 50px; background: orangered; margin-left: 10px; float: left; margin-top: -10px&#125; HTML1234&lt;div class="box"&gt; &lt;span&gt;我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字我是文字文字&lt;/span&gt; &lt;div class="box2"&gt;浮动元素&lt;/div&gt;&lt;/div&gt; 效果图 清除浮动的方法 增加额外的div1&lt;div style="clear: both"&gt;&lt;/div&gt; 优点：简单粗暴缺点: 增加额外的无意义的标签，不利于语义化 父级元素增加overflow: hidden(关键在于触发了BFC)1.clearfix&#123; overflow:hidden&#125; 优点：代码量少，没有额外的标签缺点： 如果子元素超出父元素的范围，会造成超出的部分被隐藏 after伪类12clearfix&#123;zoom:1&#125;clearfix:after&#123;display:block; content:""; clear:both; visibility: hidden;&#125; 优点：没有额外标签，综合起来算比较好的方法缺点：稍显复杂推荐使用这种方法 float应用场景float最初应用就是文字环绕效果CSS代码12.box&#123; width: 400px; height: 500px; background: lightseagreen;&#125;img&#123; float: left&#125; HTML代码1234&lt;div class="box"&gt; &lt;img src="demo6.png" alt=""&gt; 文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕文字环绕&lt;/div&gt; 效果图 还可用于横向菜单排列，但是更推荐使用display:inline-block,除了文字环绕效果，在其他几乎所有的应用场景中，float能实现的效果，display:inline-block都能实现。推荐一篇张鑫旭大神的关于float的文章,写的特别有意思。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的数组去重]]></title>
    <url>%2F2017%2F05%2F07%2F2017-05-07-js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[判断浏览器是否支持indexOf方法123456789101112131415161718//判断是否支持indexOf方法if(!Array.prototype.indexOf)&#123; Array.prototype.indexOf = function (item)&#123; var result = -1; //数组为空的时候返回-1 if (this.length == 0) &#123; return result; &#125;; for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] === item) &#123; //当当前项的值与参数值相等的时候，结束循环 result = i; break; &#125; &#125;; return result; &#125;;&#125; 遍历数组法：新建一新数组，遍历数组，值不在新数组中就加入新数组1234567891011function unique(array)&#123; //新建数组 var newArr = []; for(var i = 0; i &lt; arr.length; i++)&#123; //值不在新数组中就添加到新数组 if(newArr.indexOf(array[i]) == -1)&#123; newArr.push(array[i]); &#125; &#125;; return newArr &#125; 对象键值法：该方法执行速度比其他任何方法都快，就是占用内存大一些。新建一JS对象和数组，遍历传入数组时，判断值是否为JS对象的值，不是的话给对象新增该键并放入新数组。注意点，判断是否为JS对象键时，会自动对传入的键执行”toString()”,不同的键可能会被误认为一样。12345678910111213141516171819202122function unique(array)&#123; var obj = &#123;&#125;, newArr = [], len = array.length, val, type; for (var i = 0; i &lt; len; i++) &#123; val = array[i]; //获取值的数据类型 type = typeof val; //判断值是否存在 if (!obj[val]) &#123; //把type以数组的形式存入便于用indexOf对比 obj[val] = [type]; newArr.push(val); &#125; else if(obj[val].indexOf(type) &lt; 0) &#123; //值存在的情况下判断是否是相同的数据类型 obj[val].push(type); newArr.push(val); &#125; &#125; return newArr; &#125; 数组下标判断法：当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的。12345678910function unique(array)&#123; var newArr = [array[0]]; for (var i = 1; i &lt; array.length; i++) &#123; //判断第i项出现位置下标 if (array.indexOf(array[i]) == i) &#123; newArr.push(array[i]) &#125;; &#125; return newArr; &#125; 排序后相邻去除法：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。123456789101112function unique(array)&#123; //先排序 array.sort(); var newArr = [array[0]]; for (var i =1; i &lt; array.length; i++) &#123; //newArr最后一项就是array[i]的前一项 if(array[i] !== newArr[newArr.length - 1])&#123; newArr.push(array[i]); &#125;; &#125;; return newArr; &#125; 获取没重复的最右一值放入新数组。检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断1234567891011121314function unique(array)&#123; var r = []; for(var i = 0, len = array.length; i &lt; len; i++)&#123; for(var j = i + 1; j &lt; len; j++)&#123; if(array[i] === array[j])&#123; //当两个值相同的时候,i在内循环自增1，相当于跳出本次循环，执行下一次，当前值就不能添加到新数组 j = ++i; &#125;; &#125; r.push(array[i]); &#125;; return r; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>