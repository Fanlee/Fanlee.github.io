---
title: ES6学习笔记之变量的解构赋值
date: 2017-05-16
categories: 学习笔记
tags: ES6
keywords: ES6
comments: true

---
## 数组的解构赋值


----------
### 基本用法
>ES6运行按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructuring)。

假设我们有一个变量`arr`，其值为[1, 2, 3]，我们想给数组的每个元素分别声明一个变量，在ES5中的做法就是单独取出来赋值。
```
let arr = [1, 2, 3];
let el1 = arr[0],
    el2 = arr[1],
    el3 = arr[2];

```
现在ES6允许我们在左边使用表达式来达到和上面代码一样的效果。
```
let [el1, el2, el3] = [1, 2, 3];
```
上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。这种写法属于“模式匹配”，只要等号两边模式相同，左边的变量就会被赋予对应的值。同样的，数组还可以进行嵌套。
```
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3
```
如果解构不成功，变量的值就被赋予`undefined`，就是等号左边模式匹配不到等号右边数组的值。
```
let [a] = [];
a // undefined
let [a, b] = [1];
a // 1
b // undefined
```
如果是不完全解构，就是等号左边的模式，只匹配一部分等号右边数组的值，解构依然可以成功。
```
let [a, b, c] = [1, 2]
a // 1
b // 2
let [a, [b, c]] = [1, [2]]
a // 1
b // 2
```
如果等号右边不是数组，就会报错
```
let [a] = 1;
let [a] = true;
let [a] = NaN;
let [a] = undefined;
let [a] = null;
let [a] = {};
```
### 默认值
解构赋值允许指定默认值。
```
let [foo = true] = [];
foo // true

let [x, y = 'b'] = ['a'] //x = 'a', y = 'b'
let [x, y = 'b'] = ['a', undefined]; //x = 'a', y = 'b'
```
ES6使用全等运算符判断一个位置是否有值，所以一个数组成员不严格等于`undefined`，默认值是不会生效的。
```
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
```
如果默认值是表达式，那么这表达式则是惰性求值。用到的时候才会求值。
```
let [x = f()] = [1];
function f(){
  alert(1)
}
```
上面代码因为`x`能取到值，所以函数不会执行，只有当等号右边数值的值为`undefined`时，函数才会执行。

默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
```
let [x = 1, y = x] = [2];
x // 2
y // 2

let [x = y, y = 1] = []; // ReferenceError
```
上面报错是因为`x`用`y`作为默认值的时候，`y`还没有声明。


----------
## 对象的解构赋值
### 基本用法
对象的解构与数组有一个很重要的不同，数组的元素是按次序排列的，变量的取值由位置决定，而对象的属性是没有次序的，变量必须要与属性同名才能取到值。
```
let {bar, foo} = {foo: "aa", bar: "bb"};
foo // aa
bar // bb

let {baz} = {foo: "aa", bar: "bb"};
baz // undefined
```

如果变量名与属性名不一致，必须写成下面的形式。
```
let obj = {first: 'hello', last: 'world'};
let {first: f, last: l} = obj;
f // hello
l // world
first // ReferenceError
last // ReferenceError
```
也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。`first`是匹配的模式，`f`才是变量。

用`let`或者`const`声明过的变量再通过这种方式重新声明会报错。
```
let a;
let {a, b} = {a: 1, b : 2} // ReferenceError
```
对象解构同样可以用于嵌套。
```
let obj = {
 a: [
   'hello',
   {y: 'world'}
 ]
};
let {a:[x, {y}]} = obj;
x // hello
y // world
```
对象解构也可以指定默认值。默认值生效的条件是对象的属性值严格等于`undefined`。
```
let {x = 1} = {};
x // 1
let {x = 1} = {x: 3};
x // 3
let {x:y = 1} = {};
y // 1
let {x:y = 1} = {x:3};
y // 3

let {x = 1} = {x: undefined};
x // undefined
let {x = 1} = {x: null};
x // null
```
解构失败，变量的值等于`undefined`。
```
let {baz} = {foo: "aa", bar: "bb"};
baz // undefined
```
如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。
```
let {foo: {bar}} = {baz: 'baz'};
bar // ReferenceError
```
因为等号左边的foo属性在等号右边不存在，所以为`undefined`，而bar是foo下面的一个子属性`undefined.bar`肯定就会报错。

如果要将一个已经声明的变量用于解构赋值，需要小心。
```
let x;
{x} = {x: 1};
x // Unexpected token =
```
上面代码报错是因为JavaScript引擎将`{x}`解析成一个代码块，所以导致错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。
```
let x;
({x} = {x: 1});
x // 1
```
将代码放在一个圆括号里面就可以正确执行。

对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量。
```
let {log, sin, cos} = Math
```


----------
## 字符串的解构赋值
### 基本用法
字符串也可以解构赋值，被转化成一个类数组的对象。
```
let [a, b, c, d, e] = "hello";
a // h
b // e
c // l
d // l
e // o
```
每个类数组的对象都有个`length`属性，还可以对这个属性进行解构赋值。
```
let {length: len} = "hello";
len // 5
```


----------
## 数值和布尔值的解构赋值
解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
```
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```
上面代码中，数值和布尔值的包装对象都有`toString`属性，因此变量s都能取到值。

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。


----------
## 函数参数的解构赋值
函数参数也可以使用解构赋值。
```
function fn([a, b]){
 return a + b;
}
fn([1, 2]) // 3
```
函数被传入参数的时候，数组参数就被解构成了`x`和`y`。

函数参数的解构也可以使用默认值。
```
function fn({x = 0, y = 0} = {}){
  return [x, y]
}
fn({x: 3, y:5}) // [3, 5]
fn({x: 3}) // [3, 0]
fn({}) // [0, 0]
fn() // [0, 0]
```
而下面的代码会得到不一样的结果。
```
function fn({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

fn({x: 3, y: 8}); // [3, 8]
fn({x: 3}); // [3, undefined]
fn({}); // [undefined, undefined]
fn(); // [0, 0]
```
上面代码是为函数`fn`的参数指定默认值，而不是为变量`x`和`y`指定默认值，所以会得到与前一种写法不同的结果。


----------
## 不能使用圆括号的情况

 1. 变量声明语句不能带有圆括号，包括函数的参数。
 ```
 let [(a)] = [1];
 let {x: (c)} = {};
 let ({x: c}) = {};
 let {(x: c)} = {};
 let {(x): c} = {};
 function f([(z)]) { return z; }
 ```
 
 2. 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。
```
({ p: a }) = { p: 42 };
([a]) = [5];
[({ p: a }), { x: c }] = [{}, {}];
```


----------
## 可以使用圆括号的情况
赋值语句的非模式部分，可以使用圆括号。
```
[(b)] = [3]; 
({ p: (d) } = {}); 
[(parseInt.prop)] = [3]; 
```


----------
## 用途

交换变量的值
```
 let x = 1;
 let y = 2;
 [x, y] = [y, x];
```
 
从函数返回多个值
```
 function example() {
  return [1, 2, 3];
 }
 let [a, b, c] = example();
```

函数参数的定义
```
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
```
提取JSON数据
```
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, "OK", [867, 5309]
```
函数参数的默认值
```
jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};
```


